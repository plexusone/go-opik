// Code generated by ogen, DO NOT EDIT.

package api

import (
	"math/bits"
	"strconv"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/google/uuid"
	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

// Encode implements json.Marshaler.
func (s *AggregationData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AggregationData) encodeFields(e *jx.Encoder) {
	{
		if s.ExperimentCount.Set {
			e.FieldStart("experiment_count")
			s.ExperimentCount.Encode(e)
		}
	}
	{
		if s.TraceCount.Set {
			e.FieldStart("trace_count")
			s.TraceCount.Encode(e)
		}
	}
	{
		if s.TotalEstimatedCost.Set {
			e.FieldStart("total_estimated_cost")
			s.TotalEstimatedCost.Encode(e)
		}
	}
	{
		if s.TotalEstimatedCostAvg.Set {
			e.FieldStart("total_estimated_cost_avg")
			s.TotalEstimatedCostAvg.Encode(e)
		}
	}
	{
		if s.Duration.Set {
			e.FieldStart("duration")
			s.Duration.Encode(e)
		}
	}
	{
		if s.FeedbackScores != nil {
			e.FieldStart("feedback_scores")
			e.ArrStart()
			for _, elem := range s.FeedbackScores {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ExperimentScores != nil {
			e.FieldStart("experiment_scores")
			e.ArrStart()
			for _, elem := range s.ExperimentScores {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfAggregationData = [7]string{
	0: "experiment_count",
	1: "trace_count",
	2: "total_estimated_cost",
	3: "total_estimated_cost_avg",
	4: "duration",
	5: "feedback_scores",
	6: "experiment_scores",
}

// Decode decodes AggregationData from json.
func (s *AggregationData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AggregationData to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "experiment_count":
			if err := func() error {
				s.ExperimentCount.Reset()
				if err := s.ExperimentCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"experiment_count\"")
			}
		case "trace_count":
			if err := func() error {
				s.TraceCount.Reset()
				if err := s.TraceCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trace_count\"")
			}
		case "total_estimated_cost":
			if err := func() error {
				s.TotalEstimatedCost.Reset()
				if err := s.TotalEstimatedCost.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_estimated_cost\"")
			}
		case "total_estimated_cost_avg":
			if err := func() error {
				s.TotalEstimatedCostAvg.Reset()
				if err := s.TotalEstimatedCostAvg.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_estimated_cost_avg\"")
			}
		case "duration":
			if err := func() error {
				s.Duration.Reset()
				if err := s.Duration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration\"")
			}
		case "feedback_scores":
			if err := func() error {
				s.FeedbackScores = make([]FeedbackScoreAverage, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem FeedbackScoreAverage
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.FeedbackScores = append(s.FeedbackScores, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"feedback_scores\"")
			}
		case "experiment_scores":
			if err := func() error {
				s.ExperimentScores = make([]FeedbackScoreAverage, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem FeedbackScoreAverage
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ExperimentScores = append(s.ExperimentScores, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"experiment_scores\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AggregationData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AggregationData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AggregationData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AlertPagePublic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AlertPagePublic) encodeFields(e *jx.Encoder) {
	{
		if s.Page.Set {
			e.FieldStart("page")
			s.Page.Encode(e)
		}
	}
	{
		if s.Size.Set {
			e.FieldStart("size")
			s.Size.Encode(e)
		}
	}
	{
		if s.Total.Set {
			e.FieldStart("total")
			s.Total.Encode(e)
		}
	}
	{
		if s.Content != nil {
			e.FieldStart("content")
			e.ArrStart()
			for _, elem := range s.Content {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.SortableBy != nil {
			e.FieldStart("sortable_by")
			e.ArrStart()
			for _, elem := range s.SortableBy {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfAlertPagePublic = [5]string{
	0: "page",
	1: "size",
	2: "total",
	3: "content",
	4: "sortable_by",
}

// Decode decodes AlertPagePublic from json.
func (s *AlertPagePublic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AlertPagePublic to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "page":
			if err := func() error {
				s.Page.Reset()
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "size":
			if err := func() error {
				s.Size.Reset()
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "total":
			if err := func() error {
				s.Total.Reset()
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "content":
			if err := func() error {
				s.Content = make([]AlertPublic, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AlertPublic
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Content = append(s.Content, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		case "sortable_by":
			if err := func() error {
				s.SortableBy = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.SortableBy = append(s.SortableBy, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sortable_by\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AlertPagePublic")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AlertPagePublic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AlertPagePublic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AlertPublic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AlertPublic) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Enabled.Set {
			e.FieldStart("enabled")
			s.Enabled.Encode(e)
		}
	}
	{
		if s.AlertType.Set {
			e.FieldStart("alert_type")
			s.AlertType.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		e.FieldStart("webhook")
		s.Webhook.Encode(e)
	}
	{
		if s.Triggers != nil {
			e.FieldStart("triggers")
			e.ArrStart()
			for _, elem := range s.Triggers {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.CreatedBy.Set {
			e.FieldStart("created_by")
			s.CreatedBy.Encode(e)
		}
	}
	{
		if s.LastUpdatedAt.Set {
			e.FieldStart("last_updated_at")
			s.LastUpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.LastUpdatedBy.Set {
			e.FieldStart("last_updated_by")
			s.LastUpdatedBy.Encode(e)
		}
	}
}

var jsonFieldsNameOfAlertPublic = [11]string{
	0:  "id",
	1:  "name",
	2:  "enabled",
	3:  "alert_type",
	4:  "metadata",
	5:  "webhook",
	6:  "triggers",
	7:  "created_at",
	8:  "created_by",
	9:  "last_updated_at",
	10: "last_updated_by",
}

// Decode decodes AlertPublic from json.
func (s *AlertPublic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AlertPublic to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "enabled":
			if err := func() error {
				s.Enabled.Reset()
				if err := s.Enabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		case "alert_type":
			if err := func() error {
				s.AlertType.Reset()
				if err := s.AlertType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alert_type\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "webhook":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Webhook.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"webhook\"")
			}
		case "triggers":
			if err := func() error {
				s.Triggers = make([]AlertTriggerPublic, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AlertTriggerPublic
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Triggers = append(s.Triggers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"triggers\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "created_by":
			if err := func() error {
				s.CreatedBy.Reset()
				if err := s.CreatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_by\"")
			}
		case "last_updated_at":
			if err := func() error {
				s.LastUpdatedAt.Reset()
				if err := s.LastUpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated_at\"")
			}
		case "last_updated_by":
			if err := func() error {
				s.LastUpdatedBy.Reset()
				if err := s.LastUpdatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated_by\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AlertPublic")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00100000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAlertPublic) {
					name = jsonFieldsNameOfAlertPublic[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AlertPublic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AlertPublic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AlertPublicAlertType as json.
func (s AlertPublicAlertType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AlertPublicAlertType from json.
func (s *AlertPublicAlertType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AlertPublicAlertType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AlertPublicAlertType(v) {
	case AlertPublicAlertTypeGeneral:
		*s = AlertPublicAlertTypeGeneral
	case AlertPublicAlertTypeSlack:
		*s = AlertPublicAlertTypeSlack
	case AlertPublicAlertTypePagerduty:
		*s = AlertPublicAlertTypePagerduty
	default:
		*s = AlertPublicAlertType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AlertPublicAlertType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AlertPublicAlertType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s AlertPublicMetadata) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s AlertPublicMetadata) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes AlertPublicMetadata from json.
func (s *AlertPublicMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AlertPublicMetadata to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AlertPublicMetadata")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AlertPublicMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AlertPublicMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AlertTriggerConfigPublic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AlertTriggerConfigPublic) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.AlertTriggerID.Set {
			e.FieldStart("alert_trigger_id")
			s.AlertTriggerID.Encode(e)
		}
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		if s.ConfigValue.Set {
			e.FieldStart("config_value")
			s.ConfigValue.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.CreatedBy.Set {
			e.FieldStart("created_by")
			s.CreatedBy.Encode(e)
		}
	}
	{
		if s.LastUpdatedAt.Set {
			e.FieldStart("last_updated_at")
			s.LastUpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.LastUpdatedBy.Set {
			e.FieldStart("last_updated_by")
			s.LastUpdatedBy.Encode(e)
		}
	}
}

var jsonFieldsNameOfAlertTriggerConfigPublic = [8]string{
	0: "id",
	1: "alert_trigger_id",
	2: "type",
	3: "config_value",
	4: "created_at",
	5: "created_by",
	6: "last_updated_at",
	7: "last_updated_by",
}

// Decode decodes AlertTriggerConfigPublic from json.
func (s *AlertTriggerConfigPublic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AlertTriggerConfigPublic to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "alert_trigger_id":
			if err := func() error {
				s.AlertTriggerID.Reset()
				if err := s.AlertTriggerID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alert_trigger_id\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "config_value":
			if err := func() error {
				s.ConfigValue.Reset()
				if err := s.ConfigValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"config_value\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "created_by":
			if err := func() error {
				s.CreatedBy.Reset()
				if err := s.CreatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_by\"")
			}
		case "last_updated_at":
			if err := func() error {
				s.LastUpdatedAt.Reset()
				if err := s.LastUpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated_at\"")
			}
		case "last_updated_by":
			if err := func() error {
				s.LastUpdatedBy.Reset()
				if err := s.LastUpdatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated_by\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AlertTriggerConfigPublic")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAlertTriggerConfigPublic) {
					name = jsonFieldsNameOfAlertTriggerConfigPublic[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AlertTriggerConfigPublic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AlertTriggerConfigPublic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s AlertTriggerConfigPublicConfigValue) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s AlertTriggerConfigPublicConfigValue) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes AlertTriggerConfigPublicConfigValue from json.
func (s *AlertTriggerConfigPublicConfigValue) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AlertTriggerConfigPublicConfigValue to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AlertTriggerConfigPublicConfigValue")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AlertTriggerConfigPublicConfigValue) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AlertTriggerConfigPublicConfigValue) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AlertTriggerConfigPublicType as json.
func (s AlertTriggerConfigPublicType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AlertTriggerConfigPublicType from json.
func (s *AlertTriggerConfigPublicType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AlertTriggerConfigPublicType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AlertTriggerConfigPublicType(v) {
	case AlertTriggerConfigPublicTypeScopeProject:
		*s = AlertTriggerConfigPublicTypeScopeProject
	case AlertTriggerConfigPublicTypeThresholdFeedbackScore:
		*s = AlertTriggerConfigPublicTypeThresholdFeedbackScore
	case AlertTriggerConfigPublicTypeThresholdCost:
		*s = AlertTriggerConfigPublicTypeThresholdCost
	case AlertTriggerConfigPublicTypeThresholdLatency:
		*s = AlertTriggerConfigPublicTypeThresholdLatency
	case AlertTriggerConfigPublicTypeThresholdErrors:
		*s = AlertTriggerConfigPublicTypeThresholdErrors
	default:
		*s = AlertTriggerConfigPublicType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AlertTriggerConfigPublicType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AlertTriggerConfigPublicType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AlertTriggerConfigWrite) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AlertTriggerConfigWrite) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		if s.ConfigValue.Set {
			e.FieldStart("config_value")
			s.ConfigValue.Encode(e)
		}
	}
}

var jsonFieldsNameOfAlertTriggerConfigWrite = [3]string{
	0: "id",
	1: "type",
	2: "config_value",
}

// Decode decodes AlertTriggerConfigWrite from json.
func (s *AlertTriggerConfigWrite) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AlertTriggerConfigWrite to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "config_value":
			if err := func() error {
				s.ConfigValue.Reset()
				if err := s.ConfigValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"config_value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AlertTriggerConfigWrite")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAlertTriggerConfigWrite) {
					name = jsonFieldsNameOfAlertTriggerConfigWrite[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AlertTriggerConfigWrite) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AlertTriggerConfigWrite) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s AlertTriggerConfigWriteConfigValue) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s AlertTriggerConfigWriteConfigValue) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes AlertTriggerConfigWriteConfigValue from json.
func (s *AlertTriggerConfigWriteConfigValue) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AlertTriggerConfigWriteConfigValue to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AlertTriggerConfigWriteConfigValue")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AlertTriggerConfigWriteConfigValue) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AlertTriggerConfigWriteConfigValue) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AlertTriggerConfigWriteType as json.
func (s AlertTriggerConfigWriteType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AlertTriggerConfigWriteType from json.
func (s *AlertTriggerConfigWriteType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AlertTriggerConfigWriteType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AlertTriggerConfigWriteType(v) {
	case AlertTriggerConfigWriteTypeScopeProject:
		*s = AlertTriggerConfigWriteTypeScopeProject
	case AlertTriggerConfigWriteTypeThresholdFeedbackScore:
		*s = AlertTriggerConfigWriteTypeThresholdFeedbackScore
	case AlertTriggerConfigWriteTypeThresholdCost:
		*s = AlertTriggerConfigWriteTypeThresholdCost
	case AlertTriggerConfigWriteTypeThresholdLatency:
		*s = AlertTriggerConfigWriteTypeThresholdLatency
	case AlertTriggerConfigWriteTypeThresholdErrors:
		*s = AlertTriggerConfigWriteTypeThresholdErrors
	default:
		*s = AlertTriggerConfigWriteType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AlertTriggerConfigWriteType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AlertTriggerConfigWriteType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AlertTriggerPublic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AlertTriggerPublic) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.AlertID.Set {
			e.FieldStart("alert_id")
			s.AlertID.Encode(e)
		}
	}
	{
		e.FieldStart("event_type")
		s.EventType.Encode(e)
	}
	{
		if s.TriggerConfigs != nil {
			e.FieldStart("trigger_configs")
			e.ArrStart()
			for _, elem := range s.TriggerConfigs {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.CreatedBy.Set {
			e.FieldStart("created_by")
			s.CreatedBy.Encode(e)
		}
	}
}

var jsonFieldsNameOfAlertTriggerPublic = [6]string{
	0: "id",
	1: "alert_id",
	2: "event_type",
	3: "trigger_configs",
	4: "created_at",
	5: "created_by",
}

// Decode decodes AlertTriggerPublic from json.
func (s *AlertTriggerPublic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AlertTriggerPublic to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "alert_id":
			if err := func() error {
				s.AlertID.Reset()
				if err := s.AlertID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alert_id\"")
			}
		case "event_type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.EventType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"event_type\"")
			}
		case "trigger_configs":
			if err := func() error {
				s.TriggerConfigs = make([]AlertTriggerConfigPublic, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AlertTriggerConfigPublic
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.TriggerConfigs = append(s.TriggerConfigs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trigger_configs\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "created_by":
			if err := func() error {
				s.CreatedBy.Reset()
				if err := s.CreatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_by\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AlertTriggerPublic")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAlertTriggerPublic) {
					name = jsonFieldsNameOfAlertTriggerPublic[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AlertTriggerPublic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AlertTriggerPublic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AlertTriggerPublicEventType as json.
func (s AlertTriggerPublicEventType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AlertTriggerPublicEventType from json.
func (s *AlertTriggerPublicEventType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AlertTriggerPublicEventType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AlertTriggerPublicEventType(v) {
	case AlertTriggerPublicEventTypeTraceErrors:
		*s = AlertTriggerPublicEventTypeTraceErrors
	case AlertTriggerPublicEventTypeTraceFeedbackScore:
		*s = AlertTriggerPublicEventTypeTraceFeedbackScore
	case AlertTriggerPublicEventTypeTraceThreadFeedbackScore:
		*s = AlertTriggerPublicEventTypeTraceThreadFeedbackScore
	case AlertTriggerPublicEventTypePromptCreated:
		*s = AlertTriggerPublicEventTypePromptCreated
	case AlertTriggerPublicEventTypePromptCommitted:
		*s = AlertTriggerPublicEventTypePromptCommitted
	case AlertTriggerPublicEventTypeTraceGuardrailsTriggered:
		*s = AlertTriggerPublicEventTypeTraceGuardrailsTriggered
	case AlertTriggerPublicEventTypePromptDeleted:
		*s = AlertTriggerPublicEventTypePromptDeleted
	case AlertTriggerPublicEventTypeExperimentFinished:
		*s = AlertTriggerPublicEventTypeExperimentFinished
	case AlertTriggerPublicEventTypeTraceCost:
		*s = AlertTriggerPublicEventTypeTraceCost
	case AlertTriggerPublicEventTypeTraceLatency:
		*s = AlertTriggerPublicEventTypeTraceLatency
	default:
		*s = AlertTriggerPublicEventType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AlertTriggerPublicEventType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AlertTriggerPublicEventType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AlertTriggerWrite) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AlertTriggerWrite) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		e.FieldStart("event_type")
		s.EventType.Encode(e)
	}
	{
		if s.TriggerConfigs != nil {
			e.FieldStart("trigger_configs")
			e.ArrStart()
			for _, elem := range s.TriggerConfigs {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfAlertTriggerWrite = [3]string{
	0: "id",
	1: "event_type",
	2: "trigger_configs",
}

// Decode decodes AlertTriggerWrite from json.
func (s *AlertTriggerWrite) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AlertTriggerWrite to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "event_type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.EventType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"event_type\"")
			}
		case "trigger_configs":
			if err := func() error {
				s.TriggerConfigs = make([]AlertTriggerConfigWrite, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AlertTriggerConfigWrite
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.TriggerConfigs = append(s.TriggerConfigs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trigger_configs\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AlertTriggerWrite")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAlertTriggerWrite) {
					name = jsonFieldsNameOfAlertTriggerWrite[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AlertTriggerWrite) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AlertTriggerWrite) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AlertTriggerWriteEventType as json.
func (s AlertTriggerWriteEventType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AlertTriggerWriteEventType from json.
func (s *AlertTriggerWriteEventType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AlertTriggerWriteEventType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AlertTriggerWriteEventType(v) {
	case AlertTriggerWriteEventTypeTraceErrors:
		*s = AlertTriggerWriteEventTypeTraceErrors
	case AlertTriggerWriteEventTypeTraceFeedbackScore:
		*s = AlertTriggerWriteEventTypeTraceFeedbackScore
	case AlertTriggerWriteEventTypeTraceThreadFeedbackScore:
		*s = AlertTriggerWriteEventTypeTraceThreadFeedbackScore
	case AlertTriggerWriteEventTypePromptCreated:
		*s = AlertTriggerWriteEventTypePromptCreated
	case AlertTriggerWriteEventTypePromptCommitted:
		*s = AlertTriggerWriteEventTypePromptCommitted
	case AlertTriggerWriteEventTypeTraceGuardrailsTriggered:
		*s = AlertTriggerWriteEventTypeTraceGuardrailsTriggered
	case AlertTriggerWriteEventTypePromptDeleted:
		*s = AlertTriggerWriteEventTypePromptDeleted
	case AlertTriggerWriteEventTypeExperimentFinished:
		*s = AlertTriggerWriteEventTypeExperimentFinished
	case AlertTriggerWriteEventTypeTraceCost:
		*s = AlertTriggerWriteEventTypeTraceCost
	case AlertTriggerWriteEventTypeTraceLatency:
		*s = AlertTriggerWriteEventTypeTraceLatency
	default:
		*s = AlertTriggerWriteEventType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AlertTriggerWriteEventType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AlertTriggerWriteEventType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AlertWrite) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AlertWrite) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Enabled.Set {
			e.FieldStart("enabled")
			s.Enabled.Encode(e)
		}
	}
	{
		if s.AlertType.Set {
			e.FieldStart("alert_type")
			s.AlertType.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		e.FieldStart("webhook")
		s.Webhook.Encode(e)
	}
	{
		if s.Triggers != nil {
			e.FieldStart("triggers")
			e.ArrStart()
			for _, elem := range s.Triggers {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfAlertWrite = [7]string{
	0: "id",
	1: "name",
	2: "enabled",
	3: "alert_type",
	4: "metadata",
	5: "webhook",
	6: "triggers",
}

// Decode decodes AlertWrite from json.
func (s *AlertWrite) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AlertWrite to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "enabled":
			if err := func() error {
				s.Enabled.Reset()
				if err := s.Enabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		case "alert_type":
			if err := func() error {
				s.AlertType.Reset()
				if err := s.AlertType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alert_type\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "webhook":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Webhook.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"webhook\"")
			}
		case "triggers":
			if err := func() error {
				s.Triggers = make([]AlertTriggerWrite, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AlertTriggerWrite
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Triggers = append(s.Triggers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"triggers\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AlertWrite")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00100000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAlertWrite) {
					name = jsonFieldsNameOfAlertWrite[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AlertWrite) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AlertWrite) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AlertWriteAlertType as json.
func (s AlertWriteAlertType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AlertWriteAlertType from json.
func (s *AlertWriteAlertType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AlertWriteAlertType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AlertWriteAlertType(v) {
	case AlertWriteAlertTypeGeneral:
		*s = AlertWriteAlertTypeGeneral
	case AlertWriteAlertTypeSlack:
		*s = AlertWriteAlertTypeSlack
	case AlertWriteAlertTypePagerduty:
		*s = AlertWriteAlertTypePagerduty
	default:
		*s = AlertWriteAlertType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AlertWriteAlertType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AlertWriteAlertType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s AlertWriteMetadata) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s AlertWriteMetadata) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes AlertWriteMetadata from json.
func (s *AlertWriteMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AlertWriteMetadata to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AlertWriteMetadata")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AlertWriteMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AlertWriteMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AnnotationQueueBatchWrite) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AnnotationQueueBatchWrite) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("annotation_queues")
		e.ArrStart()
		for _, elem := range s.AnnotationQueues {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfAnnotationQueueBatchWrite = [1]string{
	0: "annotation_queues",
}

// Decode decodes AnnotationQueueBatchWrite from json.
func (s *AnnotationQueueBatchWrite) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AnnotationQueueBatchWrite to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "annotation_queues":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.AnnotationQueues = make([]AnnotationQueueWrite, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AnnotationQueueWrite
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.AnnotationQueues = append(s.AnnotationQueues, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"annotation_queues\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AnnotationQueueBatchWrite")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAnnotationQueueBatchWrite) {
					name = jsonFieldsNameOfAnnotationQueueBatchWrite[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AnnotationQueueBatchWrite) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AnnotationQueueBatchWrite) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AnnotationQueueItemIds) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AnnotationQueueItemIds) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("ids")
		e.ArrStart()
		for _, elem := range s.Ids {
			json.EncodeUUID(e, elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfAnnotationQueueItemIds = [1]string{
	0: "ids",
}

// Decode decodes AnnotationQueueItemIds from json.
func (s *AnnotationQueueItemIds) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AnnotationQueueItemIds to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ids":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Ids = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.Ids = append(s.Ids, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ids\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AnnotationQueueItemIds")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAnnotationQueueItemIds) {
					name = jsonFieldsNameOfAnnotationQueueItemIds[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AnnotationQueueItemIds) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AnnotationQueueItemIds) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AnnotationQueuePagePublic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AnnotationQueuePagePublic) encodeFields(e *jx.Encoder) {
	{
		if s.Page.Set {
			e.FieldStart("page")
			s.Page.Encode(e)
		}
	}
	{
		if s.Size.Set {
			e.FieldStart("size")
			s.Size.Encode(e)
		}
	}
	{
		if s.Total.Set {
			e.FieldStart("total")
			s.Total.Encode(e)
		}
	}
	{
		if s.Content != nil {
			e.FieldStart("content")
			e.ArrStart()
			for _, elem := range s.Content {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.SortableBy != nil {
			e.FieldStart("sortableBy")
			e.ArrStart()
			for _, elem := range s.SortableBy {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfAnnotationQueuePagePublic = [5]string{
	0: "page",
	1: "size",
	2: "total",
	3: "content",
	4: "sortableBy",
}

// Decode decodes AnnotationQueuePagePublic from json.
func (s *AnnotationQueuePagePublic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AnnotationQueuePagePublic to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "page":
			if err := func() error {
				s.Page.Reset()
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "size":
			if err := func() error {
				s.Size.Reset()
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "total":
			if err := func() error {
				s.Total.Reset()
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "content":
			if err := func() error {
				s.Content = make([]AnnotationQueuePublic, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AnnotationQueuePublic
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Content = append(s.Content, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		case "sortableBy":
			if err := func() error {
				s.SortableBy = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.SortableBy = append(s.SortableBy, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sortableBy\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AnnotationQueuePagePublic")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AnnotationQueuePagePublic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AnnotationQueuePagePublic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AnnotationQueuePublic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AnnotationQueuePublic) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		e.FieldStart("project_id")
		json.EncodeUUID(e, s.ProjectID)
	}
	{
		if s.ProjectName.Set {
			e.FieldStart("project_name")
			s.ProjectName.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Instructions.Set {
			e.FieldStart("instructions")
			s.Instructions.Encode(e)
		}
	}
	{
		e.FieldStart("scope")
		s.Scope.Encode(e)
	}
	{
		if s.CommentsEnabled.Set {
			e.FieldStart("comments_enabled")
			s.CommentsEnabled.Encode(e)
		}
	}
	{
		if s.FeedbackDefinitionNames != nil {
			e.FieldStart("feedback_definition_names")
			e.ArrStart()
			for _, elem := range s.FeedbackDefinitionNames {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Reviewers != nil {
			e.FieldStart("reviewers")
			e.ArrStart()
			for _, elem := range s.Reviewers {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.FeedbackScores != nil {
			e.FieldStart("feedback_scores")
			e.ArrStart()
			for _, elem := range s.FeedbackScores {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ItemsCount.Set {
			e.FieldStart("items_count")
			s.ItemsCount.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.CreatedBy.Set {
			e.FieldStart("created_by")
			s.CreatedBy.Encode(e)
		}
	}
	{
		if s.LastUpdatedAt.Set {
			e.FieldStart("last_updated_at")
			s.LastUpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.LastUpdatedBy.Set {
			e.FieldStart("last_updated_by")
			s.LastUpdatedBy.Encode(e)
		}
	}
}

var jsonFieldsNameOfAnnotationQueuePublic = [16]string{
	0:  "id",
	1:  "project_id",
	2:  "project_name",
	3:  "name",
	4:  "description",
	5:  "instructions",
	6:  "scope",
	7:  "comments_enabled",
	8:  "feedback_definition_names",
	9:  "reviewers",
	10: "feedback_scores",
	11: "items_count",
	12: "created_at",
	13: "created_by",
	14: "last_updated_at",
	15: "last_updated_by",
}

// Decode decodes AnnotationQueuePublic from json.
func (s *AnnotationQueuePublic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AnnotationQueuePublic to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "project_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ProjectID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"project_id\"")
			}
		case "project_name":
			if err := func() error {
				s.ProjectName.Reset()
				if err := s.ProjectName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"project_name\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "instructions":
			if err := func() error {
				s.Instructions.Reset()
				if err := s.Instructions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instructions\"")
			}
		case "scope":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Scope.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scope\"")
			}
		case "comments_enabled":
			if err := func() error {
				s.CommentsEnabled.Reset()
				if err := s.CommentsEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comments_enabled\"")
			}
		case "feedback_definition_names":
			if err := func() error {
				s.FeedbackDefinitionNames = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.FeedbackDefinitionNames = append(s.FeedbackDefinitionNames, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"feedback_definition_names\"")
			}
		case "reviewers":
			if err := func() error {
				s.Reviewers = make([]AnnotationQueueReviewerPublic, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AnnotationQueueReviewerPublic
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Reviewers = append(s.Reviewers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reviewers\"")
			}
		case "feedback_scores":
			if err := func() error {
				s.FeedbackScores = make([]FeedbackScoreAveragePublic, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem FeedbackScoreAveragePublic
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.FeedbackScores = append(s.FeedbackScores, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"feedback_scores\"")
			}
		case "items_count":
			if err := func() error {
				s.ItemsCount.Reset()
				if err := s.ItemsCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items_count\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "created_by":
			if err := func() error {
				s.CreatedBy.Reset()
				if err := s.CreatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_by\"")
			}
		case "last_updated_at":
			if err := func() error {
				s.LastUpdatedAt.Reset()
				if err := s.LastUpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated_at\"")
			}
		case "last_updated_by":
			if err := func() error {
				s.LastUpdatedBy.Reset()
				if err := s.LastUpdatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated_by\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AnnotationQueuePublic")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01001010,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAnnotationQueuePublic) {
					name = jsonFieldsNameOfAnnotationQueuePublic[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AnnotationQueuePublic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AnnotationQueuePublic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AnnotationQueuePublicScope as json.
func (s AnnotationQueuePublicScope) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AnnotationQueuePublicScope from json.
func (s *AnnotationQueuePublicScope) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AnnotationQueuePublicScope to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AnnotationQueuePublicScope(v) {
	case AnnotationQueuePublicScopeTrace:
		*s = AnnotationQueuePublicScopeTrace
	case AnnotationQueuePublicScopeThread:
		*s = AnnotationQueuePublicScopeThread
	default:
		*s = AnnotationQueuePublicScope(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AnnotationQueuePublicScope) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AnnotationQueuePublicScope) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AnnotationQueueReviewerPublic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AnnotationQueueReviewerPublic) encodeFields(e *jx.Encoder) {
	{
		if s.Username.Set {
			e.FieldStart("username")
			s.Username.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
}

var jsonFieldsNameOfAnnotationQueueReviewerPublic = [2]string{
	0: "username",
	1: "status",
}

// Decode decodes AnnotationQueueReviewerPublic from json.
func (s *AnnotationQueueReviewerPublic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AnnotationQueueReviewerPublic to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "username":
			if err := func() error {
				s.Username.Reset()
				if err := s.Username.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AnnotationQueueReviewerPublic")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AnnotationQueueReviewerPublic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AnnotationQueueReviewerPublic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AnnotationQueueUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AnnotationQueueUpdate) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Instructions.Set {
			e.FieldStart("instructions")
			s.Instructions.Encode(e)
		}
	}
	{
		if s.CommentsEnabled.Set {
			e.FieldStart("comments_enabled")
			s.CommentsEnabled.Encode(e)
		}
	}
	{
		if s.FeedbackDefinitionNames != nil {
			e.FieldStart("feedback_definition_names")
			e.ArrStart()
			for _, elem := range s.FeedbackDefinitionNames {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfAnnotationQueueUpdate = [5]string{
	0: "name",
	1: "description",
	2: "instructions",
	3: "comments_enabled",
	4: "feedback_definition_names",
}

// Decode decodes AnnotationQueueUpdate from json.
func (s *AnnotationQueueUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AnnotationQueueUpdate to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "instructions":
			if err := func() error {
				s.Instructions.Reset()
				if err := s.Instructions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instructions\"")
			}
		case "comments_enabled":
			if err := func() error {
				s.CommentsEnabled.Reset()
				if err := s.CommentsEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comments_enabled\"")
			}
		case "feedback_definition_names":
			if err := func() error {
				s.FeedbackDefinitionNames = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.FeedbackDefinitionNames = append(s.FeedbackDefinitionNames, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"feedback_definition_names\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AnnotationQueueUpdate")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AnnotationQueueUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AnnotationQueueUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AnnotationQueueWrite) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AnnotationQueueWrite) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		e.FieldStart("project_id")
		json.EncodeUUID(e, s.ProjectID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Instructions.Set {
			e.FieldStart("instructions")
			s.Instructions.Encode(e)
		}
	}
	{
		e.FieldStart("scope")
		s.Scope.Encode(e)
	}
	{
		if s.CommentsEnabled.Set {
			e.FieldStart("comments_enabled")
			s.CommentsEnabled.Encode(e)
		}
	}
	{
		if s.FeedbackDefinitionNames != nil {
			e.FieldStart("feedback_definition_names")
			e.ArrStart()
			for _, elem := range s.FeedbackDefinitionNames {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfAnnotationQueueWrite = [8]string{
	0: "id",
	1: "project_id",
	2: "name",
	3: "description",
	4: "instructions",
	5: "scope",
	6: "comments_enabled",
	7: "feedback_definition_names",
}

// Decode decodes AnnotationQueueWrite from json.
func (s *AnnotationQueueWrite) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AnnotationQueueWrite to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "project_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ProjectID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"project_id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "instructions":
			if err := func() error {
				s.Instructions.Reset()
				if err := s.Instructions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instructions\"")
			}
		case "scope":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Scope.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scope\"")
			}
		case "comments_enabled":
			if err := func() error {
				s.CommentsEnabled.Reset()
				if err := s.CommentsEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comments_enabled\"")
			}
		case "feedback_definition_names":
			if err := func() error {
				s.FeedbackDefinitionNames = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.FeedbackDefinitionNames = append(s.FeedbackDefinitionNames, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"feedback_definition_names\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AnnotationQueueWrite")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00100110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAnnotationQueueWrite) {
					name = jsonFieldsNameOfAnnotationQueueWrite[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AnnotationQueueWrite) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AnnotationQueueWrite) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AnnotationQueueWriteScope as json.
func (s AnnotationQueueWriteScope) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AnnotationQueueWriteScope from json.
func (s *AnnotationQueueWriteScope) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AnnotationQueueWriteScope to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AnnotationQueueWriteScope(v) {
	case AnnotationQueueWriteScopeTrace:
		*s = AnnotationQueueWriteScopeTrace
	case AnnotationQueueWriteScopeThread:
		*s = AnnotationQueueWriteScopeThread
	default:
		*s = AnnotationQueueWriteScope(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AnnotationQueueWriteScope) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AnnotationQueueWriteScope) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AssistantMessage) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AssistantMessage) encodeFields(e *jx.Encoder) {
	{
		if s.Role.Set {
			e.FieldStart("role")
			s.Role.Encode(e)
		}
	}
	{
		if s.Content.Set {
			e.FieldStart("content")
			s.Content.Encode(e)
		}
	}
	{
		if s.ReasoningContent.Set {
			e.FieldStart("reasoning_content")
			s.ReasoningContent.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.ToolCalls != nil {
			e.FieldStart("tool_calls")
			e.ArrStart()
			for _, elem := range s.ToolCalls {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Refusal.Set {
			e.FieldStart("refusal")
			s.Refusal.Encode(e)
		}
	}
	{
		if s.FunctionCall.Set {
			e.FieldStart("function_call")
			s.FunctionCall.Encode(e)
		}
	}
}

var jsonFieldsNameOfAssistantMessage = [7]string{
	0: "role",
	1: "content",
	2: "reasoning_content",
	3: "name",
	4: "tool_calls",
	5: "refusal",
	6: "function_call",
}

// Decode decodes AssistantMessage from json.
func (s *AssistantMessage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AssistantMessage to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "role":
			if err := func() error {
				s.Role.Reset()
				if err := s.Role.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"role\"")
			}
		case "content":
			if err := func() error {
				s.Content.Reset()
				if err := s.Content.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		case "reasoning_content":
			if err := func() error {
				s.ReasoningContent.Reset()
				if err := s.ReasoningContent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reasoning_content\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "tool_calls":
			if err := func() error {
				s.ToolCalls = make([]ToolCall, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ToolCall
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ToolCalls = append(s.ToolCalls, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tool_calls\"")
			}
		case "refusal":
			if err := func() error {
				s.Refusal.Reset()
				if err := s.Refusal.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"refusal\"")
			}
		case "function_call":
			if err := func() error {
				s.FunctionCall.Reset()
				if err := s.FunctionCall.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"function_call\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AssistantMessage")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AssistantMessage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AssistantMessage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AssistantMessageRole as json.
func (s AssistantMessageRole) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AssistantMessageRole from json.
func (s *AssistantMessageRole) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AssistantMessageRole to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AssistantMessageRole(v) {
	case AssistantMessageRoleSystem:
		*s = AssistantMessageRoleSystem
	case AssistantMessageRoleUser:
		*s = AssistantMessageRoleUser
	case AssistantMessageRoleAssistant:
		*s = AssistantMessageRoleAssistant
	case AssistantMessageRoleTool:
		*s = AssistantMessageRoleTool
	case AssistantMessageRoleFunction:
		*s = AssistantMessageRoleFunction
	default:
		*s = AssistantMessageRole(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AssistantMessageRole) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AssistantMessageRole) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Attachment) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Attachment) encodeFields(e *jx.Encoder) {
	{
		if s.Link.Set {
			e.FieldStart("link")
			s.Link.Encode(e)
		}
	}
	{
		e.FieldStart("file_name")
		e.Str(s.FileName)
	}
	{
		e.FieldStart("file_size")
		e.Int64(s.FileSize)
	}
	{
		e.FieldStart("mime_type")
		e.Str(s.MimeType)
	}
}

var jsonFieldsNameOfAttachment = [4]string{
	0: "link",
	1: "file_name",
	2: "file_size",
	3: "mime_type",
}

// Decode decodes Attachment from json.
func (s *Attachment) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Attachment to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "link":
			if err := func() error {
				s.Link.Reset()
				if err := s.Link.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"link\"")
			}
		case "file_name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.FileName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_name\"")
			}
		case "file_size":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int64()
				s.FileSize = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_size\"")
			}
		case "mime_type":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.MimeType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mime_type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Attachment")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAttachment) {
					name = jsonFieldsNameOfAttachment[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Attachment) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Attachment) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AttachmentListForbidden as json.
func (s *AttachmentListForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessage)(s)

	unwrapped.Encode(e)
}

// Decode decodes AttachmentListForbidden from json.
func (s *AttachmentListForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AttachmentListForbidden to nil")
	}
	var unwrapped ErrorMessage
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AttachmentListForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AttachmentListForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AttachmentListForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AttachmentListUnauthorized as json.
func (s *AttachmentListUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessage)(s)

	unwrapped.Encode(e)
}

// Decode decodes AttachmentListUnauthorized from json.
func (s *AttachmentListUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AttachmentListUnauthorized to nil")
	}
	var unwrapped ErrorMessage
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AttachmentListUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AttachmentListUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AttachmentListUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AttachmentPage) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AttachmentPage) encodeFields(e *jx.Encoder) {
	{
		if s.Page.Set {
			e.FieldStart("page")
			s.Page.Encode(e)
		}
	}
	{
		if s.Size.Set {
			e.FieldStart("size")
			s.Size.Encode(e)
		}
	}
	{
		if s.Total.Set {
			e.FieldStart("total")
			s.Total.Encode(e)
		}
	}
	{
		if s.Content != nil {
			e.FieldStart("content")
			e.ArrStart()
			for _, elem := range s.Content {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.SortableBy != nil {
			e.FieldStart("sortableBy")
			e.ArrStart()
			for _, elem := range s.SortableBy {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfAttachmentPage = [5]string{
	0: "page",
	1: "size",
	2: "total",
	3: "content",
	4: "sortableBy",
}

// Decode decodes AttachmentPage from json.
func (s *AttachmentPage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AttachmentPage to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "page":
			if err := func() error {
				s.Page.Reset()
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "size":
			if err := func() error {
				s.Size.Reset()
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "total":
			if err := func() error {
				s.Total.Reset()
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "content":
			if err := func() error {
				s.Content = make([]Attachment, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Attachment
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Content = append(s.Content, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		case "sortableBy":
			if err := func() error {
				s.SortableBy = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.SortableBy = append(s.SortableBy, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sortableBy\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AttachmentPage")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AttachmentPage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AttachmentPage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AuthDetailsHolder) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AuthDetailsHolder) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfAuthDetailsHolder = [0]string{}

// Decode decodes AuthDetailsHolder from json.
func (s *AuthDetailsHolder) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthDetailsHolder to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode AuthDetailsHolder")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AuthDetailsHolder) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuthDetailsHolder) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AutomationRuleEvaluatorObjectObjectPublic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AutomationRuleEvaluatorObjectObjectPublic) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		e.FieldStart("project_id")
		json.EncodeUUID(e, s.ProjectID)
	}
	{
		if s.ProjectName.Set {
			e.FieldStart("project_name")
			s.ProjectName.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.SamplingRate.Set {
			e.FieldStart("sampling_rate")
			s.SamplingRate.Encode(e)
		}
	}
	{
		if s.Enabled.Set {
			e.FieldStart("enabled")
			s.Enabled.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.CreatedBy.Set {
			e.FieldStart("created_by")
			s.CreatedBy.Encode(e)
		}
	}
	{
		if s.LastUpdatedAt.Set {
			e.FieldStart("last_updated_at")
			s.LastUpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.LastUpdatedBy.Set {
			e.FieldStart("last_updated_by")
			s.LastUpdatedBy.Encode(e)
		}
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("action")
		s.Action.Encode(e)
	}
}

var jsonFieldsNameOfAutomationRuleEvaluatorObjectObjectPublic = [12]string{
	0:  "id",
	1:  "project_id",
	2:  "project_name",
	3:  "name",
	4:  "sampling_rate",
	5:  "enabled",
	6:  "created_at",
	7:  "created_by",
	8:  "last_updated_at",
	9:  "last_updated_by",
	10: "type",
	11: "action",
}

// Decode decodes AutomationRuleEvaluatorObjectObjectPublic from json.
func (s *AutomationRuleEvaluatorObjectObjectPublic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutomationRuleEvaluatorObjectObjectPublic to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "project_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ProjectID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"project_id\"")
			}
		case "project_name":
			if err := func() error {
				s.ProjectName.Reset()
				if err := s.ProjectName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"project_name\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "sampling_rate":
			if err := func() error {
				s.SamplingRate.Reset()
				if err := s.SamplingRate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sampling_rate\"")
			}
		case "enabled":
			if err := func() error {
				s.Enabled.Reset()
				if err := s.Enabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "created_by":
			if err := func() error {
				s.CreatedBy.Reset()
				if err := s.CreatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_by\"")
			}
		case "last_updated_at":
			if err := func() error {
				s.LastUpdatedAt.Reset()
				if err := s.LastUpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated_at\"")
			}
		case "last_updated_by":
			if err := func() error {
				s.LastUpdatedBy.Reset()
				if err := s.LastUpdatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated_by\"")
			}
		case "type":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "action":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.Action.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"action\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AutomationRuleEvaluatorObjectObjectPublic")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00001010,
		0b00001100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAutomationRuleEvaluatorObjectObjectPublic) {
					name = jsonFieldsNameOfAutomationRuleEvaluatorObjectObjectPublic[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AutomationRuleEvaluatorObjectObjectPublic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AutomationRuleEvaluatorObjectObjectPublic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AutomationRuleEvaluatorObjectObjectPublicAction as json.
func (s AutomationRuleEvaluatorObjectObjectPublicAction) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AutomationRuleEvaluatorObjectObjectPublicAction from json.
func (s *AutomationRuleEvaluatorObjectObjectPublicAction) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutomationRuleEvaluatorObjectObjectPublicAction to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AutomationRuleEvaluatorObjectObjectPublicAction(v) {
	case AutomationRuleEvaluatorObjectObjectPublicActionEvaluator:
		*s = AutomationRuleEvaluatorObjectObjectPublicActionEvaluator
	default:
		*s = AutomationRuleEvaluatorObjectObjectPublicAction(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AutomationRuleEvaluatorObjectObjectPublicAction) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AutomationRuleEvaluatorObjectObjectPublicAction) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AutomationRuleEvaluatorObjectObjectPublicType as json.
func (s AutomationRuleEvaluatorObjectObjectPublicType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AutomationRuleEvaluatorObjectObjectPublicType from json.
func (s *AutomationRuleEvaluatorObjectObjectPublicType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutomationRuleEvaluatorObjectObjectPublicType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AutomationRuleEvaluatorObjectObjectPublicType(v) {
	case AutomationRuleEvaluatorObjectObjectPublicTypeLlmAsJudge:
		*s = AutomationRuleEvaluatorObjectObjectPublicTypeLlmAsJudge
	case AutomationRuleEvaluatorObjectObjectPublicTypeUserDefinedMetricPython:
		*s = AutomationRuleEvaluatorObjectObjectPublicTypeUserDefinedMetricPython
	case AutomationRuleEvaluatorObjectObjectPublicTypeTraceThreadLlmAsJudge:
		*s = AutomationRuleEvaluatorObjectObjectPublicTypeTraceThreadLlmAsJudge
	case AutomationRuleEvaluatorObjectObjectPublicTypeTraceThreadUserDefinedMetricPython:
		*s = AutomationRuleEvaluatorObjectObjectPublicTypeTraceThreadUserDefinedMetricPython
	case AutomationRuleEvaluatorObjectObjectPublicTypeSpanLlmAsJudge:
		*s = AutomationRuleEvaluatorObjectObjectPublicTypeSpanLlmAsJudge
	case AutomationRuleEvaluatorObjectObjectPublicTypeSpanUserDefinedMetricPython:
		*s = AutomationRuleEvaluatorObjectObjectPublicTypeSpanUserDefinedMetricPython
	default:
		*s = AutomationRuleEvaluatorObjectObjectPublicType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AutomationRuleEvaluatorObjectObjectPublicType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AutomationRuleEvaluatorObjectObjectPublicType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AutomationRuleEvaluatorPagePublic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AutomationRuleEvaluatorPagePublic) encodeFields(e *jx.Encoder) {
	{
		if s.Page.Set {
			e.FieldStart("page")
			s.Page.Encode(e)
		}
	}
	{
		if s.Size.Set {
			e.FieldStart("size")
			s.Size.Encode(e)
		}
	}
	{
		if s.Total.Set {
			e.FieldStart("total")
			s.Total.Encode(e)
		}
	}
	{
		if s.Content != nil {
			e.FieldStart("content")
			e.ArrStart()
			for _, elem := range s.Content {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.SortableBy != nil {
			e.FieldStart("sortable_by")
			e.ArrStart()
			for _, elem := range s.SortableBy {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfAutomationRuleEvaluatorPagePublic = [5]string{
	0: "page",
	1: "size",
	2: "total",
	3: "content",
	4: "sortable_by",
}

// Decode decodes AutomationRuleEvaluatorPagePublic from json.
func (s *AutomationRuleEvaluatorPagePublic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutomationRuleEvaluatorPagePublic to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "page":
			if err := func() error {
				s.Page.Reset()
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "size":
			if err := func() error {
				s.Size.Reset()
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "total":
			if err := func() error {
				s.Total.Reset()
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "content":
			if err := func() error {
				s.Content = make([]AutomationRuleEvaluatorObjectObjectPublic, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AutomationRuleEvaluatorObjectObjectPublic
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Content = append(s.Content, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		case "sortable_by":
			if err := func() error {
				s.SortableBy = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.SortableBy = append(s.SortableBy, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sortable_by\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AutomationRuleEvaluatorPagePublic")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AutomationRuleEvaluatorPagePublic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AutomationRuleEvaluatorPagePublic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AutomationRuleEvaluatorPublic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AutomationRuleEvaluatorPublic) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		e.FieldStart("project_id")
		json.EncodeUUID(e, s.ProjectID)
	}
	{
		if s.ProjectName.Set {
			e.FieldStart("project_name")
			s.ProjectName.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.SamplingRate.Set {
			e.FieldStart("sampling_rate")
			s.SamplingRate.Encode(e)
		}
	}
	{
		if s.Enabled.Set {
			e.FieldStart("enabled")
			s.Enabled.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.CreatedBy.Set {
			e.FieldStart("created_by")
			s.CreatedBy.Encode(e)
		}
	}
	{
		if s.LastUpdatedAt.Set {
			e.FieldStart("last_updated_at")
			s.LastUpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.LastUpdatedBy.Set {
			e.FieldStart("last_updated_by")
			s.LastUpdatedBy.Encode(e)
		}
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("action")
		s.Action.Encode(e)
	}
}

var jsonFieldsNameOfAutomationRuleEvaluatorPublic = [12]string{
	0:  "id",
	1:  "project_id",
	2:  "project_name",
	3:  "name",
	4:  "sampling_rate",
	5:  "enabled",
	6:  "created_at",
	7:  "created_by",
	8:  "last_updated_at",
	9:  "last_updated_by",
	10: "type",
	11: "action",
}

// Decode decodes AutomationRuleEvaluatorPublic from json.
func (s *AutomationRuleEvaluatorPublic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutomationRuleEvaluatorPublic to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "project_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ProjectID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"project_id\"")
			}
		case "project_name":
			if err := func() error {
				s.ProjectName.Reset()
				if err := s.ProjectName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"project_name\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "sampling_rate":
			if err := func() error {
				s.SamplingRate.Reset()
				if err := s.SamplingRate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sampling_rate\"")
			}
		case "enabled":
			if err := func() error {
				s.Enabled.Reset()
				if err := s.Enabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "created_by":
			if err := func() error {
				s.CreatedBy.Reset()
				if err := s.CreatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_by\"")
			}
		case "last_updated_at":
			if err := func() error {
				s.LastUpdatedAt.Reset()
				if err := s.LastUpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated_at\"")
			}
		case "last_updated_by":
			if err := func() error {
				s.LastUpdatedBy.Reset()
				if err := s.LastUpdatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated_by\"")
			}
		case "type":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "action":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.Action.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"action\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AutomationRuleEvaluatorPublic")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00001010,
		0b00001100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAutomationRuleEvaluatorPublic) {
					name = jsonFieldsNameOfAutomationRuleEvaluatorPublic[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AutomationRuleEvaluatorPublic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AutomationRuleEvaluatorPublic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AutomationRuleEvaluatorPublicAction as json.
func (s AutomationRuleEvaluatorPublicAction) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AutomationRuleEvaluatorPublicAction from json.
func (s *AutomationRuleEvaluatorPublicAction) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutomationRuleEvaluatorPublicAction to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AutomationRuleEvaluatorPublicAction(v) {
	case AutomationRuleEvaluatorPublicActionEvaluator:
		*s = AutomationRuleEvaluatorPublicActionEvaluator
	default:
		*s = AutomationRuleEvaluatorPublicAction(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AutomationRuleEvaluatorPublicAction) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AutomationRuleEvaluatorPublicAction) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AutomationRuleEvaluatorPublicType as json.
func (s AutomationRuleEvaluatorPublicType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AutomationRuleEvaluatorPublicType from json.
func (s *AutomationRuleEvaluatorPublicType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutomationRuleEvaluatorPublicType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AutomationRuleEvaluatorPublicType(v) {
	case AutomationRuleEvaluatorPublicTypeLlmAsJudge:
		*s = AutomationRuleEvaluatorPublicTypeLlmAsJudge
	case AutomationRuleEvaluatorPublicTypeUserDefinedMetricPython:
		*s = AutomationRuleEvaluatorPublicTypeUserDefinedMetricPython
	case AutomationRuleEvaluatorPublicTypeTraceThreadLlmAsJudge:
		*s = AutomationRuleEvaluatorPublicTypeTraceThreadLlmAsJudge
	case AutomationRuleEvaluatorPublicTypeTraceThreadUserDefinedMetricPython:
		*s = AutomationRuleEvaluatorPublicTypeTraceThreadUserDefinedMetricPython
	case AutomationRuleEvaluatorPublicTypeSpanLlmAsJudge:
		*s = AutomationRuleEvaluatorPublicTypeSpanLlmAsJudge
	case AutomationRuleEvaluatorPublicTypeSpanUserDefinedMetricPython:
		*s = AutomationRuleEvaluatorPublicTypeSpanUserDefinedMetricPython
	default:
		*s = AutomationRuleEvaluatorPublicType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AutomationRuleEvaluatorPublicType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AutomationRuleEvaluatorPublicType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AutomationRuleEvaluatorUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AutomationRuleEvaluatorUpdate) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.SamplingRate.Set {
			e.FieldStart("sampling_rate")
			s.SamplingRate.Encode(e)
		}
	}
	{
		if s.Enabled.Set {
			e.FieldStart("enabled")
			s.Enabled.Encode(e)
		}
	}
	{
		e.FieldStart("project_id")
		json.EncodeUUID(e, s.ProjectID)
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		e.FieldStart("action")
		s.Action.Encode(e)
	}
}

var jsonFieldsNameOfAutomationRuleEvaluatorUpdate = [6]string{
	0: "name",
	1: "sampling_rate",
	2: "enabled",
	3: "project_id",
	4: "type",
	5: "action",
}

// Decode decodes AutomationRuleEvaluatorUpdate from json.
func (s *AutomationRuleEvaluatorUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutomationRuleEvaluatorUpdate to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "sampling_rate":
			if err := func() error {
				s.SamplingRate.Reset()
				if err := s.SamplingRate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sampling_rate\"")
			}
		case "enabled":
			if err := func() error {
				s.Enabled.Reset()
				if err := s.Enabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		case "project_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ProjectID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"project_id\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "action":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Action.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"action\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AutomationRuleEvaluatorUpdate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00101001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAutomationRuleEvaluatorUpdate) {
					name = jsonFieldsNameOfAutomationRuleEvaluatorUpdate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AutomationRuleEvaluatorUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AutomationRuleEvaluatorUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AutomationRuleEvaluatorUpdateAction as json.
func (s AutomationRuleEvaluatorUpdateAction) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AutomationRuleEvaluatorUpdateAction from json.
func (s *AutomationRuleEvaluatorUpdateAction) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutomationRuleEvaluatorUpdateAction to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AutomationRuleEvaluatorUpdateAction(v) {
	case AutomationRuleEvaluatorUpdateActionEvaluator:
		*s = AutomationRuleEvaluatorUpdateActionEvaluator
	default:
		*s = AutomationRuleEvaluatorUpdateAction(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AutomationRuleEvaluatorUpdateAction) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AutomationRuleEvaluatorUpdateAction) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AutomationRuleEvaluatorUpdateType as json.
func (s AutomationRuleEvaluatorUpdateType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AutomationRuleEvaluatorUpdateType from json.
func (s *AutomationRuleEvaluatorUpdateType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutomationRuleEvaluatorUpdateType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AutomationRuleEvaluatorUpdateType(v) {
	case AutomationRuleEvaluatorUpdateTypeLlmAsJudge:
		*s = AutomationRuleEvaluatorUpdateTypeLlmAsJudge
	case AutomationRuleEvaluatorUpdateTypeUserDefinedMetricPython:
		*s = AutomationRuleEvaluatorUpdateTypeUserDefinedMetricPython
	case AutomationRuleEvaluatorUpdateTypeTraceThreadLlmAsJudge:
		*s = AutomationRuleEvaluatorUpdateTypeTraceThreadLlmAsJudge
	case AutomationRuleEvaluatorUpdateTypeTraceThreadUserDefinedMetricPython:
		*s = AutomationRuleEvaluatorUpdateTypeTraceThreadUserDefinedMetricPython
	case AutomationRuleEvaluatorUpdateTypeSpanLlmAsJudge:
		*s = AutomationRuleEvaluatorUpdateTypeSpanLlmAsJudge
	case AutomationRuleEvaluatorUpdateTypeSpanUserDefinedMetricPython:
		*s = AutomationRuleEvaluatorUpdateTypeSpanUserDefinedMetricPython
	default:
		*s = AutomationRuleEvaluatorUpdateType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AutomationRuleEvaluatorUpdateType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AutomationRuleEvaluatorUpdateType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AutomationRuleEvaluatorWrite) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AutomationRuleEvaluatorWrite) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("project_id")
		json.EncodeUUID(e, s.ProjectID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.SamplingRate.Set {
			e.FieldStart("sampling_rate")
			s.SamplingRate.Encode(e)
		}
	}
	{
		if s.Enabled.Set {
			e.FieldStart("enabled")
			s.Enabled.Encode(e)
		}
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("action")
		s.Action.Encode(e)
	}
}

var jsonFieldsNameOfAutomationRuleEvaluatorWrite = [6]string{
	0: "project_id",
	1: "name",
	2: "sampling_rate",
	3: "enabled",
	4: "type",
	5: "action",
}

// Decode decodes AutomationRuleEvaluatorWrite from json.
func (s *AutomationRuleEvaluatorWrite) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutomationRuleEvaluatorWrite to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "project_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ProjectID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"project_id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "sampling_rate":
			if err := func() error {
				s.SamplingRate.Reset()
				if err := s.SamplingRate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sampling_rate\"")
			}
		case "enabled":
			if err := func() error {
				s.Enabled.Reset()
				if err := s.Enabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "action":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Action.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"action\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AutomationRuleEvaluatorWrite")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00110011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAutomationRuleEvaluatorWrite) {
					name = jsonFieldsNameOfAutomationRuleEvaluatorWrite[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AutomationRuleEvaluatorWrite) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AutomationRuleEvaluatorWrite) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AutomationRuleEvaluatorWriteAction as json.
func (s AutomationRuleEvaluatorWriteAction) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AutomationRuleEvaluatorWriteAction from json.
func (s *AutomationRuleEvaluatorWriteAction) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutomationRuleEvaluatorWriteAction to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AutomationRuleEvaluatorWriteAction(v) {
	case AutomationRuleEvaluatorWriteActionEvaluator:
		*s = AutomationRuleEvaluatorWriteActionEvaluator
	default:
		*s = AutomationRuleEvaluatorWriteAction(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AutomationRuleEvaluatorWriteAction) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AutomationRuleEvaluatorWriteAction) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AutomationRuleEvaluatorWriteType as json.
func (s AutomationRuleEvaluatorWriteType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AutomationRuleEvaluatorWriteType from json.
func (s *AutomationRuleEvaluatorWriteType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutomationRuleEvaluatorWriteType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AutomationRuleEvaluatorWriteType(v) {
	case AutomationRuleEvaluatorWriteTypeLlmAsJudge:
		*s = AutomationRuleEvaluatorWriteTypeLlmAsJudge
	case AutomationRuleEvaluatorWriteTypeUserDefinedMetricPython:
		*s = AutomationRuleEvaluatorWriteTypeUserDefinedMetricPython
	case AutomationRuleEvaluatorWriteTypeTraceThreadLlmAsJudge:
		*s = AutomationRuleEvaluatorWriteTypeTraceThreadLlmAsJudge
	case AutomationRuleEvaluatorWriteTypeTraceThreadUserDefinedMetricPython:
		*s = AutomationRuleEvaluatorWriteTypeTraceThreadUserDefinedMetricPython
	case AutomationRuleEvaluatorWriteTypeSpanLlmAsJudge:
		*s = AutomationRuleEvaluatorWriteTypeSpanLlmAsJudge
	case AutomationRuleEvaluatorWriteTypeSpanUserDefinedMetricPython:
		*s = AutomationRuleEvaluatorWriteTypeSpanUserDefinedMetricPython
	default:
		*s = AutomationRuleEvaluatorWriteType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AutomationRuleEvaluatorWriteType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AutomationRuleEvaluatorWriteType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BatchDelete) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BatchDelete) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("ids")
		e.ArrStart()
		for _, elem := range s.Ids {
			json.EncodeUUID(e, elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfBatchDelete = [1]string{
	0: "ids",
}

// Decode decodes BatchDelete from json.
func (s *BatchDelete) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BatchDelete to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ids":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Ids = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.Ids = append(s.Ids, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ids\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BatchDelete")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBatchDelete) {
					name = jsonFieldsNameOfBatchDelete[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BatchDelete) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BatchDelete) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BiInformation) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BiInformation) encodeFields(e *jx.Encoder) {
	{
		if s.WorkspaceID.Set {
			e.FieldStart("workspace_id")
			s.WorkspaceID.Encode(e)
		}
	}
	{
		if s.User.Set {
			e.FieldStart("user")
			s.User.Encode(e)
		}
	}
	{
		if s.Count.Set {
			e.FieldStart("count")
			s.Count.Encode(e)
		}
	}
}

var jsonFieldsNameOfBiInformation = [3]string{
	0: "workspace_id",
	1: "user",
	2: "count",
}

// Decode decodes BiInformation from json.
func (s *BiInformation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BiInformation to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "workspace_id":
			if err := func() error {
				s.WorkspaceID.Reset()
				if err := s.WorkspaceID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"workspace_id\"")
			}
		case "user":
			if err := func() error {
				s.User.Reset()
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "count":
			if err := func() error {
				s.Count.Reset()
				if err := s.Count.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"count\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BiInformation")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BiInformation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BiInformation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BiInformationResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BiInformationResponse) encodeFields(e *jx.Encoder) {
	{
		if s.BiInformation != nil {
			e.FieldStart("bi_information")
			e.ArrStart()
			for _, elem := range s.BiInformation {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfBiInformationResponse = [1]string{
	0: "bi_information",
}

// Decode decodes BiInformationResponse from json.
func (s *BiInformationResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BiInformationResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "bi_information":
			if err := func() error {
				s.BiInformation = make([]BiInformation, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem BiInformation
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.BiInformation = append(s.BiInformation, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bi_information\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BiInformationResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BiInformationResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BiInformationResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ChatCompletionChoice) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ChatCompletionChoice) encodeFields(e *jx.Encoder) {
	{
		if s.Index.Set {
			e.FieldStart("index")
			s.Index.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.Delta.Set {
			e.FieldStart("delta")
			s.Delta.Encode(e)
		}
	}
	{
		if s.FinishReason.Set {
			e.FieldStart("finish_reason")
			s.FinishReason.Encode(e)
		}
	}
}

var jsonFieldsNameOfChatCompletionChoice = [4]string{
	0: "index",
	1: "message",
	2: "delta",
	3: "finish_reason",
}

// Decode decodes ChatCompletionChoice from json.
func (s *ChatCompletionChoice) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChatCompletionChoice to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "index":
			if err := func() error {
				s.Index.Reset()
				if err := s.Index.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"index\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "delta":
			if err := func() error {
				s.Delta.Reset()
				if err := s.Delta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"delta\"")
			}
		case "finish_reason":
			if err := func() error {
				s.FinishReason.Reset()
				if err := s.FinishReason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"finish_reason\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChatCompletionChoice")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ChatCompletionChoice) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChatCompletionChoice) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ChatCompletionRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ChatCompletionRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Model.Set {
			e.FieldStart("model")
			s.Model.Encode(e)
		}
	}
	{
		if s.Messages != nil {
			e.FieldStart("messages")
			e.ArrStart()
			for _, elem := range s.Messages {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Temperature.Set {
			e.FieldStart("temperature")
			s.Temperature.Encode(e)
		}
	}
	{
		if s.TopP.Set {
			e.FieldStart("top_p")
			s.TopP.Encode(e)
		}
	}
	{
		if s.N.Set {
			e.FieldStart("n")
			s.N.Encode(e)
		}
	}
	{
		if s.Stream.Set {
			e.FieldStart("stream")
			s.Stream.Encode(e)
		}
	}
	{
		if s.StreamOptions.Set {
			e.FieldStart("stream_options")
			s.StreamOptions.Encode(e)
		}
	}
	{
		if s.Stop != nil {
			e.FieldStart("stop")
			e.ArrStart()
			for _, elem := range s.Stop {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.MaxTokens.Set {
			e.FieldStart("max_tokens")
			s.MaxTokens.Encode(e)
		}
	}
	{
		if s.MaxCompletionTokens.Set {
			e.FieldStart("max_completion_tokens")
			s.MaxCompletionTokens.Encode(e)
		}
	}
	{
		if s.PresencePenalty.Set {
			e.FieldStart("presence_penalty")
			s.PresencePenalty.Encode(e)
		}
	}
	{
		if s.FrequencyPenalty.Set {
			e.FieldStart("frequency_penalty")
			s.FrequencyPenalty.Encode(e)
		}
	}
	{
		if s.LogitBias.Set {
			e.FieldStart("logit_bias")
			s.LogitBias.Encode(e)
		}
	}
	{
		if s.User.Set {
			e.FieldStart("user")
			s.User.Encode(e)
		}
	}
	{
		if s.ResponseFormat.Set {
			e.FieldStart("response_format")
			s.ResponseFormat.Encode(e)
		}
	}
	{
		if s.Seed.Set {
			e.FieldStart("seed")
			s.Seed.Encode(e)
		}
	}
	{
		if s.Tools != nil {
			e.FieldStart("tools")
			e.ArrStart()
			for _, elem := range s.Tools {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ToolChoice != nil {
			e.FieldStart("tool_choice")
			s.ToolChoice.Encode(e)
		}
	}
	{
		if s.ParallelToolCalls.Set {
			e.FieldStart("parallel_tool_calls")
			s.ParallelToolCalls.Encode(e)
		}
	}
	{
		if s.Store.Set {
			e.FieldStart("store")
			s.Store.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.ReasoningEffort.Set {
			e.FieldStart("reasoning_effort")
			s.ReasoningEffort.Encode(e)
		}
	}
	{
		if s.ServiceTier.Set {
			e.FieldStart("service_tier")
			s.ServiceTier.Encode(e)
		}
	}
	{
		if s.Functions != nil {
			e.FieldStart("functions")
			e.ArrStart()
			for _, elem := range s.Functions {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.FunctionCall.Set {
			e.FieldStart("function_call")
			s.FunctionCall.Encode(e)
		}
	}
}

var jsonFieldsNameOfChatCompletionRequest = [25]string{
	0:  "model",
	1:  "messages",
	2:  "temperature",
	3:  "top_p",
	4:  "n",
	5:  "stream",
	6:  "stream_options",
	7:  "stop",
	8:  "max_tokens",
	9:  "max_completion_tokens",
	10: "presence_penalty",
	11: "frequency_penalty",
	12: "logit_bias",
	13: "user",
	14: "response_format",
	15: "seed",
	16: "tools",
	17: "tool_choice",
	18: "parallel_tool_calls",
	19: "store",
	20: "metadata",
	21: "reasoning_effort",
	22: "service_tier",
	23: "functions",
	24: "function_call",
}

// Decode decodes ChatCompletionRequest from json.
func (s *ChatCompletionRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChatCompletionRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "model":
			if err := func() error {
				s.Model.Reset()
				if err := s.Model.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"model\"")
			}
		case "messages":
			if err := func() error {
				s.Messages = make([]Message, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Message
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Messages = append(s.Messages, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"messages\"")
			}
		case "temperature":
			if err := func() error {
				s.Temperature.Reset()
				if err := s.Temperature.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"temperature\"")
			}
		case "top_p":
			if err := func() error {
				s.TopP.Reset()
				if err := s.TopP.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"top_p\"")
			}
		case "n":
			if err := func() error {
				s.N.Reset()
				if err := s.N.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"n\"")
			}
		case "stream":
			if err := func() error {
				s.Stream.Reset()
				if err := s.Stream.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stream\"")
			}
		case "stream_options":
			if err := func() error {
				s.StreamOptions.Reset()
				if err := s.StreamOptions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stream_options\"")
			}
		case "stop":
			if err := func() error {
				s.Stop = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Stop = append(s.Stop, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stop\"")
			}
		case "max_tokens":
			if err := func() error {
				s.MaxTokens.Reset()
				if err := s.MaxTokens.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_tokens\"")
			}
		case "max_completion_tokens":
			if err := func() error {
				s.MaxCompletionTokens.Reset()
				if err := s.MaxCompletionTokens.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_completion_tokens\"")
			}
		case "presence_penalty":
			if err := func() error {
				s.PresencePenalty.Reset()
				if err := s.PresencePenalty.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"presence_penalty\"")
			}
		case "frequency_penalty":
			if err := func() error {
				s.FrequencyPenalty.Reset()
				if err := s.FrequencyPenalty.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"frequency_penalty\"")
			}
		case "logit_bias":
			if err := func() error {
				s.LogitBias.Reset()
				if err := s.LogitBias.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"logit_bias\"")
			}
		case "user":
			if err := func() error {
				s.User.Reset()
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "response_format":
			if err := func() error {
				s.ResponseFormat.Reset()
				if err := s.ResponseFormat.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response_format\"")
			}
		case "seed":
			if err := func() error {
				s.Seed.Reset()
				if err := s.Seed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"seed\"")
			}
		case "tools":
			if err := func() error {
				s.Tools = make([]Tool, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Tool
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Tools = append(s.Tools, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tools\"")
			}
		case "tool_choice":
			if err := func() error {
				s.ToolChoice = nil
				var elem ChatCompletionRequestToolChoice
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.ToolChoice = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tool_choice\"")
			}
		case "parallel_tool_calls":
			if err := func() error {
				s.ParallelToolCalls.Reset()
				if err := s.ParallelToolCalls.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parallel_tool_calls\"")
			}
		case "store":
			if err := func() error {
				s.Store.Reset()
				if err := s.Store.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"store\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "reasoning_effort":
			if err := func() error {
				s.ReasoningEffort.Reset()
				if err := s.ReasoningEffort.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reasoning_effort\"")
			}
		case "service_tier":
			if err := func() error {
				s.ServiceTier.Reset()
				if err := s.ServiceTier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"service_tier\"")
			}
		case "functions":
			if err := func() error {
				s.Functions = make([]Function, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Function
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Functions = append(s.Functions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"functions\"")
			}
		case "function_call":
			if err := func() error {
				s.FunctionCall.Reset()
				if err := s.FunctionCall.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"function_call\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChatCompletionRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ChatCompletionRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChatCompletionRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ChatCompletionRequestLogitBias) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s ChatCompletionRequestLogitBias) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Int32(elem)
	}
}

// Decode decodes ChatCompletionRequestLogitBias from json.
func (s *ChatCompletionRequestLogitBias) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChatCompletionRequestLogitBias to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem int32
		if err := func() error {
			v, err := d.Int32()
			elem = int32(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChatCompletionRequestLogitBias")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ChatCompletionRequestLogitBias) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChatCompletionRequestLogitBias) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ChatCompletionRequestMetadata) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s ChatCompletionRequestMetadata) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes ChatCompletionRequestMetadata from json.
func (s *ChatCompletionRequestMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChatCompletionRequestMetadata to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChatCompletionRequestMetadata")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ChatCompletionRequestMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChatCompletionRequestMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ChatCompletionRequestToolChoice) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ChatCompletionRequestToolChoice) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfChatCompletionRequestToolChoice = [0]string{}

// Decode decodes ChatCompletionRequestToolChoice from json.
func (s *ChatCompletionRequestToolChoice) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChatCompletionRequestToolChoice to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode ChatCompletionRequestToolChoice")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ChatCompletionRequestToolChoice) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChatCompletionRequestToolChoice) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ChatCompletionResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ChatCompletionResponse) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Created.Set {
			e.FieldStart("created")
			s.Created.Encode(e)
		}
	}
	{
		if s.Model.Set {
			e.FieldStart("model")
			s.Model.Encode(e)
		}
	}
	{
		if s.Choices != nil {
			e.FieldStart("choices")
			e.ArrStart()
			for _, elem := range s.Choices {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Usage.Set {
			e.FieldStart("usage")
			s.Usage.Encode(e)
		}
	}
	{
		if s.SystemFingerprint.Set {
			e.FieldStart("system_fingerprint")
			s.SystemFingerprint.Encode(e)
		}
	}
	{
		if s.ServiceTier.Set {
			e.FieldStart("service_tier")
			s.ServiceTier.Encode(e)
		}
	}
}

var jsonFieldsNameOfChatCompletionResponse = [7]string{
	0: "id",
	1: "created",
	2: "model",
	3: "choices",
	4: "usage",
	5: "system_fingerprint",
	6: "service_tier",
}

// Decode decodes ChatCompletionResponse from json.
func (s *ChatCompletionResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChatCompletionResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "created":
			if err := func() error {
				s.Created.Reset()
				if err := s.Created.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created\"")
			}
		case "model":
			if err := func() error {
				s.Model.Reset()
				if err := s.Model.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"model\"")
			}
		case "choices":
			if err := func() error {
				s.Choices = make([]ChatCompletionChoice, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ChatCompletionChoice
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Choices = append(s.Choices, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"choices\"")
			}
		case "usage":
			if err := func() error {
				s.Usage.Reset()
				if err := s.Usage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usage\"")
			}
		case "system_fingerprint":
			if err := func() error {
				s.SystemFingerprint.Reset()
				if err := s.SystemFingerprint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"system_fingerprint\"")
			}
		case "service_tier":
			if err := func() error {
				s.ServiceTier.Reset()
				if err := s.ServiceTier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"service_tier\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChatCompletionResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ChatCompletionResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChatCompletionResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CheckAccessForbidden as json.
func (s *CheckAccessForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessage)(s)

	unwrapped.Encode(e)
}

// Decode decodes CheckAccessForbidden from json.
func (s *CheckAccessForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CheckAccessForbidden to nil")
	}
	var unwrapped ErrorMessage
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CheckAccessForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CheckAccessForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CheckAccessForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CheckAccessUnauthorized as json.
func (s *CheckAccessUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessage)(s)

	unwrapped.Encode(e)
}

// Decode decodes CheckAccessUnauthorized from json.
func (s *CheckAccessUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CheckAccessUnauthorized to nil")
	}
	var unwrapped ErrorMessage
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CheckAccessUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CheckAccessUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CheckAccessUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CheckPublic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CheckPublic) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Result.Set {
			e.FieldStart("result")
			s.Result.Encode(e)
		}
	}
}

var jsonFieldsNameOfCheckPublic = [2]string{
	0: "name",
	1: "result",
}

// Decode decodes CheckPublic from json.
func (s *CheckPublic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CheckPublic to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "result":
			if err := func() error {
				s.Result.Reset()
				if err := s.Result.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CheckPublic")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CheckPublic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CheckPublic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CheckPublicName as json.
func (s CheckPublicName) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CheckPublicName from json.
func (s *CheckPublicName) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CheckPublicName to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CheckPublicName(v) {
	case CheckPublicNameTOPIC:
		*s = CheckPublicNameTOPIC
	case CheckPublicNamePII:
		*s = CheckPublicNamePII
	default:
		*s = CheckPublicName(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CheckPublicName) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CheckPublicName) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CheckPublicResult as json.
func (s CheckPublicResult) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CheckPublicResult from json.
func (s *CheckPublicResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CheckPublicResult to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CheckPublicResult(v) {
	case CheckPublicResultPassed:
		*s = CheckPublicResultPassed
	case CheckPublicResultFailed:
		*s = CheckPublicResultFailed
	default:
		*s = CheckPublicResult(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CheckPublicResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CheckPublicResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Column) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Column) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Types != nil {
			e.FieldStart("types")
			e.ArrStart()
			for _, elem := range s.Types {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.FilterFieldPrefix.Set {
			e.FieldStart("filter_field_prefix")
			s.FilterFieldPrefix.Encode(e)
		}
	}
	{
		if s.FilterField.Set {
			e.FieldStart("filterField")
			s.FilterField.Encode(e)
		}
	}
}

var jsonFieldsNameOfColumn = [4]string{
	0: "name",
	1: "types",
	2: "filter_field_prefix",
	3: "filterField",
}

// Decode decodes Column from json.
func (s *Column) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Column to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "types":
			if err := func() error {
				s.Types = make([]ColumnTypesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ColumnTypesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Types = append(s.Types, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"types\"")
			}
		case "filter_field_prefix":
			if err := func() error {
				s.FilterFieldPrefix.Reset()
				if err := s.FilterFieldPrefix.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"filter_field_prefix\"")
			}
		case "filterField":
			if err := func() error {
				s.FilterField.Reset()
				if err := s.FilterField.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"filterField\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Column")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Column) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Column) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ColumnCompare) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ColumnCompare) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Types != nil {
			e.FieldStart("types")
			e.ArrStart()
			for _, elem := range s.Types {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.FilterFieldPrefix.Set {
			e.FieldStart("filter_field_prefix")
			s.FilterFieldPrefix.Encode(e)
		}
	}
	{
		if s.FilterField.Set {
			e.FieldStart("filterField")
			s.FilterField.Encode(e)
		}
	}
}

var jsonFieldsNameOfColumnCompare = [4]string{
	0: "name",
	1: "types",
	2: "filter_field_prefix",
	3: "filterField",
}

// Decode decodes ColumnCompare from json.
func (s *ColumnCompare) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ColumnCompare to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "types":
			if err := func() error {
				s.Types = make([]ColumnCompareTypesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ColumnCompareTypesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Types = append(s.Types, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"types\"")
			}
		case "filter_field_prefix":
			if err := func() error {
				s.FilterFieldPrefix.Reset()
				if err := s.FilterFieldPrefix.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"filter_field_prefix\"")
			}
		case "filterField":
			if err := func() error {
				s.FilterField.Reset()
				if err := s.FilterField.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"filterField\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ColumnCompare")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ColumnCompare) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ColumnCompare) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ColumnCompareTypesItem as json.
func (s ColumnCompareTypesItem) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ColumnCompareTypesItem from json.
func (s *ColumnCompareTypesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ColumnCompareTypesItem to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ColumnCompareTypesItem(v) {
	case ColumnCompareTypesItemString:
		*s = ColumnCompareTypesItemString
	case ColumnCompareTypesItemNumber:
		*s = ColumnCompareTypesItemNumber
	case ColumnCompareTypesItemObject:
		*s = ColumnCompareTypesItemObject
	case ColumnCompareTypesItemBoolean:
		*s = ColumnCompareTypesItemBoolean
	case ColumnCompareTypesItemArray:
		*s = ColumnCompareTypesItemArray
	case ColumnCompareTypesItemNull:
		*s = ColumnCompareTypesItemNull
	default:
		*s = ColumnCompareTypesItem(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ColumnCompareTypesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ColumnCompareTypesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ColumnPublic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ColumnPublic) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Types != nil {
			e.FieldStart("types")
			e.ArrStart()
			for _, elem := range s.Types {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.FilterFieldPrefix.Set {
			e.FieldStart("filter_field_prefix")
			s.FilterFieldPrefix.Encode(e)
		}
	}
	{
		if s.FilterField.Set {
			e.FieldStart("filterField")
			s.FilterField.Encode(e)
		}
	}
}

var jsonFieldsNameOfColumnPublic = [4]string{
	0: "name",
	1: "types",
	2: "filter_field_prefix",
	3: "filterField",
}

// Decode decodes ColumnPublic from json.
func (s *ColumnPublic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ColumnPublic to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "types":
			if err := func() error {
				s.Types = make([]ColumnPublicTypesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ColumnPublicTypesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Types = append(s.Types, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"types\"")
			}
		case "filter_field_prefix":
			if err := func() error {
				s.FilterFieldPrefix.Reset()
				if err := s.FilterFieldPrefix.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"filter_field_prefix\"")
			}
		case "filterField":
			if err := func() error {
				s.FilterField.Reset()
				if err := s.FilterField.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"filterField\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ColumnPublic")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ColumnPublic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ColumnPublic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ColumnPublicTypesItem as json.
func (s ColumnPublicTypesItem) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ColumnPublicTypesItem from json.
func (s *ColumnPublicTypesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ColumnPublicTypesItem to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ColumnPublicTypesItem(v) {
	case ColumnPublicTypesItemString:
		*s = ColumnPublicTypesItemString
	case ColumnPublicTypesItemNumber:
		*s = ColumnPublicTypesItemNumber
	case ColumnPublicTypesItemObject:
		*s = ColumnPublicTypesItemObject
	case ColumnPublicTypesItemBoolean:
		*s = ColumnPublicTypesItemBoolean
	case ColumnPublicTypesItemArray:
		*s = ColumnPublicTypesItemArray
	case ColumnPublicTypesItemNull:
		*s = ColumnPublicTypesItemNull
	default:
		*s = ColumnPublicTypesItem(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ColumnPublicTypesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ColumnPublicTypesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ColumnTypesItem as json.
func (s ColumnTypesItem) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ColumnTypesItem from json.
func (s *ColumnTypesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ColumnTypesItem to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ColumnTypesItem(v) {
	case ColumnTypesItemString:
		*s = ColumnTypesItemString
	case ColumnTypesItemNumber:
		*s = ColumnTypesItemNumber
	case ColumnTypesItemObject:
		*s = ColumnTypesItemObject
	case ColumnTypesItemBoolean:
		*s = ColumnTypesItemBoolean
	case ColumnTypesItemArray:
		*s = ColumnTypesItemArray
	case ColumnTypesItemNull:
		*s = ColumnTypesItemNull
	default:
		*s = ColumnTypesItem(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ColumnTypesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ColumnTypesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Comment) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Comment) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		e.FieldStart("text")
		e.Str(s.Text)
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.LastUpdatedAt.Set {
			e.FieldStart("last_updated_at")
			s.LastUpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.CreatedBy.Set {
			e.FieldStart("created_by")
			s.CreatedBy.Encode(e)
		}
	}
	{
		if s.LastUpdatedBy.Set {
			e.FieldStart("last_updated_by")
			s.LastUpdatedBy.Encode(e)
		}
	}
}

var jsonFieldsNameOfComment = [6]string{
	0: "id",
	1: "text",
	2: "created_at",
	3: "last_updated_at",
	4: "created_by",
	5: "last_updated_by",
}

// Decode decodes Comment from json.
func (s *Comment) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Comment to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "text":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Text = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "last_updated_at":
			if err := func() error {
				s.LastUpdatedAt.Reset()
				if err := s.LastUpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated_at\"")
			}
		case "created_by":
			if err := func() error {
				s.CreatedBy.Reset()
				if err := s.CreatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_by\"")
			}
		case "last_updated_by":
			if err := func() error {
				s.LastUpdatedBy.Reset()
				if err := s.LastUpdatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated_by\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Comment")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfComment) {
					name = jsonFieldsNameOfComment[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Comment) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Comment) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CommentCompare) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CommentCompare) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		e.FieldStart("text")
		e.Str(s.Text)
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.LastUpdatedAt.Set {
			e.FieldStart("last_updated_at")
			s.LastUpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.CreatedBy.Set {
			e.FieldStart("created_by")
			s.CreatedBy.Encode(e)
		}
	}
	{
		if s.LastUpdatedBy.Set {
			e.FieldStart("last_updated_by")
			s.LastUpdatedBy.Encode(e)
		}
	}
}

var jsonFieldsNameOfCommentCompare = [6]string{
	0: "id",
	1: "text",
	2: "created_at",
	3: "last_updated_at",
	4: "created_by",
	5: "last_updated_by",
}

// Decode decodes CommentCompare from json.
func (s *CommentCompare) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CommentCompare to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "text":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Text = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "last_updated_at":
			if err := func() error {
				s.LastUpdatedAt.Reset()
				if err := s.LastUpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated_at\"")
			}
		case "created_by":
			if err := func() error {
				s.CreatedBy.Reset()
				if err := s.CreatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_by\"")
			}
		case "last_updated_by":
			if err := func() error {
				s.LastUpdatedBy.Reset()
				if err := s.LastUpdatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated_by\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CommentCompare")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCommentCompare) {
					name = jsonFieldsNameOfCommentCompare[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CommentCompare) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CommentCompare) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CommentPublic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CommentPublic) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		e.FieldStart("text")
		e.Str(s.Text)
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.LastUpdatedAt.Set {
			e.FieldStart("last_updated_at")
			s.LastUpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.CreatedBy.Set {
			e.FieldStart("created_by")
			s.CreatedBy.Encode(e)
		}
	}
	{
		if s.LastUpdatedBy.Set {
			e.FieldStart("last_updated_by")
			s.LastUpdatedBy.Encode(e)
		}
	}
}

var jsonFieldsNameOfCommentPublic = [6]string{
	0: "id",
	1: "text",
	2: "created_at",
	3: "last_updated_at",
	4: "created_by",
	5: "last_updated_by",
}

// Decode decodes CommentPublic from json.
func (s *CommentPublic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CommentPublic to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "text":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Text = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "last_updated_at":
			if err := func() error {
				s.LastUpdatedAt.Reset()
				if err := s.LastUpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated_at\"")
			}
		case "created_by":
			if err := func() error {
				s.CreatedBy.Reset()
				if err := s.CreatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_by\"")
			}
		case "last_updated_by":
			if err := func() error {
				s.LastUpdatedBy.Reset()
				if err := s.LastUpdatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated_by\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CommentPublic")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCommentPublic) {
					name = jsonFieldsNameOfCommentPublic[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CommentPublic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CommentPublic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CompleteMultiPartUploadForbidden as json.
func (s *CompleteMultiPartUploadForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessage)(s)

	unwrapped.Encode(e)
}

// Decode decodes CompleteMultiPartUploadForbidden from json.
func (s *CompleteMultiPartUploadForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CompleteMultiPartUploadForbidden to nil")
	}
	var unwrapped ErrorMessage
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CompleteMultiPartUploadForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CompleteMultiPartUploadForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CompleteMultiPartUploadForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CompleteMultiPartUploadUnauthorized as json.
func (s *CompleteMultiPartUploadUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessage)(s)

	unwrapped.Encode(e)
}

// Decode decodes CompleteMultiPartUploadUnauthorized from json.
func (s *CompleteMultiPartUploadUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CompleteMultiPartUploadUnauthorized to nil")
	}
	var unwrapped ErrorMessage
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CompleteMultiPartUploadUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CompleteMultiPartUploadUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CompleteMultiPartUploadUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CompleteMultipartUploadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CompleteMultipartUploadRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("file_name")
		e.Str(s.FileName)
	}
	{
		if s.ProjectName.Set {
			e.FieldStart("project_name")
			s.ProjectName.Encode(e)
		}
	}
	{
		e.FieldStart("entity_type")
		s.EntityType.Encode(e)
	}
	{
		e.FieldStart("entity_id")
		json.EncodeUUID(e, s.EntityID)
	}
	{
		if s.ContainerID.Set {
			e.FieldStart("container_id")
			s.ContainerID.Encode(e)
		}
	}
	{
		e.FieldStart("file_size")
		e.Int64(s.FileSize)
	}
	{
		if s.MimeType.Set {
			e.FieldStart("mime_type")
			s.MimeType.Encode(e)
		}
	}
	{
		e.FieldStart("upload_id")
		e.Str(s.UploadID)
	}
	{
		e.FieldStart("uploaded_file_parts")
		e.ArrStart()
		for _, elem := range s.UploadedFileParts {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfCompleteMultipartUploadRequest = [9]string{
	0: "file_name",
	1: "project_name",
	2: "entity_type",
	3: "entity_id",
	4: "container_id",
	5: "file_size",
	6: "mime_type",
	7: "upload_id",
	8: "uploaded_file_parts",
}

// Decode decodes CompleteMultipartUploadRequest from json.
func (s *CompleteMultipartUploadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CompleteMultipartUploadRequest to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "file_name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.FileName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_name\"")
			}
		case "project_name":
			if err := func() error {
				s.ProjectName.Reset()
				if err := s.ProjectName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"project_name\"")
			}
		case "entity_type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.EntityType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"entity_type\"")
			}
		case "entity_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.EntityID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"entity_id\"")
			}
		case "container_id":
			if err := func() error {
				s.ContainerID.Reset()
				if err := s.ContainerID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"container_id\"")
			}
		case "file_size":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int64()
				s.FileSize = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_size\"")
			}
		case "mime_type":
			if err := func() error {
				s.MimeType.Reset()
				if err := s.MimeType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mime_type\"")
			}
		case "upload_id":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.UploadID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"upload_id\"")
			}
		case "uploaded_file_parts":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				s.UploadedFileParts = make([]MultipartUploadPart, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MultipartUploadPart
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.UploadedFileParts = append(s.UploadedFileParts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uploaded_file_parts\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CompleteMultipartUploadRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b10101101,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCompleteMultipartUploadRequest) {
					name = jsonFieldsNameOfCompleteMultipartUploadRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CompleteMultipartUploadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CompleteMultipartUploadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CompleteMultipartUploadRequestEntityType as json.
func (s CompleteMultipartUploadRequestEntityType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CompleteMultipartUploadRequestEntityType from json.
func (s *CompleteMultipartUploadRequestEntityType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CompleteMultipartUploadRequestEntityType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CompleteMultipartUploadRequestEntityType(v) {
	case CompleteMultipartUploadRequestEntityTypeTrace:
		*s = CompleteMultipartUploadRequestEntityTypeTrace
	case CompleteMultipartUploadRequestEntityTypeSpan:
		*s = CompleteMultipartUploadRequestEntityTypeSpan
	default:
		*s = CompleteMultipartUploadRequestEntityType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CompleteMultipartUploadRequestEntityType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CompleteMultipartUploadRequestEntityType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CompletionTokensDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CompletionTokensDetails) encodeFields(e *jx.Encoder) {
	{
		if s.ReasoningTokens.Set {
			e.FieldStart("reasoning_tokens")
			s.ReasoningTokens.Encode(e)
		}
	}
}

var jsonFieldsNameOfCompletionTokensDetails = [1]string{
	0: "reasoning_tokens",
}

// Decode decodes CompletionTokensDetails from json.
func (s *CompletionTokensDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CompletionTokensDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "reasoning_tokens":
			if err := func() error {
				s.ReasoningTokens.Reset()
				if err := s.ReasoningTokens.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reasoning_tokens\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CompletionTokensDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CompletionTokensDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CompletionTokensDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateAlertBadRequest as json.
func (s *CreateAlertBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessage)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateAlertBadRequest from json.
func (s *CreateAlertBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateAlertBadRequest to nil")
	}
	var unwrapped ErrorMessage
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateAlertBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateAlertBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateAlertBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateAlertConflict as json.
func (s *CreateAlertConflict) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessage)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateAlertConflict from json.
func (s *CreateAlertConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateAlertConflict to nil")
	}
	var unwrapped ErrorMessage
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateAlertConflict(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateAlertConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateAlertConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateAlertUnprocessableEntity as json.
func (s *CreateAlertUnprocessableEntity) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessage)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateAlertUnprocessableEntity from json.
func (s *CreateAlertUnprocessableEntity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateAlertUnprocessableEntity to nil")
	}
	var unwrapped ErrorMessage
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateAlertUnprocessableEntity(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateAlertUnprocessableEntity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateAlertUnprocessableEntity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateAnnotationQueueBadRequest as json.
func (s *CreateAnnotationQueueBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessage)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateAnnotationQueueBadRequest from json.
func (s *CreateAnnotationQueueBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateAnnotationQueueBadRequest to nil")
	}
	var unwrapped ErrorMessage
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateAnnotationQueueBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateAnnotationQueueBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateAnnotationQueueBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateAnnotationQueueBatchBadRequest as json.
func (s *CreateAnnotationQueueBatchBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessage)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateAnnotationQueueBatchBadRequest from json.
func (s *CreateAnnotationQueueBatchBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateAnnotationQueueBatchBadRequest to nil")
	}
	var unwrapped ErrorMessage
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateAnnotationQueueBatchBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateAnnotationQueueBatchBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateAnnotationQueueBatchBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateAnnotationQueueBatchConflict as json.
func (s *CreateAnnotationQueueBatchConflict) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessage)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateAnnotationQueueBatchConflict from json.
func (s *CreateAnnotationQueueBatchConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateAnnotationQueueBatchConflict to nil")
	}
	var unwrapped ErrorMessage
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateAnnotationQueueBatchConflict(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateAnnotationQueueBatchConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateAnnotationQueueBatchConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateAnnotationQueueBatchUnprocessableEntity as json.
func (s *CreateAnnotationQueueBatchUnprocessableEntity) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessage)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateAnnotationQueueBatchUnprocessableEntity from json.
func (s *CreateAnnotationQueueBatchUnprocessableEntity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateAnnotationQueueBatchUnprocessableEntity to nil")
	}
	var unwrapped ErrorMessage
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateAnnotationQueueBatchUnprocessableEntity(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateAnnotationQueueBatchUnprocessableEntity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateAnnotationQueueBatchUnprocessableEntity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateAnnotationQueueUnprocessableEntity as json.
func (s *CreateAnnotationQueueUnprocessableEntity) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessage)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateAnnotationQueueUnprocessableEntity from json.
func (s *CreateAnnotationQueueUnprocessableEntity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateAnnotationQueueUnprocessableEntity to nil")
	}
	var unwrapped ErrorMessage
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateAnnotationQueueUnprocessableEntity(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateAnnotationQueueUnprocessableEntity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateAnnotationQueueUnprocessableEntity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateDatasetItemsFromCsvBadRequest as json.
func (s *CreateDatasetItemsFromCsvBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessage)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateDatasetItemsFromCsvBadRequest from json.
func (s *CreateDatasetItemsFromCsvBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateDatasetItemsFromCsvBadRequest to nil")
	}
	var unwrapped ErrorMessage
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateDatasetItemsFromCsvBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateDatasetItemsFromCsvBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateDatasetItemsFromCsvBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateDatasetItemsFromCsvNotFound as json.
func (s *CreateDatasetItemsFromCsvNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessage)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateDatasetItemsFromCsvNotFound from json.
func (s *CreateDatasetItemsFromCsvNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateDatasetItemsFromCsvNotFound to nil")
	}
	var unwrapped ErrorMessage
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateDatasetItemsFromCsvNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateDatasetItemsFromCsvNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateDatasetItemsFromCsvNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateDatasetItemsFromCsvReqFile) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateDatasetItemsFromCsvReqFile) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCreateDatasetItemsFromCsvReqFile = [0]string{}

// Decode decodes CreateDatasetItemsFromCsvReqFile from json.
func (s *CreateDatasetItemsFromCsvReqFile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateDatasetItemsFromCsvReqFile to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode CreateDatasetItemsFromCsvReqFile")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateDatasetItemsFromCsvReqFile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateDatasetItemsFromCsvReqFile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateDatasetItemsFromSpansRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateDatasetItemsFromSpansRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("span_ids")
		e.ArrStart()
		for _, elem := range s.SpanIds {
			json.EncodeUUID(e, elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("enrichment_options")
		s.EnrichmentOptions.Encode(e)
	}
}

var jsonFieldsNameOfCreateDatasetItemsFromSpansRequest = [2]string{
	0: "span_ids",
	1: "enrichment_options",
}

// Decode decodes CreateDatasetItemsFromSpansRequest from json.
func (s *CreateDatasetItemsFromSpansRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateDatasetItemsFromSpansRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "span_ids":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.SpanIds = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.SpanIds = append(s.SpanIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"span_ids\"")
			}
		case "enrichment_options":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.EnrichmentOptions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enrichment_options\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateDatasetItemsFromSpansRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateDatasetItemsFromSpansRequest) {
					name = jsonFieldsNameOfCreateDatasetItemsFromSpansRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateDatasetItemsFromSpansRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateDatasetItemsFromSpansRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateDatasetItemsFromTracesRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateDatasetItemsFromTracesRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("trace_ids")
		e.ArrStart()
		for _, elem := range s.TraceIds {
			json.EncodeUUID(e, elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("enrichment_options")
		s.EnrichmentOptions.Encode(e)
	}
}

var jsonFieldsNameOfCreateDatasetItemsFromTracesRequest = [2]string{
	0: "trace_ids",
	1: "enrichment_options",
}

// Decode decodes CreateDatasetItemsFromTracesRequest from json.
func (s *CreateDatasetItemsFromTracesRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateDatasetItemsFromTracesRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "trace_ids":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.TraceIds = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.TraceIds = append(s.TraceIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trace_ids\"")
			}
		case "enrichment_options":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.EnrichmentOptions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enrichment_options\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateDatasetItemsFromTracesRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateDatasetItemsFromTracesRequest) {
					name = jsonFieldsNameOfCreateDatasetItemsFromTracesRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateDatasetItemsFromTracesRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateDatasetItemsFromTracesRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateDatasetVersionBadRequest as json.
func (s *CreateDatasetVersionBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessagePublic)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateDatasetVersionBadRequest from json.
func (s *CreateDatasetVersionBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateDatasetVersionBadRequest to nil")
	}
	var unwrapped ErrorMessagePublic
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateDatasetVersionBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateDatasetVersionBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateDatasetVersionBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateDatasetVersionConflict as json.
func (s *CreateDatasetVersionConflict) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessagePublic)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateDatasetVersionConflict from json.
func (s *CreateDatasetVersionConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateDatasetVersionConflict to nil")
	}
	var unwrapped ErrorMessagePublic
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateDatasetVersionConflict(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateDatasetVersionConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateDatasetVersionConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateProjectBadRequest as json.
func (s *CreateProjectBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessage)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateProjectBadRequest from json.
func (s *CreateProjectBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateProjectBadRequest to nil")
	}
	var unwrapped ErrorMessage
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateProjectBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateProjectBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateProjectBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateProjectUnprocessableEntity as json.
func (s *CreateProjectUnprocessableEntity) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessage)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateProjectUnprocessableEntity from json.
func (s *CreateProjectUnprocessableEntity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateProjectUnprocessableEntity to nil")
	}
	var unwrapped ErrorMessage
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateProjectUnprocessableEntity(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateProjectUnprocessableEntity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateProjectUnprocessableEntity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreatePromptBadRequest as json.
func (s *CreatePromptBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessage)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreatePromptBadRequest from json.
func (s *CreatePromptBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreatePromptBadRequest to nil")
	}
	var unwrapped ErrorMessage
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreatePromptBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreatePromptBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreatePromptBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreatePromptConflict as json.
func (s *CreatePromptConflict) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessage)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreatePromptConflict from json.
func (s *CreatePromptConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreatePromptConflict to nil")
	}
	var unwrapped ErrorMessage
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreatePromptConflict(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreatePromptConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreatePromptConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreatePromptUnprocessableEntity as json.
func (s *CreatePromptUnprocessableEntity) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessage)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreatePromptUnprocessableEntity from json.
func (s *CreatePromptUnprocessableEntity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreatePromptUnprocessableEntity to nil")
	}
	var unwrapped ErrorMessage
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreatePromptUnprocessableEntity(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreatePromptUnprocessableEntity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreatePromptUnprocessableEntity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreatePromptVersionBadRequest as json.
func (s *CreatePromptVersionBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessageDetail)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreatePromptVersionBadRequest from json.
func (s *CreatePromptVersionBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreatePromptVersionBadRequest to nil")
	}
	var unwrapped ErrorMessageDetail
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreatePromptVersionBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreatePromptVersionBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreatePromptVersionBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreatePromptVersionConflict as json.
func (s *CreatePromptVersionConflict) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessageDetail)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreatePromptVersionConflict from json.
func (s *CreatePromptVersionConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreatePromptVersionConflict to nil")
	}
	var unwrapped ErrorMessageDetail
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreatePromptVersionConflict(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreatePromptVersionConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreatePromptVersionConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreatePromptVersionDetail) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreatePromptVersionDetail) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("version")
		s.Version.Encode(e)
	}
	{
		if s.TemplateStructure.Set {
			e.FieldStart("template_structure")
			s.TemplateStructure.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreatePromptVersionDetail = [3]string{
	0: "name",
	1: "version",
	2: "template_structure",
}

// Decode decodes CreatePromptVersionDetail from json.
func (s *CreatePromptVersionDetail) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreatePromptVersionDetail to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "version":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "template_structure":
			if err := func() error {
				s.TemplateStructure.Reset()
				if err := s.TemplateStructure.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"template_structure\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreatePromptVersionDetail")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreatePromptVersionDetail) {
					name = jsonFieldsNameOfCreatePromptVersionDetail[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreatePromptVersionDetail) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreatePromptVersionDetail) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreatePromptVersionDetailTemplateStructure as json.
func (s CreatePromptVersionDetailTemplateStructure) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreatePromptVersionDetailTemplateStructure from json.
func (s *CreatePromptVersionDetailTemplateStructure) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreatePromptVersionDetailTemplateStructure to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreatePromptVersionDetailTemplateStructure(v) {
	case CreatePromptVersionDetailTemplateStructureText:
		*s = CreatePromptVersionDetailTemplateStructureText
	case CreatePromptVersionDetailTemplateStructureChat:
		*s = CreatePromptVersionDetailTemplateStructureChat
	default:
		*s = CreatePromptVersionDetailTemplateStructure(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreatePromptVersionDetailTemplateStructure) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreatePromptVersionDetailTemplateStructure) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreatePromptVersionUnprocessableEntity as json.
func (s *CreatePromptVersionUnprocessableEntity) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessageDetail)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreatePromptVersionUnprocessableEntity from json.
func (s *CreatePromptVersionUnprocessableEntity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreatePromptVersionUnprocessableEntity to nil")
	}
	var unwrapped ErrorMessageDetail
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreatePromptVersionUnprocessableEntity(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreatePromptVersionUnprocessableEntity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreatePromptVersionUnprocessableEntity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateVersionTagBadRequest as json.
func (s *CreateVersionTagBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessage)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateVersionTagBadRequest from json.
func (s *CreateVersionTagBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateVersionTagBadRequest to nil")
	}
	var unwrapped ErrorMessage
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateVersionTagBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateVersionTagBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateVersionTagBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateVersionTagConflict as json.
func (s *CreateVersionTagConflict) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessage)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateVersionTagConflict from json.
func (s *CreateVersionTagConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateVersionTagConflict to nil")
	}
	var unwrapped ErrorMessage
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateVersionTagConflict(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateVersionTagConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateVersionTagConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateVersionTagNotFound as json.
func (s *CreateVersionTagNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessage)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateVersionTagNotFound from json.
func (s *CreateVersionTagNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateVersionTagNotFound to nil")
	}
	var unwrapped ErrorMessage
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateVersionTagNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateVersionTagNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateVersionTagNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DashboardPagePublic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DashboardPagePublic) encodeFields(e *jx.Encoder) {
	{
		if s.Content != nil {
			e.FieldStart("content")
			e.ArrStart()
			for _, elem := range s.Content {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Page.Set {
			e.FieldStart("page")
			s.Page.Encode(e)
		}
	}
	{
		if s.Size.Set {
			e.FieldStart("size")
			s.Size.Encode(e)
		}
	}
	{
		if s.Total.Set {
			e.FieldStart("total")
			s.Total.Encode(e)
		}
	}
	{
		if s.SortableBy != nil {
			e.FieldStart("sortable_by")
			e.ArrStart()
			for _, elem := range s.SortableBy {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfDashboardPagePublic = [5]string{
	0: "content",
	1: "page",
	2: "size",
	3: "total",
	4: "sortable_by",
}

// Decode decodes DashboardPagePublic from json.
func (s *DashboardPagePublic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DashboardPagePublic to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "content":
			if err := func() error {
				s.Content = make([]DashboardPublic, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DashboardPublic
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Content = append(s.Content, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		case "page":
			if err := func() error {
				s.Page.Reset()
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "size":
			if err := func() error {
				s.Size.Reset()
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "total":
			if err := func() error {
				s.Total.Reset()
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "sortable_by":
			if err := func() error {
				s.SortableBy = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.SortableBy = append(s.SortableBy, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sortable_by\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DashboardPagePublic")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DashboardPagePublic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DashboardPagePublic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DashboardPublic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DashboardPublic) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.WorkspaceID.Set {
			e.FieldStart("workspace_id")
			s.WorkspaceID.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Slug.Set {
			e.FieldStart("slug")
			s.Slug.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		e.FieldStart("config")
		s.Config.Encode(e)
	}
	{
		if s.CreatedBy.Set {
			e.FieldStart("created_by")
			s.CreatedBy.Encode(e)
		}
	}
	{
		if s.LastUpdatedBy.Set {
			e.FieldStart("last_updated_by")
			s.LastUpdatedBy.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.LastUpdatedAt.Set {
			e.FieldStart("last_updated_at")
			s.LastUpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfDashboardPublic = [10]string{
	0: "id",
	1: "workspace_id",
	2: "name",
	3: "slug",
	4: "description",
	5: "config",
	6: "created_by",
	7: "last_updated_by",
	8: "created_at",
	9: "last_updated_at",
}

// Decode decodes DashboardPublic from json.
func (s *DashboardPublic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DashboardPublic to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "workspace_id":
			if err := func() error {
				s.WorkspaceID.Reset()
				if err := s.WorkspaceID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"workspace_id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "slug":
			if err := func() error {
				s.Slug.Reset()
				if err := s.Slug.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"slug\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "config":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Config.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"config\"")
			}
		case "created_by":
			if err := func() error {
				s.CreatedBy.Reset()
				if err := s.CreatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_by\"")
			}
		case "last_updated_by":
			if err := func() error {
				s.LastUpdatedBy.Reset()
				if err := s.LastUpdatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated_by\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "last_updated_at":
			if err := func() error {
				s.LastUpdatedAt.Reset()
				if err := s.LastUpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DashboardPublic")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00100100,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDashboardPublic) {
					name = jsonFieldsNameOfDashboardPublic[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DashboardPublic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DashboardPublic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DashboardUpdatePublic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DashboardUpdatePublic) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Config.Set {
			e.FieldStart("config")
			s.Config.Encode(e)
		}
	}
}

var jsonFieldsNameOfDashboardUpdatePublic = [3]string{
	0: "name",
	1: "description",
	2: "config",
}

// Decode decodes DashboardUpdatePublic from json.
func (s *DashboardUpdatePublic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DashboardUpdatePublic to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "config":
			if err := func() error {
				s.Config.Reset()
				if err := s.Config.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"config\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DashboardUpdatePublic")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DashboardUpdatePublic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DashboardUpdatePublic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DashboardWrite) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DashboardWrite) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		e.FieldStart("config")
		s.Config.Encode(e)
	}
}

var jsonFieldsNameOfDashboardWrite = [3]string{
	0: "name",
	1: "description",
	2: "config",
}

// Decode decodes DashboardWrite from json.
func (s *DashboardWrite) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DashboardWrite to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "config":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Config.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"config\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DashboardWrite")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDashboardWrite) {
					name = jsonFieldsNameOfDashboardWrite[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DashboardWrite) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DashboardWrite) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DataPointNumberPublic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DataPointNumberPublic) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("time")
		json.EncodeDateTime(e, s.Time)
	}
	{
		if s.Value.Set {
			e.FieldStart("value")
			s.Value.Encode(e)
		}
	}
}

var jsonFieldsNameOfDataPointNumberPublic = [2]string{
	0: "time",
	1: "value",
}

// Decode decodes DataPointNumberPublic from json.
func (s *DataPointNumberPublic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataPointNumberPublic to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "time":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Time = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"time\"")
			}
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DataPointNumberPublic")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDataPointNumberPublic) {
					name = jsonFieldsNameOfDataPointNumberPublic[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DataPointNumberPublic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataPointNumberPublic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatasetExpansionResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatasetExpansionResponse) encodeFields(e *jx.Encoder) {
	{
		if s.GeneratedSamples != nil {
			e.FieldStart("generated_samples")
			e.ArrStart()
			for _, elem := range s.GeneratedSamples {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Model.Set {
			e.FieldStart("model")
			s.Model.Encode(e)
		}
	}
	{
		if s.TotalGenerated.Set {
			e.FieldStart("total_generated")
			s.TotalGenerated.Encode(e)
		}
	}
	{
		if s.GenerationTime.Set {
			e.FieldStart("generation_time")
			s.GenerationTime.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfDatasetExpansionResponse = [4]string{
	0: "generated_samples",
	1: "model",
	2: "total_generated",
	3: "generation_time",
}

// Decode decodes DatasetExpansionResponse from json.
func (s *DatasetExpansionResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatasetExpansionResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "generated_samples":
			if err := func() error {
				s.GeneratedSamples = make([]DatasetItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DatasetItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.GeneratedSamples = append(s.GeneratedSamples, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"generated_samples\"")
			}
		case "model":
			if err := func() error {
				s.Model.Reset()
				if err := s.Model.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"model\"")
			}
		case "total_generated":
			if err := func() error {
				s.TotalGenerated.Reset()
				if err := s.TotalGenerated.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_generated\"")
			}
		case "generation_time":
			if err := func() error {
				s.GenerationTime.Reset()
				if err := s.GenerationTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"generation_time\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatasetExpansionResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatasetExpansionResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatasetExpansionResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatasetExpansionWrite) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatasetExpansionWrite) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("model")
		e.Str(s.Model)
	}
	{
		if s.SampleCount.Set {
			e.FieldStart("sample_count")
			s.SampleCount.Encode(e)
		}
	}
	{
		if s.PreserveFields != nil {
			e.FieldStart("preserve_fields")
			e.ArrStart()
			for _, elem := range s.PreserveFields {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.VariationInstructions.Set {
			e.FieldStart("variation_instructions")
			s.VariationInstructions.Encode(e)
		}
	}
	{
		if s.CustomPrompt.Set {
			e.FieldStart("custom_prompt")
			s.CustomPrompt.Encode(e)
		}
	}
}

var jsonFieldsNameOfDatasetExpansionWrite = [5]string{
	0: "model",
	1: "sample_count",
	2: "preserve_fields",
	3: "variation_instructions",
	4: "custom_prompt",
}

// Decode decodes DatasetExpansionWrite from json.
func (s *DatasetExpansionWrite) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatasetExpansionWrite to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "model":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Model = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"model\"")
			}
		case "sample_count":
			if err := func() error {
				s.SampleCount.Reset()
				if err := s.SampleCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sample_count\"")
			}
		case "preserve_fields":
			if err := func() error {
				s.PreserveFields = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.PreserveFields = append(s.PreserveFields, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"preserve_fields\"")
			}
		case "variation_instructions":
			if err := func() error {
				s.VariationInstructions.Reset()
				if err := s.VariationInstructions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"variation_instructions\"")
			}
		case "custom_prompt":
			if err := func() error {
				s.CustomPrompt.Reset()
				if err := s.CustomPrompt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"custom_prompt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatasetExpansionWrite")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDatasetExpansionWrite) {
					name = jsonFieldsNameOfDatasetExpansionWrite[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatasetExpansionWrite) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatasetExpansionWrite) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatasetIdentifier) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatasetIdentifier) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("dataset_name")
		e.Str(s.DatasetName)
	}
}

var jsonFieldsNameOfDatasetIdentifier = [1]string{
	0: "dataset_name",
}

// Decode decodes DatasetIdentifier from json.
func (s *DatasetIdentifier) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatasetIdentifier to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "dataset_name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.DatasetName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dataset_name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatasetIdentifier")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDatasetIdentifier) {
					name = jsonFieldsNameOfDatasetIdentifier[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatasetIdentifier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatasetIdentifier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatasetIdentifierPublic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatasetIdentifierPublic) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("dataset_name")
		e.Str(s.DatasetName)
	}
}

var jsonFieldsNameOfDatasetIdentifierPublic = [1]string{
	0: "dataset_name",
}

// Decode decodes DatasetIdentifierPublic from json.
func (s *DatasetIdentifierPublic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatasetIdentifierPublic to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "dataset_name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.DatasetName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dataset_name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatasetIdentifierPublic")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDatasetIdentifierPublic) {
					name = jsonFieldsNameOfDatasetIdentifierPublic[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatasetIdentifierPublic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatasetIdentifierPublic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatasetItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatasetItem) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.DraftItemID.Set {
			e.FieldStart("draft_item_id")
			s.DraftItemID.Encode(e)
		}
	}
	{
		if s.TraceID.Set {
			e.FieldStart("trace_id")
			s.TraceID.Encode(e)
		}
	}
	{
		if s.SpanID.Set {
			e.FieldStart("span_id")
			s.SpanID.Encode(e)
		}
	}
	{
		e.FieldStart("source")
		s.Source.Encode(e)
	}
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
	{
		if s.Tags != nil {
			e.FieldStart("tags")
			e.ArrStart()
			for _, elem := range s.Tags {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ExperimentItems != nil {
			e.FieldStart("experiment_items")
			e.ArrStart()
			for _, elem := range s.ExperimentItems {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.DatasetID.Set {
			e.FieldStart("dataset_id")
			s.DatasetID.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.LastUpdatedAt.Set {
			e.FieldStart("last_updated_at")
			s.LastUpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.CreatedBy.Set {
			e.FieldStart("created_by")
			s.CreatedBy.Encode(e)
		}
	}
	{
		if s.LastUpdatedBy.Set {
			e.FieldStart("last_updated_by")
			s.LastUpdatedBy.Encode(e)
		}
	}
}

var jsonFieldsNameOfDatasetItem = [13]string{
	0:  "id",
	1:  "draft_item_id",
	2:  "trace_id",
	3:  "span_id",
	4:  "source",
	5:  "data",
	6:  "tags",
	7:  "experiment_items",
	8:  "dataset_id",
	9:  "created_at",
	10: "last_updated_at",
	11: "created_by",
	12: "last_updated_by",
}

// Decode decodes DatasetItem from json.
func (s *DatasetItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatasetItem to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "draft_item_id":
			if err := func() error {
				s.DraftItemID.Reset()
				if err := s.DraftItemID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"draft_item_id\"")
			}
		case "trace_id":
			if err := func() error {
				s.TraceID.Reset()
				if err := s.TraceID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trace_id\"")
			}
		case "span_id":
			if err := func() error {
				s.SpanID.Reset()
				if err := s.SpanID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"span_id\"")
			}
		case "source":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Source.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		case "data":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "tags":
			if err := func() error {
				s.Tags = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Tags = append(s.Tags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		case "experiment_items":
			if err := func() error {
				s.ExperimentItems = make([]ExperimentItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ExperimentItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ExperimentItems = append(s.ExperimentItems, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"experiment_items\"")
			}
		case "dataset_id":
			if err := func() error {
				s.DatasetID.Reset()
				if err := s.DatasetID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dataset_id\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "last_updated_at":
			if err := func() error {
				s.LastUpdatedAt.Reset()
				if err := s.LastUpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated_at\"")
			}
		case "created_by":
			if err := func() error {
				s.CreatedBy.Reset()
				if err := s.CreatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_by\"")
			}
		case "last_updated_by":
			if err := func() error {
				s.LastUpdatedBy.Reset()
				if err := s.LastUpdatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated_by\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatasetItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00110000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDatasetItem) {
					name = jsonFieldsNameOfDatasetItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatasetItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatasetItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatasetItemBatchUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatasetItemBatchUpdate) encodeFields(e *jx.Encoder) {
	{
		if s.Ids != nil {
			e.FieldStart("ids")
			e.ArrStart()
			for _, elem := range s.Ids {
				json.EncodeUUID(e, elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Filters != nil {
			e.FieldStart("filters")
			e.ArrStart()
			for _, elem := range s.Filters {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("update")
		s.Update.Encode(e)
	}
	{
		if s.MergeTags.Set {
			e.FieldStart("merge_tags")
			s.MergeTags.Encode(e)
		}
	}
}

var jsonFieldsNameOfDatasetItemBatchUpdate = [4]string{
	0: "ids",
	1: "filters",
	2: "update",
	3: "merge_tags",
}

// Decode decodes DatasetItemBatchUpdate from json.
func (s *DatasetItemBatchUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatasetItemBatchUpdate to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ids":
			if err := func() error {
				s.Ids = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.Ids = append(s.Ids, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ids\"")
			}
		case "filters":
			if err := func() error {
				s.Filters = make([]DatasetItemFilter, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DatasetItemFilter
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Filters = append(s.Filters, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"filters\"")
			}
		case "update":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Update.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update\"")
			}
		case "merge_tags":
			if err := func() error {
				s.MergeTags.Reset()
				if err := s.MergeTags.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"merge_tags\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatasetItemBatchUpdate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDatasetItemBatchUpdate) {
					name = jsonFieldsNameOfDatasetItemBatchUpdate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatasetItemBatchUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatasetItemBatchUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatasetItemBatchWrite) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatasetItemBatchWrite) encodeFields(e *jx.Encoder) {
	{
		if s.DatasetName.Set {
			e.FieldStart("dataset_name")
			s.DatasetName.Encode(e)
		}
	}
	{
		if s.DatasetID.Set {
			e.FieldStart("dataset_id")
			s.DatasetID.Encode(e)
		}
	}
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfDatasetItemBatchWrite = [3]string{
	0: "dataset_name",
	1: "dataset_id",
	2: "items",
}

// Decode decodes DatasetItemBatchWrite from json.
func (s *DatasetItemBatchWrite) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatasetItemBatchWrite to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "dataset_name":
			if err := func() error {
				s.DatasetName.Reset()
				if err := s.DatasetName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dataset_name\"")
			}
		case "dataset_id":
			if err := func() error {
				s.DatasetID.Reset()
				if err := s.DatasetID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dataset_id\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Items = make([]DatasetItemWrite, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DatasetItemWrite
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatasetItemBatchWrite")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDatasetItemBatchWrite) {
					name = jsonFieldsNameOfDatasetItemBatchWrite[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatasetItemBatchWrite) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatasetItemBatchWrite) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatasetItemCompare) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatasetItemCompare) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.DraftItemID.Set {
			e.FieldStart("draft_item_id")
			s.DraftItemID.Encode(e)
		}
	}
	{
		if s.TraceID.Set {
			e.FieldStart("trace_id")
			s.TraceID.Encode(e)
		}
	}
	{
		if s.SpanID.Set {
			e.FieldStart("span_id")
			s.SpanID.Encode(e)
		}
	}
	{
		e.FieldStart("source")
		s.Source.Encode(e)
	}
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
	{
		if s.Tags != nil {
			e.FieldStart("tags")
			e.ArrStart()
			for _, elem := range s.Tags {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ExperimentItems != nil {
			e.FieldStart("experiment_items")
			e.ArrStart()
			for _, elem := range s.ExperimentItems {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.DatasetID.Set {
			e.FieldStart("dataset_id")
			s.DatasetID.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.LastUpdatedAt.Set {
			e.FieldStart("last_updated_at")
			s.LastUpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.CreatedBy.Set {
			e.FieldStart("created_by")
			s.CreatedBy.Encode(e)
		}
	}
	{
		if s.LastUpdatedBy.Set {
			e.FieldStart("last_updated_by")
			s.LastUpdatedBy.Encode(e)
		}
	}
}

var jsonFieldsNameOfDatasetItemCompare = [13]string{
	0:  "id",
	1:  "draft_item_id",
	2:  "trace_id",
	3:  "span_id",
	4:  "source",
	5:  "data",
	6:  "tags",
	7:  "experiment_items",
	8:  "dataset_id",
	9:  "created_at",
	10: "last_updated_at",
	11: "created_by",
	12: "last_updated_by",
}

// Decode decodes DatasetItemCompare from json.
func (s *DatasetItemCompare) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatasetItemCompare to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "draft_item_id":
			if err := func() error {
				s.DraftItemID.Reset()
				if err := s.DraftItemID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"draft_item_id\"")
			}
		case "trace_id":
			if err := func() error {
				s.TraceID.Reset()
				if err := s.TraceID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trace_id\"")
			}
		case "span_id":
			if err := func() error {
				s.SpanID.Reset()
				if err := s.SpanID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"span_id\"")
			}
		case "source":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Source.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		case "data":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "tags":
			if err := func() error {
				s.Tags = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Tags = append(s.Tags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		case "experiment_items":
			if err := func() error {
				s.ExperimentItems = make([]ExperimentItemCompare, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ExperimentItemCompare
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ExperimentItems = append(s.ExperimentItems, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"experiment_items\"")
			}
		case "dataset_id":
			if err := func() error {
				s.DatasetID.Reset()
				if err := s.DatasetID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dataset_id\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "last_updated_at":
			if err := func() error {
				s.LastUpdatedAt.Reset()
				if err := s.LastUpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated_at\"")
			}
		case "created_by":
			if err := func() error {
				s.CreatedBy.Reset()
				if err := s.CreatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_by\"")
			}
		case "last_updated_by":
			if err := func() error {
				s.LastUpdatedBy.Reset()
				if err := s.LastUpdatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated_by\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatasetItemCompare")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00110000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDatasetItemCompare) {
					name = jsonFieldsNameOfDatasetItemCompare[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatasetItemCompare) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatasetItemCompare) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatasetItemCompareSource as json.
func (s DatasetItemCompareSource) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DatasetItemCompareSource from json.
func (s *DatasetItemCompareSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatasetItemCompareSource to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DatasetItemCompareSource(v) {
	case DatasetItemCompareSourceManual:
		*s = DatasetItemCompareSourceManual
	case DatasetItemCompareSourceTrace:
		*s = DatasetItemCompareSourceTrace
	case DatasetItemCompareSourceSpan:
		*s = DatasetItemCompareSourceSpan
	case DatasetItemCompareSourceSdk:
		*s = DatasetItemCompareSourceSdk
	default:
		*s = DatasetItemCompareSource(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DatasetItemCompareSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatasetItemCompareSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatasetItemFilter) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatasetItemFilter) encodeFields(e *jx.Encoder) {
	{
		if s.Field.Set {
			e.FieldStart("field")
			s.Field.Encode(e)
		}
	}
	{
		if s.Operator.Set {
			e.FieldStart("operator")
			s.Operator.Encode(e)
		}
	}
	{
		if s.Key.Set {
			e.FieldStart("key")
			s.Key.Encode(e)
		}
	}
	{
		if s.Value.Set {
			e.FieldStart("value")
			s.Value.Encode(e)
		}
	}
}

var jsonFieldsNameOfDatasetItemFilter = [4]string{
	0: "field",
	1: "operator",
	2: "key",
	3: "value",
}

// Decode decodes DatasetItemFilter from json.
func (s *DatasetItemFilter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatasetItemFilter to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "field":
			if err := func() error {
				s.Field.Reset()
				if err := s.Field.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"field\"")
			}
		case "operator":
			if err := func() error {
				s.Operator.Reset()
				if err := s.Operator.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operator\"")
			}
		case "key":
			if err := func() error {
				s.Key.Reset()
				if err := s.Key.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatasetItemFilter")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatasetItemFilter) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatasetItemFilter) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatasetItemFilterOperator as json.
func (s DatasetItemFilterOperator) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DatasetItemFilterOperator from json.
func (s *DatasetItemFilterOperator) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatasetItemFilterOperator to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DatasetItemFilterOperator(v) {
	case DatasetItemFilterOperator_0:
		*s = DatasetItemFilterOperator_0
	case DatasetItemFilterOperator_1:
		*s = DatasetItemFilterOperator_1
	case DatasetItemFilterOperator_2:
		*s = DatasetItemFilterOperator_2
	case DatasetItemFilterOperator_3:
		*s = DatasetItemFilterOperator_3
	case DatasetItemFilterOperator_4:
		*s = DatasetItemFilterOperator_4
	case DatasetItemFilterOperator_5:
		*s = DatasetItemFilterOperator_5
	case DatasetItemFilterOperator_6:
		*s = DatasetItemFilterOperator_6
	case DatasetItemFilterOperator_7:
		*s = DatasetItemFilterOperator_7
	case DatasetItemFilterOperator_8:
		*s = DatasetItemFilterOperator_8
	case DatasetItemFilterOperator_9:
		*s = DatasetItemFilterOperator_9
	case DatasetItemFilterOperator_10:
		*s = DatasetItemFilterOperator_10
	case DatasetItemFilterOperator_11:
		*s = DatasetItemFilterOperator_11
	default:
		*s = DatasetItemFilterOperator(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DatasetItemFilterOperator) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatasetItemFilterOperator) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatasetItemPageCompare) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatasetItemPageCompare) encodeFields(e *jx.Encoder) {
	{
		if s.Content != nil {
			e.FieldStart("content")
			e.ArrStart()
			for _, elem := range s.Content {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Page.Set {
			e.FieldStart("page")
			s.Page.Encode(e)
		}
	}
	{
		if s.Size.Set {
			e.FieldStart("size")
			s.Size.Encode(e)
		}
	}
	{
		if s.Total.Set {
			e.FieldStart("total")
			s.Total.Encode(e)
		}
	}
	{
		if s.Columns != nil {
			e.FieldStart("columns")
			e.ArrStart()
			for _, elem := range s.Columns {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.SortableBy != nil {
			e.FieldStart("sortableBy")
			e.ArrStart()
			for _, elem := range s.SortableBy {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.HasDraft.Set {
			e.FieldStart("hasDraft")
			s.HasDraft.Encode(e)
		}
	}
}

var jsonFieldsNameOfDatasetItemPageCompare = [7]string{
	0: "content",
	1: "page",
	2: "size",
	3: "total",
	4: "columns",
	5: "sortableBy",
	6: "hasDraft",
}

// Decode decodes DatasetItemPageCompare from json.
func (s *DatasetItemPageCompare) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatasetItemPageCompare to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "content":
			if err := func() error {
				s.Content = make([]DatasetItemCompare, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DatasetItemCompare
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Content = append(s.Content, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		case "page":
			if err := func() error {
				s.Page.Reset()
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "size":
			if err := func() error {
				s.Size.Reset()
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "total":
			if err := func() error {
				s.Total.Reset()
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "columns":
			if err := func() error {
				s.Columns = make([]ColumnCompare, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ColumnCompare
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Columns = append(s.Columns, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"columns\"")
			}
		case "sortableBy":
			if err := func() error {
				s.SortableBy = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.SortableBy = append(s.SortableBy, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sortableBy\"")
			}
		case "hasDraft":
			if err := func() error {
				s.HasDraft.Reset()
				if err := s.HasDraft.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hasDraft\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatasetItemPageCompare")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatasetItemPageCompare) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatasetItemPageCompare) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatasetItemPagePublic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatasetItemPagePublic) encodeFields(e *jx.Encoder) {
	{
		if s.Content != nil {
			e.FieldStart("content")
			e.ArrStart()
			for _, elem := range s.Content {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Page.Set {
			e.FieldStart("page")
			s.Page.Encode(e)
		}
	}
	{
		if s.Size.Set {
			e.FieldStart("size")
			s.Size.Encode(e)
		}
	}
	{
		if s.Total.Set {
			e.FieldStart("total")
			s.Total.Encode(e)
		}
	}
	{
		if s.Columns != nil {
			e.FieldStart("columns")
			e.ArrStart()
			for _, elem := range s.Columns {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.SortableBy != nil {
			e.FieldStart("sortableBy")
			e.ArrStart()
			for _, elem := range s.SortableBy {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.HasDraft.Set {
			e.FieldStart("hasDraft")
			s.HasDraft.Encode(e)
		}
	}
}

var jsonFieldsNameOfDatasetItemPagePublic = [7]string{
	0: "content",
	1: "page",
	2: "size",
	3: "total",
	4: "columns",
	5: "sortableBy",
	6: "hasDraft",
}

// Decode decodes DatasetItemPagePublic from json.
func (s *DatasetItemPagePublic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatasetItemPagePublic to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "content":
			if err := func() error {
				s.Content = make([]DatasetItemPublic, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DatasetItemPublic
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Content = append(s.Content, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		case "page":
			if err := func() error {
				s.Page.Reset()
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "size":
			if err := func() error {
				s.Size.Reset()
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "total":
			if err := func() error {
				s.Total.Reset()
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "columns":
			if err := func() error {
				s.Columns = make([]ColumnPublic, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ColumnPublic
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Columns = append(s.Columns, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"columns\"")
			}
		case "sortableBy":
			if err := func() error {
				s.SortableBy = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.SortableBy = append(s.SortableBy, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sortableBy\"")
			}
		case "hasDraft":
			if err := func() error {
				s.HasDraft.Reset()
				if err := s.HasDraft.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hasDraft\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatasetItemPagePublic")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatasetItemPagePublic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatasetItemPagePublic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatasetItemPublic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatasetItemPublic) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.DraftItemID.Set {
			e.FieldStart("draft_item_id")
			s.DraftItemID.Encode(e)
		}
	}
	{
		if s.TraceID.Set {
			e.FieldStart("trace_id")
			s.TraceID.Encode(e)
		}
	}
	{
		if s.SpanID.Set {
			e.FieldStart("span_id")
			s.SpanID.Encode(e)
		}
	}
	{
		e.FieldStart("source")
		s.Source.Encode(e)
	}
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
	{
		if s.Tags != nil {
			e.FieldStart("tags")
			e.ArrStart()
			for _, elem := range s.Tags {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ExperimentItems != nil {
			e.FieldStart("experiment_items")
			e.ArrStart()
			for _, elem := range s.ExperimentItems {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.DatasetID.Set {
			e.FieldStart("dataset_id")
			s.DatasetID.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.LastUpdatedAt.Set {
			e.FieldStart("last_updated_at")
			s.LastUpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.CreatedBy.Set {
			e.FieldStart("created_by")
			s.CreatedBy.Encode(e)
		}
	}
	{
		if s.LastUpdatedBy.Set {
			e.FieldStart("last_updated_by")
			s.LastUpdatedBy.Encode(e)
		}
	}
}

var jsonFieldsNameOfDatasetItemPublic = [13]string{
	0:  "id",
	1:  "draft_item_id",
	2:  "trace_id",
	3:  "span_id",
	4:  "source",
	5:  "data",
	6:  "tags",
	7:  "experiment_items",
	8:  "dataset_id",
	9:  "created_at",
	10: "last_updated_at",
	11: "created_by",
	12: "last_updated_by",
}

// Decode decodes DatasetItemPublic from json.
func (s *DatasetItemPublic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatasetItemPublic to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "draft_item_id":
			if err := func() error {
				s.DraftItemID.Reset()
				if err := s.DraftItemID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"draft_item_id\"")
			}
		case "trace_id":
			if err := func() error {
				s.TraceID.Reset()
				if err := s.TraceID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trace_id\"")
			}
		case "span_id":
			if err := func() error {
				s.SpanID.Reset()
				if err := s.SpanID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"span_id\"")
			}
		case "source":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Source.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		case "data":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "tags":
			if err := func() error {
				s.Tags = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Tags = append(s.Tags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		case "experiment_items":
			if err := func() error {
				s.ExperimentItems = make([]ExperimentItemPublic, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ExperimentItemPublic
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ExperimentItems = append(s.ExperimentItems, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"experiment_items\"")
			}
		case "dataset_id":
			if err := func() error {
				s.DatasetID.Reset()
				if err := s.DatasetID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dataset_id\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "last_updated_at":
			if err := func() error {
				s.LastUpdatedAt.Reset()
				if err := s.LastUpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated_at\"")
			}
		case "created_by":
			if err := func() error {
				s.CreatedBy.Reset()
				if err := s.CreatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_by\"")
			}
		case "last_updated_by":
			if err := func() error {
				s.LastUpdatedBy.Reset()
				if err := s.LastUpdatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated_by\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatasetItemPublic")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00110000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDatasetItemPublic) {
					name = jsonFieldsNameOfDatasetItemPublic[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatasetItemPublic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatasetItemPublic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatasetItemPublicSource as json.
func (s DatasetItemPublicSource) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DatasetItemPublicSource from json.
func (s *DatasetItemPublicSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatasetItemPublicSource to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DatasetItemPublicSource(v) {
	case DatasetItemPublicSourceManual:
		*s = DatasetItemPublicSourceManual
	case DatasetItemPublicSourceTrace:
		*s = DatasetItemPublicSourceTrace
	case DatasetItemPublicSourceSpan:
		*s = DatasetItemPublicSourceSpan
	case DatasetItemPublicSourceSdk:
		*s = DatasetItemPublicSourceSdk
	default:
		*s = DatasetItemPublicSource(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DatasetItemPublicSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatasetItemPublicSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatasetItemSource as json.
func (s DatasetItemSource) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DatasetItemSource from json.
func (s *DatasetItemSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatasetItemSource to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DatasetItemSource(v) {
	case DatasetItemSourceManual:
		*s = DatasetItemSourceManual
	case DatasetItemSourceTrace:
		*s = DatasetItemSourceTrace
	case DatasetItemSourceSpan:
		*s = DatasetItemSourceSpan
	case DatasetItemSourceSdk:
		*s = DatasetItemSourceSdk
	default:
		*s = DatasetItemSource(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DatasetItemSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatasetItemSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatasetItemUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatasetItemUpdate) encodeFields(e *jx.Encoder) {
	{
		if s.Input.Set {
			e.FieldStart("input")
			s.Input.Encode(e)
		}
	}
	{
		if s.ExpectedOutput.Set {
			e.FieldStart("expected_output")
			s.ExpectedOutput.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
	{
		if s.Tags != nil {
			e.FieldStart("tags")
			e.ArrStart()
			for _, elem := range s.Tags {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfDatasetItemUpdate = [5]string{
	0: "input",
	1: "expected_output",
	2: "metadata",
	3: "data",
	4: "tags",
}

// Decode decodes DatasetItemUpdate from json.
func (s *DatasetItemUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatasetItemUpdate to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "input":
			if err := func() error {
				s.Input.Reset()
				if err := s.Input.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"input\"")
			}
		case "expected_output":
			if err := func() error {
				s.ExpectedOutput.Reset()
				if err := s.ExpectedOutput.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expected_output\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "tags":
			if err := func() error {
				s.Tags = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Tags = append(s.Tags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatasetItemUpdate")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatasetItemUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatasetItemUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatasetItemWrite) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatasetItemWrite) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.TraceID.Set {
			e.FieldStart("trace_id")
			s.TraceID.Encode(e)
		}
	}
	{
		if s.SpanID.Set {
			e.FieldStart("span_id")
			s.SpanID.Encode(e)
		}
	}
	{
		e.FieldStart("source")
		s.Source.Encode(e)
	}
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
	{
		if s.Tags != nil {
			e.FieldStart("tags")
			e.ArrStart()
			for _, elem := range s.Tags {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfDatasetItemWrite = [6]string{
	0: "id",
	1: "trace_id",
	2: "span_id",
	3: "source",
	4: "data",
	5: "tags",
}

// Decode decodes DatasetItemWrite from json.
func (s *DatasetItemWrite) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatasetItemWrite to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "trace_id":
			if err := func() error {
				s.TraceID.Reset()
				if err := s.TraceID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trace_id\"")
			}
		case "span_id":
			if err := func() error {
				s.SpanID.Reset()
				if err := s.SpanID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"span_id\"")
			}
		case "source":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Source.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		case "data":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "tags":
			if err := func() error {
				s.Tags = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Tags = append(s.Tags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatasetItemWrite")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDatasetItemWrite) {
					name = jsonFieldsNameOfDatasetItemWrite[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatasetItemWrite) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatasetItemWrite) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatasetItemWriteSource as json.
func (s DatasetItemWriteSource) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DatasetItemWriteSource from json.
func (s *DatasetItemWriteSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatasetItemWriteSource to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DatasetItemWriteSource(v) {
	case DatasetItemWriteSourceManual:
		*s = DatasetItemWriteSourceManual
	case DatasetItemWriteSourceTrace:
		*s = DatasetItemWriteSourceTrace
	case DatasetItemWriteSourceSpan:
		*s = DatasetItemWriteSourceSpan
	case DatasetItemWriteSourceSdk:
		*s = DatasetItemWriteSourceSdk
	default:
		*s = DatasetItemWriteSource(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DatasetItemWriteSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatasetItemWriteSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatasetItemsDelete) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatasetItemsDelete) encodeFields(e *jx.Encoder) {
	{
		if s.ItemIds != nil {
			e.FieldStart("item_ids")
			e.ArrStart()
			for _, elem := range s.ItemIds {
				json.EncodeUUID(e, elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.DatasetID.Set {
			e.FieldStart("dataset_id")
			s.DatasetID.Encode(e)
		}
	}
	{
		if s.Filters != nil {
			e.FieldStart("filters")
			e.ArrStart()
			for _, elem := range s.Filters {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfDatasetItemsDelete = [3]string{
	0: "item_ids",
	1: "dataset_id",
	2: "filters",
}

// Decode decodes DatasetItemsDelete from json.
func (s *DatasetItemsDelete) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatasetItemsDelete to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "item_ids":
			if err := func() error {
				s.ItemIds = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.ItemIds = append(s.ItemIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"item_ids\"")
			}
		case "dataset_id":
			if err := func() error {
				s.DatasetID.Reset()
				if err := s.DatasetID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dataset_id\"")
			}
		case "filters":
			if err := func() error {
				s.Filters = make([]DatasetItemFilter, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DatasetItemFilter
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Filters = append(s.Filters, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"filters\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatasetItemsDelete")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatasetItemsDelete) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatasetItemsDelete) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatasetPagePublic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatasetPagePublic) encodeFields(e *jx.Encoder) {
	{
		if s.Content != nil {
			e.FieldStart("content")
			e.ArrStart()
			for _, elem := range s.Content {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Page.Set {
			e.FieldStart("page")
			s.Page.Encode(e)
		}
	}
	{
		if s.Size.Set {
			e.FieldStart("size")
			s.Size.Encode(e)
		}
	}
	{
		if s.Total.Set {
			e.FieldStart("total")
			s.Total.Encode(e)
		}
	}
	{
		if s.SortableBy != nil {
			e.FieldStart("sortableBy")
			e.ArrStart()
			for _, elem := range s.SortableBy {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfDatasetPagePublic = [5]string{
	0: "content",
	1: "page",
	2: "size",
	3: "total",
	4: "sortableBy",
}

// Decode decodes DatasetPagePublic from json.
func (s *DatasetPagePublic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatasetPagePublic to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "content":
			if err := func() error {
				s.Content = make([]DatasetPublic, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DatasetPublic
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Content = append(s.Content, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		case "page":
			if err := func() error {
				s.Page.Reset()
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "size":
			if err := func() error {
				s.Size.Reset()
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "total":
			if err := func() error {
				s.Total.Reset()
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "sortableBy":
			if err := func() error {
				s.SortableBy = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.SortableBy = append(s.SortableBy, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sortableBy\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatasetPagePublic")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatasetPagePublic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatasetPagePublic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatasetPublic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatasetPublic) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Visibility.Set {
			e.FieldStart("visibility")
			s.Visibility.Encode(e)
		}
	}
	{
		if s.Tags != nil {
			e.FieldStart("tags")
			e.ArrStart()
			for _, elem := range s.Tags {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.CreatedBy.Set {
			e.FieldStart("created_by")
			s.CreatedBy.Encode(e)
		}
	}
	{
		if s.LastUpdatedAt.Set {
			e.FieldStart("last_updated_at")
			s.LastUpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.LastUpdatedBy.Set {
			e.FieldStart("last_updated_by")
			s.LastUpdatedBy.Encode(e)
		}
	}
	{
		if s.ExperimentCount.Set {
			e.FieldStart("experiment_count")
			s.ExperimentCount.Encode(e)
		}
	}
	{
		if s.DatasetItemsCount.Set {
			e.FieldStart("dataset_items_count")
			s.DatasetItemsCount.Encode(e)
		}
	}
	{
		if s.OptimizationCount.Set {
			e.FieldStart("optimization_count")
			s.OptimizationCount.Encode(e)
		}
	}
	{
		if s.MostRecentExperimentAt.Set {
			e.FieldStart("most_recent_experiment_at")
			s.MostRecentExperimentAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.LastCreatedExperimentAt.Set {
			e.FieldStart("last_created_experiment_at")
			s.LastCreatedExperimentAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.MostRecentOptimizationAt.Set {
			e.FieldStart("most_recent_optimization_at")
			s.MostRecentOptimizationAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.LastCreatedOptimizationAt.Set {
			e.FieldStart("last_created_optimization_at")
			s.LastCreatedOptimizationAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.LatestVersion.Set {
			e.FieldStart("latest_version")
			s.LatestVersion.Encode(e)
		}
	}
}

var jsonFieldsNameOfDatasetPublic = [18]string{
	0:  "id",
	1:  "name",
	2:  "visibility",
	3:  "tags",
	4:  "description",
	5:  "created_at",
	6:  "created_by",
	7:  "last_updated_at",
	8:  "last_updated_by",
	9:  "experiment_count",
	10: "dataset_items_count",
	11: "optimization_count",
	12: "most_recent_experiment_at",
	13: "last_created_experiment_at",
	14: "most_recent_optimization_at",
	15: "last_created_optimization_at",
	16: "status",
	17: "latest_version",
}

// Decode decodes DatasetPublic from json.
func (s *DatasetPublic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatasetPublic to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "visibility":
			if err := func() error {
				s.Visibility.Reset()
				if err := s.Visibility.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"visibility\"")
			}
		case "tags":
			if err := func() error {
				s.Tags = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Tags = append(s.Tags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "created_by":
			if err := func() error {
				s.CreatedBy.Reset()
				if err := s.CreatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_by\"")
			}
		case "last_updated_at":
			if err := func() error {
				s.LastUpdatedAt.Reset()
				if err := s.LastUpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated_at\"")
			}
		case "last_updated_by":
			if err := func() error {
				s.LastUpdatedBy.Reset()
				if err := s.LastUpdatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated_by\"")
			}
		case "experiment_count":
			if err := func() error {
				s.ExperimentCount.Reset()
				if err := s.ExperimentCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"experiment_count\"")
			}
		case "dataset_items_count":
			if err := func() error {
				s.DatasetItemsCount.Reset()
				if err := s.DatasetItemsCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dataset_items_count\"")
			}
		case "optimization_count":
			if err := func() error {
				s.OptimizationCount.Reset()
				if err := s.OptimizationCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"optimization_count\"")
			}
		case "most_recent_experiment_at":
			if err := func() error {
				s.MostRecentExperimentAt.Reset()
				if err := s.MostRecentExperimentAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"most_recent_experiment_at\"")
			}
		case "last_created_experiment_at":
			if err := func() error {
				s.LastCreatedExperimentAt.Reset()
				if err := s.LastCreatedExperimentAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_created_experiment_at\"")
			}
		case "most_recent_optimization_at":
			if err := func() error {
				s.MostRecentOptimizationAt.Reset()
				if err := s.MostRecentOptimizationAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"most_recent_optimization_at\"")
			}
		case "last_created_optimization_at":
			if err := func() error {
				s.LastCreatedOptimizationAt.Reset()
				if err := s.LastCreatedOptimizationAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_created_optimization_at\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "latest_version":
			if err := func() error {
				s.LatestVersion.Reset()
				if err := s.LatestVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"latest_version\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatasetPublic")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b00000010,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDatasetPublic) {
					name = jsonFieldsNameOfDatasetPublic[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatasetPublic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatasetPublic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatasetPublicStatus as json.
func (s DatasetPublicStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DatasetPublicStatus from json.
func (s *DatasetPublicStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatasetPublicStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DatasetPublicStatus(v) {
	case DatasetPublicStatusUnknown:
		*s = DatasetPublicStatusUnknown
	case DatasetPublicStatusProcessing:
		*s = DatasetPublicStatusProcessing
	case DatasetPublicStatusCompleted:
		*s = DatasetPublicStatusCompleted
	case DatasetPublicStatusFailed:
		*s = DatasetPublicStatusFailed
	default:
		*s = DatasetPublicStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DatasetPublicStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatasetPublicStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatasetPublicVisibility as json.
func (s DatasetPublicVisibility) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DatasetPublicVisibility from json.
func (s *DatasetPublicVisibility) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatasetPublicVisibility to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DatasetPublicVisibility(v) {
	case DatasetPublicVisibilityPrivate:
		*s = DatasetPublicVisibilityPrivate
	case DatasetPublicVisibilityPublic:
		*s = DatasetPublicVisibilityPublic
	default:
		*s = DatasetPublicVisibility(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DatasetPublicVisibility) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatasetPublicVisibility) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatasetUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatasetUpdate) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Visibility.Set {
			e.FieldStart("visibility")
			s.Visibility.Encode(e)
		}
	}
	{
		if s.Tags != nil {
			e.FieldStart("tags")
			e.ArrStart()
			for _, elem := range s.Tags {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfDatasetUpdate = [4]string{
	0: "name",
	1: "description",
	2: "visibility",
	3: "tags",
}

// Decode decodes DatasetUpdate from json.
func (s *DatasetUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatasetUpdate to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "visibility":
			if err := func() error {
				s.Visibility.Reset()
				if err := s.Visibility.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"visibility\"")
			}
		case "tags":
			if err := func() error {
				s.Tags = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Tags = append(s.Tags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatasetUpdate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDatasetUpdate) {
					name = jsonFieldsNameOfDatasetUpdate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatasetUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatasetUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatasetUpdateVisibility as json.
func (s DatasetUpdateVisibility) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DatasetUpdateVisibility from json.
func (s *DatasetUpdateVisibility) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatasetUpdateVisibility to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DatasetUpdateVisibility(v) {
	case DatasetUpdateVisibilityPrivate:
		*s = DatasetUpdateVisibilityPrivate
	case DatasetUpdateVisibilityPublic:
		*s = DatasetUpdateVisibilityPublic
	default:
		*s = DatasetUpdateVisibility(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DatasetUpdateVisibility) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatasetUpdateVisibility) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatasetVersionCreatePublic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatasetVersionCreatePublic) encodeFields(e *jx.Encoder) {
	{
		if s.Tags != nil {
			e.FieldStart("tags")
			e.ArrStart()
			for _, elem := range s.Tags {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ChangeDescription.Set {
			e.FieldStart("change_description")
			s.ChangeDescription.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfDatasetVersionCreatePublic = [3]string{
	0: "tags",
	1: "change_description",
	2: "metadata",
}

// Decode decodes DatasetVersionCreatePublic from json.
func (s *DatasetVersionCreatePublic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatasetVersionCreatePublic to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "tags":
			if err := func() error {
				s.Tags = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Tags = append(s.Tags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		case "change_description":
			if err := func() error {
				s.ChangeDescription.Reset()
				if err := s.ChangeDescription.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"change_description\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatasetVersionCreatePublic")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatasetVersionCreatePublic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatasetVersionCreatePublic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DatasetVersionCreatePublicMetadata) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DatasetVersionCreatePublicMetadata) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes DatasetVersionCreatePublicMetadata from json.
func (s *DatasetVersionCreatePublicMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatasetVersionCreatePublicMetadata to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatasetVersionCreatePublicMetadata")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DatasetVersionCreatePublicMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatasetVersionCreatePublicMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatasetVersionDiff) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatasetVersionDiff) encodeFields(e *jx.Encoder) {
	{
		if s.FromVersion.Set {
			e.FieldStart("from_version")
			s.FromVersion.Encode(e)
		}
	}
	{
		if s.ToVersion.Set {
			e.FieldStart("to_version")
			s.ToVersion.Encode(e)
		}
	}
	{
		if s.Statistics.Set {
			e.FieldStart("statistics")
			s.Statistics.Encode(e)
		}
	}
}

var jsonFieldsNameOfDatasetVersionDiff = [3]string{
	0: "from_version",
	1: "to_version",
	2: "statistics",
}

// Decode decodes DatasetVersionDiff from json.
func (s *DatasetVersionDiff) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatasetVersionDiff to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "from_version":
			if err := func() error {
				s.FromVersion.Reset()
				if err := s.FromVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"from_version\"")
			}
		case "to_version":
			if err := func() error {
				s.ToVersion.Reset()
				if err := s.ToVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"to_version\"")
			}
		case "statistics":
			if err := func() error {
				s.Statistics.Reset()
				if err := s.Statistics.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statistics\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatasetVersionDiff")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatasetVersionDiff) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatasetVersionDiff) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatasetVersionDiffStats) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatasetVersionDiffStats) encodeFields(e *jx.Encoder) {
	{
		if s.ItemsAdded.Set {
			e.FieldStart("itemsAdded")
			s.ItemsAdded.Encode(e)
		}
	}
	{
		if s.ItemsModified.Set {
			e.FieldStart("itemsModified")
			s.ItemsModified.Encode(e)
		}
	}
	{
		if s.ItemsDeleted.Set {
			e.FieldStart("itemsDeleted")
			s.ItemsDeleted.Encode(e)
		}
	}
	{
		if s.ItemsUnchanged.Set {
			e.FieldStart("itemsUnchanged")
			s.ItemsUnchanged.Encode(e)
		}
	}
}

var jsonFieldsNameOfDatasetVersionDiffStats = [4]string{
	0: "itemsAdded",
	1: "itemsModified",
	2: "itemsDeleted",
	3: "itemsUnchanged",
}

// Decode decodes DatasetVersionDiffStats from json.
func (s *DatasetVersionDiffStats) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatasetVersionDiffStats to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "itemsAdded":
			if err := func() error {
				s.ItemsAdded.Reset()
				if err := s.ItemsAdded.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"itemsAdded\"")
			}
		case "itemsModified":
			if err := func() error {
				s.ItemsModified.Reset()
				if err := s.ItemsModified.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"itemsModified\"")
			}
		case "itemsDeleted":
			if err := func() error {
				s.ItemsDeleted.Reset()
				if err := s.ItemsDeleted.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"itemsDeleted\"")
			}
		case "itemsUnchanged":
			if err := func() error {
				s.ItemsUnchanged.Reset()
				if err := s.ItemsUnchanged.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"itemsUnchanged\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatasetVersionDiffStats")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatasetVersionDiffStats) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatasetVersionDiffStats) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatasetVersionPagePublic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatasetVersionPagePublic) encodeFields(e *jx.Encoder) {
	{
		if s.Content != nil {
			e.FieldStart("content")
			e.ArrStart()
			for _, elem := range s.Content {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Page.Set {
			e.FieldStart("page")
			s.Page.Encode(e)
		}
	}
	{
		if s.Size.Set {
			e.FieldStart("size")
			s.Size.Encode(e)
		}
	}
	{
		if s.Total.Set {
			e.FieldStart("total")
			s.Total.Encode(e)
		}
	}
}

var jsonFieldsNameOfDatasetVersionPagePublic = [4]string{
	0: "content",
	1: "page",
	2: "size",
	3: "total",
}

// Decode decodes DatasetVersionPagePublic from json.
func (s *DatasetVersionPagePublic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatasetVersionPagePublic to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "content":
			if err := func() error {
				s.Content = make([]DatasetVersionPublic, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DatasetVersionPublic
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Content = append(s.Content, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		case "page":
			if err := func() error {
				s.Page.Reset()
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "size":
			if err := func() error {
				s.Size.Reset()
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "total":
			if err := func() error {
				s.Total.Reset()
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatasetVersionPagePublic")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatasetVersionPagePublic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatasetVersionPagePublic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatasetVersionPublic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatasetVersionPublic) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.DatasetID.Set {
			e.FieldStart("dataset_id")
			s.DatasetID.Encode(e)
		}
	}
	{
		if s.VersionHash.Set {
			e.FieldStart("version_hash")
			s.VersionHash.Encode(e)
		}
	}
	{
		if s.Tags != nil {
			e.FieldStart("tags")
			e.ArrStart()
			for _, elem := range s.Tags {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.IsLatest.Set {
			e.FieldStart("is_latest")
			s.IsLatest.Encode(e)
		}
	}
	{
		if s.ItemsTotal.Set {
			e.FieldStart("items_total")
			s.ItemsTotal.Encode(e)
		}
	}
	{
		if s.ItemsAdded.Set {
			e.FieldStart("items_added")
			s.ItemsAdded.Encode(e)
		}
	}
	{
		if s.ItemsModified.Set {
			e.FieldStart("items_modified")
			s.ItemsModified.Encode(e)
		}
	}
	{
		if s.ItemsDeleted.Set {
			e.FieldStart("items_deleted")
			s.ItemsDeleted.Encode(e)
		}
	}
	{
		if s.ChangeDescription.Set {
			e.FieldStart("change_description")
			s.ChangeDescription.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.CreatedBy.Set {
			e.FieldStart("created_by")
			s.CreatedBy.Encode(e)
		}
	}
	{
		if s.LastUpdatedAt.Set {
			e.FieldStart("last_updated_at")
			s.LastUpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.LastUpdatedBy.Set {
			e.FieldStart("last_updated_by")
			s.LastUpdatedBy.Encode(e)
		}
	}
}

var jsonFieldsNameOfDatasetVersionPublic = [15]string{
	0:  "id",
	1:  "dataset_id",
	2:  "version_hash",
	3:  "tags",
	4:  "is_latest",
	5:  "items_total",
	6:  "items_added",
	7:  "items_modified",
	8:  "items_deleted",
	9:  "change_description",
	10: "metadata",
	11: "created_at",
	12: "created_by",
	13: "last_updated_at",
	14: "last_updated_by",
}

// Decode decodes DatasetVersionPublic from json.
func (s *DatasetVersionPublic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatasetVersionPublic to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "dataset_id":
			if err := func() error {
				s.DatasetID.Reset()
				if err := s.DatasetID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dataset_id\"")
			}
		case "version_hash":
			if err := func() error {
				s.VersionHash.Reset()
				if err := s.VersionHash.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version_hash\"")
			}
		case "tags":
			if err := func() error {
				s.Tags = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Tags = append(s.Tags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		case "is_latest":
			if err := func() error {
				s.IsLatest.Reset()
				if err := s.IsLatest.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_latest\"")
			}
		case "items_total":
			if err := func() error {
				s.ItemsTotal.Reset()
				if err := s.ItemsTotal.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items_total\"")
			}
		case "items_added":
			if err := func() error {
				s.ItemsAdded.Reset()
				if err := s.ItemsAdded.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items_added\"")
			}
		case "items_modified":
			if err := func() error {
				s.ItemsModified.Reset()
				if err := s.ItemsModified.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items_modified\"")
			}
		case "items_deleted":
			if err := func() error {
				s.ItemsDeleted.Reset()
				if err := s.ItemsDeleted.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items_deleted\"")
			}
		case "change_description":
			if err := func() error {
				s.ChangeDescription.Reset()
				if err := s.ChangeDescription.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"change_description\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "created_by":
			if err := func() error {
				s.CreatedBy.Reset()
				if err := s.CreatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_by\"")
			}
		case "last_updated_at":
			if err := func() error {
				s.LastUpdatedAt.Reset()
				if err := s.LastUpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated_at\"")
			}
		case "last_updated_by":
			if err := func() error {
				s.LastUpdatedBy.Reset()
				if err := s.LastUpdatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated_by\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatasetVersionPublic")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatasetVersionPublic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatasetVersionPublic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DatasetVersionPublicMetadata) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DatasetVersionPublicMetadata) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes DatasetVersionPublicMetadata from json.
func (s *DatasetVersionPublicMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatasetVersionPublicMetadata to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatasetVersionPublicMetadata")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DatasetVersionPublicMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatasetVersionPublicMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatasetVersionRestorePublic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatasetVersionRestorePublic) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("version_ref")
		e.Str(s.VersionRef)
	}
}

var jsonFieldsNameOfDatasetVersionRestorePublic = [1]string{
	0: "version_ref",
}

// Decode decodes DatasetVersionRestorePublic from json.
func (s *DatasetVersionRestorePublic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatasetVersionRestorePublic to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "version_ref":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.VersionRef = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version_ref\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatasetVersionRestorePublic")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDatasetVersionRestorePublic) {
					name = jsonFieldsNameOfDatasetVersionRestorePublic[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatasetVersionRestorePublic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatasetVersionRestorePublic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatasetVersionSummaryPublic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatasetVersionSummaryPublic) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.VersionHash.Set {
			e.FieldStart("version_hash")
			s.VersionHash.Encode(e)
		}
	}
	{
		if s.ChangeDescription.Set {
			e.FieldStart("change_description")
			s.ChangeDescription.Encode(e)
		}
	}
	{
		if s.Tags != nil {
			e.FieldStart("tags")
			e.ArrStart()
			for _, elem := range s.Tags {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfDatasetVersionSummaryPublic = [4]string{
	0: "id",
	1: "version_hash",
	2: "change_description",
	3: "tags",
}

// Decode decodes DatasetVersionSummaryPublic from json.
func (s *DatasetVersionSummaryPublic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatasetVersionSummaryPublic to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "version_hash":
			if err := func() error {
				s.VersionHash.Reset()
				if err := s.VersionHash.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version_hash\"")
			}
		case "change_description":
			if err := func() error {
				s.ChangeDescription.Reset()
				if err := s.ChangeDescription.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"change_description\"")
			}
		case "tags":
			if err := func() error {
				s.Tags = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Tags = append(s.Tags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatasetVersionSummaryPublic")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatasetVersionSummaryPublic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatasetVersionSummaryPublic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatasetVersionTag) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatasetVersionTag) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("tag")
		e.Str(s.Tag)
	}
}

var jsonFieldsNameOfDatasetVersionTag = [1]string{
	0: "tag",
}

// Decode decodes DatasetVersionTag from json.
func (s *DatasetVersionTag) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatasetVersionTag to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "tag":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Tag = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatasetVersionTag")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDatasetVersionTag) {
					name = jsonFieldsNameOfDatasetVersionTag[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatasetVersionTag) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatasetVersionTag) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatasetVersionUpdatePublic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatasetVersionUpdatePublic) encodeFields(e *jx.Encoder) {
	{
		if s.ChangeDescription.Set {
			e.FieldStart("change_description")
			s.ChangeDescription.Encode(e)
		}
	}
	{
		if s.TagsToAdd != nil {
			e.FieldStart("tags_to_add")
			e.ArrStart()
			for _, elem := range s.TagsToAdd {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfDatasetVersionUpdatePublic = [2]string{
	0: "change_description",
	1: "tags_to_add",
}

// Decode decodes DatasetVersionUpdatePublic from json.
func (s *DatasetVersionUpdatePublic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatasetVersionUpdatePublic to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "change_description":
			if err := func() error {
				s.ChangeDescription.Reset()
				if err := s.ChangeDescription.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"change_description\"")
			}
		case "tags_to_add":
			if err := func() error {
				s.TagsToAdd = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.TagsToAdd = append(s.TagsToAdd, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags_to_add\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatasetVersionUpdatePublic")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatasetVersionUpdatePublic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatasetVersionUpdatePublic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DatasetWrite) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DatasetWrite) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Visibility.Set {
			e.FieldStart("visibility")
			s.Visibility.Encode(e)
		}
	}
	{
		if s.Tags != nil {
			e.FieldStart("tags")
			e.ArrStart()
			for _, elem := range s.Tags {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
}

var jsonFieldsNameOfDatasetWrite = [5]string{
	0: "id",
	1: "name",
	2: "visibility",
	3: "tags",
	4: "description",
}

// Decode decodes DatasetWrite from json.
func (s *DatasetWrite) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatasetWrite to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "visibility":
			if err := func() error {
				s.Visibility.Reset()
				if err := s.Visibility.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"visibility\"")
			}
		case "tags":
			if err := func() error {
				s.Tags = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Tags = append(s.Tags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DatasetWrite")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDatasetWrite) {
					name = jsonFieldsNameOfDatasetWrite[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DatasetWrite) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatasetWrite) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatasetWriteVisibility as json.
func (s DatasetWriteVisibility) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DatasetWriteVisibility from json.
func (s *DatasetWriteVisibility) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DatasetWriteVisibility to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DatasetWriteVisibility(v) {
	case DatasetWriteVisibilityPrivate:
		*s = DatasetWriteVisibilityPrivate
	case DatasetWriteVisibilityPublic:
		*s = DatasetWriteVisibilityPublic
	default:
		*s = DatasetWriteVisibility(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DatasetWriteVisibility) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DatasetWriteVisibility) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteAttachmentsForbidden as json.
func (s *DeleteAttachmentsForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessage)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteAttachmentsForbidden from json.
func (s *DeleteAttachmentsForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteAttachmentsForbidden to nil")
	}
	var unwrapped ErrorMessage
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteAttachmentsForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteAttachmentsForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteAttachmentsForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteAttachmentsUnauthorized as json.
func (s *DeleteAttachmentsUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessage)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteAttachmentsUnauthorized from json.
func (s *DeleteAttachmentsUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteAttachmentsUnauthorized to nil")
	}
	var unwrapped ErrorMessage
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteAttachmentsUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteAttachmentsUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteAttachmentsUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteFeedbackScore) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteFeedbackScore) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Author.Set {
			e.FieldStart("author")
			s.Author.Encode(e)
		}
	}
}

var jsonFieldsNameOfDeleteFeedbackScore = [2]string{
	0: "name",
	1: "author",
}

// Decode decodes DeleteFeedbackScore from json.
func (s *DeleteFeedbackScore) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteFeedbackScore to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "author":
			if err := func() error {
				s.Author.Reset()
				if err := s.Author.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"author\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteFeedbackScore")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteFeedbackScore) {
					name = jsonFieldsNameOfDeleteFeedbackScore[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteFeedbackScore) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteFeedbackScore) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteIdsHolder) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteIdsHolder) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("ids")
		e.ArrStart()
		for _, elem := range s.Ids {
			json.EncodeUUID(e, elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfDeleteIdsHolder = [1]string{
	0: "ids",
}

// Decode decodes DeleteIdsHolder from json.
func (s *DeleteIdsHolder) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteIdsHolder to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ids":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Ids = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.Ids = append(s.Ids, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ids\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteIdsHolder")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteIdsHolder) {
					name = jsonFieldsNameOfDeleteIdsHolder[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteIdsHolder) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteIdsHolder) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteThreadFeedbackScores) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteThreadFeedbackScores) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("project_name")
		e.Str(s.ProjectName)
	}
	{
		e.FieldStart("thread_id")
		e.Str(s.ThreadID)
	}
	{
		e.FieldStart("names")
		e.ArrStart()
		for _, elem := range s.Names {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		if s.Author.Set {
			e.FieldStart("author")
			s.Author.Encode(e)
		}
	}
}

var jsonFieldsNameOfDeleteThreadFeedbackScores = [4]string{
	0: "project_name",
	1: "thread_id",
	2: "names",
	3: "author",
}

// Decode decodes DeleteThreadFeedbackScores from json.
func (s *DeleteThreadFeedbackScores) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteThreadFeedbackScores to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "project_name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ProjectName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"project_name\"")
			}
		case "thread_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ThreadID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thread_id\"")
			}
		case "names":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Names = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Names = append(s.Names, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"names\"")
			}
		case "author":
			if err := func() error {
				s.Author.Reset()
				if err := s.Author.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"author\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteThreadFeedbackScores")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteThreadFeedbackScores) {
					name = jsonFieldsNameOfDeleteThreadFeedbackScores[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteThreadFeedbackScores) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteThreadFeedbackScores) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteTraceThreads) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteTraceThreads) encodeFields(e *jx.Encoder) {
	{
		if s.ProjectName.Set {
			e.FieldStart("project_name")
			s.ProjectName.Encode(e)
		}
	}
	{
		if s.ProjectID.Set {
			e.FieldStart("project_id")
			s.ProjectID.Encode(e)
		}
	}
	{
		e.FieldStart("thread_ids")
		e.ArrStart()
		for _, elem := range s.ThreadIds {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfDeleteTraceThreads = [3]string{
	0: "project_name",
	1: "project_id",
	2: "thread_ids",
}

// Decode decodes DeleteTraceThreads from json.
func (s *DeleteTraceThreads) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteTraceThreads to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "project_name":
			if err := func() error {
				s.ProjectName.Reset()
				if err := s.ProjectName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"project_name\"")
			}
		case "project_id":
			if err := func() error {
				s.ProjectID.Reset()
				if err := s.ProjectID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"project_id\"")
			}
		case "thread_ids":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.ThreadIds = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.ThreadIds = append(s.ThreadIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thread_ids\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteTraceThreads")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteTraceThreads) {
					name = jsonFieldsNameOfDeleteTraceThreads[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteTraceThreads) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteTraceThreads) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Delta) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Delta) encodeFields(e *jx.Encoder) {
	{
		if s.Role.Set {
			e.FieldStart("role")
			s.Role.Encode(e)
		}
	}
	{
		if s.Content.Set {
			e.FieldStart("content")
			s.Content.Encode(e)
		}
	}
	{
		if s.ReasoningContent.Set {
			e.FieldStart("reasoning_content")
			s.ReasoningContent.Encode(e)
		}
	}
	{
		if s.ToolCalls != nil {
			e.FieldStart("tool_calls")
			e.ArrStart()
			for _, elem := range s.ToolCalls {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.FunctionCall.Set {
			e.FieldStart("function_call")
			s.FunctionCall.Encode(e)
		}
	}
}

var jsonFieldsNameOfDelta = [5]string{
	0: "role",
	1: "content",
	2: "reasoning_content",
	3: "tool_calls",
	4: "function_call",
}

// Decode decodes Delta from json.
func (s *Delta) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Delta to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "role":
			if err := func() error {
				s.Role.Reset()
				if err := s.Role.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"role\"")
			}
		case "content":
			if err := func() error {
				s.Content.Reset()
				if err := s.Content.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		case "reasoning_content":
			if err := func() error {
				s.ReasoningContent.Reset()
				if err := s.ReasoningContent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reasoning_content\"")
			}
		case "tool_calls":
			if err := func() error {
				s.ToolCalls = make([]ToolCall, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ToolCall
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ToolCalls = append(s.ToolCalls, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tool_calls\"")
			}
		case "function_call":
			if err := func() error {
				s.FunctionCall.Reset()
				if err := s.FunctionCall.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"function_call\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Delta")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Delta) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Delta) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ErrorCountWithDeviation) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ErrorCountWithDeviation) encodeFields(e *jx.Encoder) {
	{
		if s.Count.Set {
			e.FieldStart("count")
			s.Count.Encode(e)
		}
	}
	{
		if s.Deviation.Set {
			e.FieldStart("deviation")
			s.Deviation.Encode(e)
		}
	}
	{
		if s.DeviationPercentage.Set {
			e.FieldStart("deviation_percentage")
			s.DeviationPercentage.Encode(e)
		}
	}
}

var jsonFieldsNameOfErrorCountWithDeviation = [3]string{
	0: "count",
	1: "deviation",
	2: "deviation_percentage",
}

// Decode decodes ErrorCountWithDeviation from json.
func (s *ErrorCountWithDeviation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ErrorCountWithDeviation to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "count":
			if err := func() error {
				s.Count.Reset()
				if err := s.Count.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"count\"")
			}
		case "deviation":
			if err := func() error {
				s.Deviation.Reset()
				if err := s.Deviation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deviation\"")
			}
		case "deviation_percentage":
			if err := func() error {
				s.DeviationPercentage.Reset()
				if err := s.DeviationPercentage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deviation_percentage\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ErrorCountWithDeviation")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ErrorCountWithDeviation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ErrorCountWithDeviation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ErrorCountWithDeviationDetailed) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ErrorCountWithDeviationDetailed) encodeFields(e *jx.Encoder) {
	{
		if s.Count.Set {
			e.FieldStart("count")
			s.Count.Encode(e)
		}
	}
	{
		if s.Deviation.Set {
			e.FieldStart("deviation")
			s.Deviation.Encode(e)
		}
	}
	{
		if s.DeviationPercentage.Set {
			e.FieldStart("deviation_percentage")
			s.DeviationPercentage.Encode(e)
		}
	}
}

var jsonFieldsNameOfErrorCountWithDeviationDetailed = [3]string{
	0: "count",
	1: "deviation",
	2: "deviation_percentage",
}

// Decode decodes ErrorCountWithDeviationDetailed from json.
func (s *ErrorCountWithDeviationDetailed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ErrorCountWithDeviationDetailed to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "count":
			if err := func() error {
				s.Count.Reset()
				if err := s.Count.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"count\"")
			}
		case "deviation":
			if err := func() error {
				s.Deviation.Reset()
				if err := s.Deviation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deviation\"")
			}
		case "deviation_percentage":
			if err := func() error {
				s.DeviationPercentage.Reset()
				if err := s.DeviationPercentage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deviation_percentage\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ErrorCountWithDeviationDetailed")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ErrorCountWithDeviationDetailed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ErrorCountWithDeviationDetailed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ErrorInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ErrorInfo) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("exception_type")
		e.Str(s.ExceptionType)
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		e.FieldStart("traceback")
		e.Str(s.Traceback)
	}
}

var jsonFieldsNameOfErrorInfo = [3]string{
	0: "exception_type",
	1: "message",
	2: "traceback",
}

// Decode decodes ErrorInfo from json.
func (s *ErrorInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ErrorInfo to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "exception_type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ExceptionType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exception_type\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "traceback":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Traceback = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"traceback\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ErrorInfo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfErrorInfo) {
					name = jsonFieldsNameOfErrorInfo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ErrorInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ErrorInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ErrorInfoExperimentItemBulkWriteView) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ErrorInfoExperimentItemBulkWriteView) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("exception_type")
		e.Str(s.ExceptionType)
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		e.FieldStart("traceback")
		e.Str(s.Traceback)
	}
}

var jsonFieldsNameOfErrorInfoExperimentItemBulkWriteView = [3]string{
	0: "exception_type",
	1: "message",
	2: "traceback",
}

// Decode decodes ErrorInfoExperimentItemBulkWriteView from json.
func (s *ErrorInfoExperimentItemBulkWriteView) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ErrorInfoExperimentItemBulkWriteView to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "exception_type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ExceptionType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exception_type\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "traceback":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Traceback = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"traceback\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ErrorInfoExperimentItemBulkWriteView")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfErrorInfoExperimentItemBulkWriteView) {
					name = jsonFieldsNameOfErrorInfoExperimentItemBulkWriteView[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ErrorInfoExperimentItemBulkWriteView) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ErrorInfoExperimentItemBulkWriteView) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ErrorInfoPublic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ErrorInfoPublic) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("exception_type")
		e.Str(s.ExceptionType)
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		e.FieldStart("traceback")
		e.Str(s.Traceback)
	}
}

var jsonFieldsNameOfErrorInfoPublic = [3]string{
	0: "exception_type",
	1: "message",
	2: "traceback",
}

// Decode decodes ErrorInfoPublic from json.
func (s *ErrorInfoPublic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ErrorInfoPublic to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "exception_type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ExceptionType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exception_type\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "traceback":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Traceback = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"traceback\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ErrorInfoPublic")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfErrorInfoPublic) {
					name = jsonFieldsNameOfErrorInfoPublic[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ErrorInfoPublic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ErrorInfoPublic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ErrorInfoWrite) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ErrorInfoWrite) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("exception_type")
		e.Str(s.ExceptionType)
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		e.FieldStart("traceback")
		e.Str(s.Traceback)
	}
}

var jsonFieldsNameOfErrorInfoWrite = [3]string{
	0: "exception_type",
	1: "message",
	2: "traceback",
}

// Decode decodes ErrorInfoWrite from json.
func (s *ErrorInfoWrite) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ErrorInfoWrite to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "exception_type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ExceptionType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exception_type\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "traceback":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Traceback = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"traceback\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ErrorInfoWrite")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfErrorInfoWrite) {
					name = jsonFieldsNameOfErrorInfoWrite[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ErrorInfoWrite) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ErrorInfoWrite) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ErrorMessage) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ErrorMessage) encodeFields(e *jx.Encoder) {
	{
		if s.Code.Set {
			e.FieldStart("code")
			s.Code.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.Details.Set {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfErrorMessage = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes ErrorMessage from json.
func (s *ErrorMessage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ErrorMessage to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			if err := func() error {
				s.Code.Reset()
				if err := s.Code.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details.Reset()
				if err := s.Details.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ErrorMessage")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ErrorMessage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ErrorMessage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ErrorMessageDetail) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ErrorMessageDetail) encodeFields(e *jx.Encoder) {
	{
		if s.Code.Set {
			e.FieldStart("code")
			s.Code.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.Details.Set {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfErrorMessageDetail = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes ErrorMessageDetail from json.
func (s *ErrorMessageDetail) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ErrorMessageDetail to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			if err := func() error {
				s.Code.Reset()
				if err := s.Code.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details.Reset()
				if err := s.Details.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ErrorMessageDetail")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ErrorMessageDetail) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ErrorMessageDetail) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ErrorMessageDetailed) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ErrorMessageDetailed) encodeFields(e *jx.Encoder) {
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfErrorMessageDetailed = [1]string{
	0: "errors",
}

// Decode decodes ErrorMessageDetailed from json.
func (s *ErrorMessageDetailed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ErrorMessageDetailed to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "errors":
			if err := func() error {
				s.Errors = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ErrorMessageDetailed")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ErrorMessageDetailed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ErrorMessageDetailed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ErrorMessagePublic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ErrorMessagePublic) encodeFields(e *jx.Encoder) {
	{
		if s.Code.Set {
			e.FieldStart("code")
			s.Code.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.Details.Set {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfErrorMessagePublic = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes ErrorMessagePublic from json.
func (s *ErrorMessagePublic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ErrorMessagePublic to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			if err := func() error {
				s.Code.Reset()
				if err := s.Code.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				s.Details.Reset()
				if err := s.Details.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ErrorMessagePublic")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ErrorMessagePublic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ErrorMessagePublic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EvaluateSpansBadRequest as json.
func (s *EvaluateSpansBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessage)(s)

	unwrapped.Encode(e)
}

// Decode decodes EvaluateSpansBadRequest from json.
func (s *EvaluateSpansBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EvaluateSpansBadRequest to nil")
	}
	var unwrapped ErrorMessage
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = EvaluateSpansBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EvaluateSpansBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EvaluateSpansBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EvaluateSpansNotFound as json.
func (s *EvaluateSpansNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessage)(s)

	unwrapped.Encode(e)
}

// Decode decodes EvaluateSpansNotFound from json.
func (s *EvaluateSpansNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EvaluateSpansNotFound to nil")
	}
	var unwrapped ErrorMessage
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = EvaluateSpansNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EvaluateSpansNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EvaluateSpansNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EvaluateThreadsBadRequest as json.
func (s *EvaluateThreadsBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessage)(s)

	unwrapped.Encode(e)
}

// Decode decodes EvaluateThreadsBadRequest from json.
func (s *EvaluateThreadsBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EvaluateThreadsBadRequest to nil")
	}
	var unwrapped ErrorMessage
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = EvaluateThreadsBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EvaluateThreadsBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EvaluateThreadsBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EvaluateThreadsNotFound as json.
func (s *EvaluateThreadsNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessage)(s)

	unwrapped.Encode(e)
}

// Decode decodes EvaluateThreadsNotFound from json.
func (s *EvaluateThreadsNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EvaluateThreadsNotFound to nil")
	}
	var unwrapped ErrorMessage
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = EvaluateThreadsNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EvaluateThreadsNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EvaluateThreadsNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EvaluateTracesBadRequest as json.
func (s *EvaluateTracesBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessage)(s)

	unwrapped.Encode(e)
}

// Decode decodes EvaluateTracesBadRequest from json.
func (s *EvaluateTracesBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EvaluateTracesBadRequest to nil")
	}
	var unwrapped ErrorMessage
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = EvaluateTracesBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EvaluateTracesBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EvaluateTracesBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EvaluateTracesNotFound as json.
func (s *EvaluateTracesNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessage)(s)

	unwrapped.Encode(e)
}

// Decode decodes EvaluateTracesNotFound from json.
func (s *EvaluateTracesNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EvaluateTracesNotFound to nil")
	}
	var unwrapped ErrorMessage
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = EvaluateTracesNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EvaluateTracesNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EvaluateTracesNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ExperimentGroupAggregationsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ExperimentGroupAggregationsResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Content.Set {
			e.FieldStart("content")
			s.Content.Encode(e)
		}
	}
}

var jsonFieldsNameOfExperimentGroupAggregationsResponse = [1]string{
	0: "content",
}

// Decode decodes ExperimentGroupAggregationsResponse from json.
func (s *ExperimentGroupAggregationsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExperimentGroupAggregationsResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "content":
			if err := func() error {
				s.Content.Reset()
				if err := s.Content.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ExperimentGroupAggregationsResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ExperimentGroupAggregationsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExperimentGroupAggregationsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ExperimentGroupAggregationsResponseContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s ExperimentGroupAggregationsResponseContent) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes ExperimentGroupAggregationsResponseContent from json.
func (s *ExperimentGroupAggregationsResponseContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExperimentGroupAggregationsResponseContent to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem GroupContentWithAggregations
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ExperimentGroupAggregationsResponseContent")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ExperimentGroupAggregationsResponseContent) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExperimentGroupAggregationsResponseContent) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ExperimentGroupResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ExperimentGroupResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Content.Set {
			e.FieldStart("content")
			s.Content.Encode(e)
		}
	}
	{
		if s.Details.Set {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
}

var jsonFieldsNameOfExperimentGroupResponse = [2]string{
	0: "content",
	1: "details",
}

// Decode decodes ExperimentGroupResponse from json.
func (s *ExperimentGroupResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExperimentGroupResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "content":
			if err := func() error {
				s.Content.Reset()
				if err := s.Content.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		case "details":
			if err := func() error {
				s.Details.Reset()
				if err := s.Details.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ExperimentGroupResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ExperimentGroupResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExperimentGroupResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ExperimentGroupResponseContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s ExperimentGroupResponseContent) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes ExperimentGroupResponseContent from json.
func (s *ExperimentGroupResponseContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExperimentGroupResponseContent to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem GroupContent
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ExperimentGroupResponseContent")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ExperimentGroupResponseContent) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExperimentGroupResponseContent) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ExperimentItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ExperimentItem) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		e.FieldStart("experiment_id")
		json.EncodeUUID(e, s.ExperimentID)
	}
	{
		e.FieldStart("dataset_item_id")
		json.EncodeUUID(e, s.DatasetItemID)
	}
	{
		e.FieldStart("trace_id")
		json.EncodeUUID(e, s.TraceID)
	}
	{
		e.FieldStart("input")
		s.Input.Encode(e)
	}
	{
		e.FieldStart("output")
		s.Output.Encode(e)
	}
	{
		if s.FeedbackScores != nil {
			e.FieldStart("feedback_scores")
			e.ArrStart()
			for _, elem := range s.FeedbackScores {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Comments != nil {
			e.FieldStart("comments")
			e.ArrStart()
			for _, elem := range s.Comments {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.TotalEstimatedCost.Set {
			e.FieldStart("total_estimated_cost")
			s.TotalEstimatedCost.Encode(e)
		}
	}
	{
		if s.Duration.Set {
			e.FieldStart("duration")
			s.Duration.Encode(e)
		}
	}
	{
		if s.Usage.Set {
			e.FieldStart("usage")
			s.Usage.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.LastUpdatedAt.Set {
			e.FieldStart("last_updated_at")
			s.LastUpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.CreatedBy.Set {
			e.FieldStart("created_by")
			s.CreatedBy.Encode(e)
		}
	}
	{
		if s.LastUpdatedBy.Set {
			e.FieldStart("last_updated_by")
			s.LastUpdatedBy.Encode(e)
		}
	}
	{
		if s.TraceVisibilityMode.Set {
			e.FieldStart("trace_visibility_mode")
			s.TraceVisibilityMode.Encode(e)
		}
	}
}

var jsonFieldsNameOfExperimentItem = [16]string{
	0:  "id",
	1:  "experiment_id",
	2:  "dataset_item_id",
	3:  "trace_id",
	4:  "input",
	5:  "output",
	6:  "feedback_scores",
	7:  "comments",
	8:  "total_estimated_cost",
	9:  "duration",
	10: "usage",
	11: "created_at",
	12: "last_updated_at",
	13: "created_by",
	14: "last_updated_by",
	15: "trace_visibility_mode",
}

// Decode decodes ExperimentItem from json.
func (s *ExperimentItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExperimentItem to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "experiment_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ExperimentID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"experiment_id\"")
			}
		case "dataset_item_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.DatasetItemID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dataset_item_id\"")
			}
		case "trace_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.TraceID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trace_id\"")
			}
		case "input":
			if err := func() error {
				if err := s.Input.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"input\"")
			}
		case "output":
			if err := func() error {
				if err := s.Output.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"output\"")
			}
		case "feedback_scores":
			if err := func() error {
				s.FeedbackScores = make([]FeedbackScore, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem FeedbackScore
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.FeedbackScores = append(s.FeedbackScores, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"feedback_scores\"")
			}
		case "comments":
			if err := func() error {
				s.Comments = make([]Comment, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Comment
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Comments = append(s.Comments, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comments\"")
			}
		case "total_estimated_cost":
			if err := func() error {
				s.TotalEstimatedCost.Reset()
				if err := s.TotalEstimatedCost.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_estimated_cost\"")
			}
		case "duration":
			if err := func() error {
				s.Duration.Reset()
				if err := s.Duration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration\"")
			}
		case "usage":
			if err := func() error {
				s.Usage.Reset()
				if err := s.Usage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usage\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "last_updated_at":
			if err := func() error {
				s.LastUpdatedAt.Reset()
				if err := s.LastUpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated_at\"")
			}
		case "created_by":
			if err := func() error {
				s.CreatedBy.Reset()
				if err := s.CreatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_by\"")
			}
		case "last_updated_by":
			if err := func() error {
				s.LastUpdatedBy.Reset()
				if err := s.LastUpdatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated_by\"")
			}
		case "trace_visibility_mode":
			if err := func() error {
				s.TraceVisibilityMode.Reset()
				if err := s.TraceVisibilityMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trace_visibility_mode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ExperimentItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00001110,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfExperimentItem) {
					name = jsonFieldsNameOfExperimentItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ExperimentItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExperimentItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ExperimentItemBulkRecordExperimentItemBulkWriteView) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ExperimentItemBulkRecordExperimentItemBulkWriteView) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("dataset_item_id")
		json.EncodeUUID(e, s.DatasetItemID)
	}
	{
		e.FieldStart("evaluate_task_result")
		s.EvaluateTaskResult.Encode(e)
	}
	{
		if s.Trace.Set {
			e.FieldStart("trace")
			s.Trace.Encode(e)
		}
	}
	{
		if s.Spans != nil {
			e.FieldStart("spans")
			e.ArrStart()
			for _, elem := range s.Spans {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.FeedbackScores != nil {
			e.FieldStart("feedback_scores")
			e.ArrStart()
			for _, elem := range s.FeedbackScores {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfExperimentItemBulkRecordExperimentItemBulkWriteView = [5]string{
	0: "dataset_item_id",
	1: "evaluate_task_result",
	2: "trace",
	3: "spans",
	4: "feedback_scores",
}

// Decode decodes ExperimentItemBulkRecordExperimentItemBulkWriteView from json.
func (s *ExperimentItemBulkRecordExperimentItemBulkWriteView) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExperimentItemBulkRecordExperimentItemBulkWriteView to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "dataset_item_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.DatasetItemID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dataset_item_id\"")
			}
		case "evaluate_task_result":
			if err := func() error {
				if err := s.EvaluateTaskResult.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"evaluate_task_result\"")
			}
		case "trace":
			if err := func() error {
				s.Trace.Reset()
				if err := s.Trace.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trace\"")
			}
		case "spans":
			if err := func() error {
				s.Spans = make([]SpanExperimentItemBulkWriteView, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SpanExperimentItemBulkWriteView
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Spans = append(s.Spans, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spans\"")
			}
		case "feedback_scores":
			if err := func() error {
				s.FeedbackScores = make([]FeedbackScoreExperimentItemBulkWriteView, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem FeedbackScoreExperimentItemBulkWriteView
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.FeedbackScores = append(s.FeedbackScores, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"feedback_scores\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ExperimentItemBulkRecordExperimentItemBulkWriteView")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfExperimentItemBulkRecordExperimentItemBulkWriteView) {
					name = jsonFieldsNameOfExperimentItemBulkRecordExperimentItemBulkWriteView[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ExperimentItemBulkRecordExperimentItemBulkWriteView) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExperimentItemBulkRecordExperimentItemBulkWriteView) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ExperimentItemBulkUploadExperimentItemBulkWriteView) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ExperimentItemBulkUploadExperimentItemBulkWriteView) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("experiment_name")
		e.Str(s.ExperimentName)
	}
	{
		e.FieldStart("dataset_name")
		e.Str(s.DatasetName)
	}
	{
		if s.ExperimentID.Set {
			e.FieldStart("experiment_id")
			s.ExperimentID.Encode(e)
		}
	}
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfExperimentItemBulkUploadExperimentItemBulkWriteView = [4]string{
	0: "experiment_name",
	1: "dataset_name",
	2: "experiment_id",
	3: "items",
}

// Decode decodes ExperimentItemBulkUploadExperimentItemBulkWriteView from json.
func (s *ExperimentItemBulkUploadExperimentItemBulkWriteView) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExperimentItemBulkUploadExperimentItemBulkWriteView to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "experiment_name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ExperimentName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"experiment_name\"")
			}
		case "dataset_name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.DatasetName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dataset_name\"")
			}
		case "experiment_id":
			if err := func() error {
				s.ExperimentID.Reset()
				if err := s.ExperimentID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"experiment_id\"")
			}
		case "items":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Items = make([]ExperimentItemBulkRecordExperimentItemBulkWriteView, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ExperimentItemBulkRecordExperimentItemBulkWriteView
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ExperimentItemBulkUploadExperimentItemBulkWriteView")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfExperimentItemBulkUploadExperimentItemBulkWriteView) {
					name = jsonFieldsNameOfExperimentItemBulkUploadExperimentItemBulkWriteView[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ExperimentItemBulkUploadExperimentItemBulkWriteView) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExperimentItemBulkUploadExperimentItemBulkWriteView) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ExperimentItemCompare) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ExperimentItemCompare) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		e.FieldStart("experiment_id")
		json.EncodeUUID(e, s.ExperimentID)
	}
	{
		e.FieldStart("dataset_item_id")
		json.EncodeUUID(e, s.DatasetItemID)
	}
	{
		e.FieldStart("trace_id")
		json.EncodeUUID(e, s.TraceID)
	}
	{
		e.FieldStart("input")
		s.Input.Encode(e)
	}
	{
		e.FieldStart("output")
		s.Output.Encode(e)
	}
	{
		if s.FeedbackScores != nil {
			e.FieldStart("feedback_scores")
			e.ArrStart()
			for _, elem := range s.FeedbackScores {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Comments != nil {
			e.FieldStart("comments")
			e.ArrStart()
			for _, elem := range s.Comments {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.TotalEstimatedCost.Set {
			e.FieldStart("total_estimated_cost")
			s.TotalEstimatedCost.Encode(e)
		}
	}
	{
		if s.Duration.Set {
			e.FieldStart("duration")
			s.Duration.Encode(e)
		}
	}
	{
		if s.Usage.Set {
			e.FieldStart("usage")
			s.Usage.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.LastUpdatedAt.Set {
			e.FieldStart("last_updated_at")
			s.LastUpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.CreatedBy.Set {
			e.FieldStart("created_by")
			s.CreatedBy.Encode(e)
		}
	}
	{
		if s.LastUpdatedBy.Set {
			e.FieldStart("last_updated_by")
			s.LastUpdatedBy.Encode(e)
		}
	}
	{
		if s.TraceVisibilityMode.Set {
			e.FieldStart("trace_visibility_mode")
			s.TraceVisibilityMode.Encode(e)
		}
	}
}

var jsonFieldsNameOfExperimentItemCompare = [16]string{
	0:  "id",
	1:  "experiment_id",
	2:  "dataset_item_id",
	3:  "trace_id",
	4:  "input",
	5:  "output",
	6:  "feedback_scores",
	7:  "comments",
	8:  "total_estimated_cost",
	9:  "duration",
	10: "usage",
	11: "created_at",
	12: "last_updated_at",
	13: "created_by",
	14: "last_updated_by",
	15: "trace_visibility_mode",
}

// Decode decodes ExperimentItemCompare from json.
func (s *ExperimentItemCompare) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExperimentItemCompare to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "experiment_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ExperimentID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"experiment_id\"")
			}
		case "dataset_item_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.DatasetItemID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dataset_item_id\"")
			}
		case "trace_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.TraceID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trace_id\"")
			}
		case "input":
			if err := func() error {
				if err := s.Input.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"input\"")
			}
		case "output":
			if err := func() error {
				if err := s.Output.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"output\"")
			}
		case "feedback_scores":
			if err := func() error {
				s.FeedbackScores = make([]FeedbackScoreCompare, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem FeedbackScoreCompare
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.FeedbackScores = append(s.FeedbackScores, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"feedback_scores\"")
			}
		case "comments":
			if err := func() error {
				s.Comments = make([]CommentCompare, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CommentCompare
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Comments = append(s.Comments, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comments\"")
			}
		case "total_estimated_cost":
			if err := func() error {
				s.TotalEstimatedCost.Reset()
				if err := s.TotalEstimatedCost.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_estimated_cost\"")
			}
		case "duration":
			if err := func() error {
				s.Duration.Reset()
				if err := s.Duration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration\"")
			}
		case "usage":
			if err := func() error {
				s.Usage.Reset()
				if err := s.Usage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usage\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "last_updated_at":
			if err := func() error {
				s.LastUpdatedAt.Reset()
				if err := s.LastUpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated_at\"")
			}
		case "created_by":
			if err := func() error {
				s.CreatedBy.Reset()
				if err := s.CreatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_by\"")
			}
		case "last_updated_by":
			if err := func() error {
				s.LastUpdatedBy.Reset()
				if err := s.LastUpdatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated_by\"")
			}
		case "trace_visibility_mode":
			if err := func() error {
				s.TraceVisibilityMode.Reset()
				if err := s.TraceVisibilityMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trace_visibility_mode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ExperimentItemCompare")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00001110,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfExperimentItemCompare) {
					name = jsonFieldsNameOfExperimentItemCompare[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ExperimentItemCompare) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExperimentItemCompare) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ExperimentItemCompareTraceVisibilityMode as json.
func (s ExperimentItemCompareTraceVisibilityMode) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ExperimentItemCompareTraceVisibilityMode from json.
func (s *ExperimentItemCompareTraceVisibilityMode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExperimentItemCompareTraceVisibilityMode to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ExperimentItemCompareTraceVisibilityMode(v) {
	case ExperimentItemCompareTraceVisibilityModeDefault:
		*s = ExperimentItemCompareTraceVisibilityModeDefault
	case ExperimentItemCompareTraceVisibilityModeHidden:
		*s = ExperimentItemCompareTraceVisibilityModeHidden
	default:
		*s = ExperimentItemCompareTraceVisibilityMode(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ExperimentItemCompareTraceVisibilityMode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExperimentItemCompareTraceVisibilityMode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ExperimentItemCompareUsage) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s ExperimentItemCompareUsage) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Int64(elem)
	}
}

// Decode decodes ExperimentItemCompareUsage from json.
func (s *ExperimentItemCompareUsage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExperimentItemCompareUsage to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem int64
		if err := func() error {
			v, err := d.Int64()
			elem = int64(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ExperimentItemCompareUsage")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ExperimentItemCompareUsage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExperimentItemCompareUsage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ExperimentItemPublic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ExperimentItemPublic) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		e.FieldStart("experiment_id")
		json.EncodeUUID(e, s.ExperimentID)
	}
	{
		e.FieldStart("dataset_item_id")
		json.EncodeUUID(e, s.DatasetItemID)
	}
	{
		e.FieldStart("trace_id")
		json.EncodeUUID(e, s.TraceID)
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.LastUpdatedAt.Set {
			e.FieldStart("last_updated_at")
			s.LastUpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.CreatedBy.Set {
			e.FieldStart("created_by")
			s.CreatedBy.Encode(e)
		}
	}
	{
		if s.LastUpdatedBy.Set {
			e.FieldStart("last_updated_by")
			s.LastUpdatedBy.Encode(e)
		}
	}
	{
		if s.TraceVisibilityMode.Set {
			e.FieldStart("trace_visibility_mode")
			s.TraceVisibilityMode.Encode(e)
		}
	}
}

var jsonFieldsNameOfExperimentItemPublic = [9]string{
	0: "id",
	1: "experiment_id",
	2: "dataset_item_id",
	3: "trace_id",
	4: "created_at",
	5: "last_updated_at",
	6: "created_by",
	7: "last_updated_by",
	8: "trace_visibility_mode",
}

// Decode decodes ExperimentItemPublic from json.
func (s *ExperimentItemPublic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExperimentItemPublic to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "experiment_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ExperimentID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"experiment_id\"")
			}
		case "dataset_item_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.DatasetItemID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dataset_item_id\"")
			}
		case "trace_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.TraceID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trace_id\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "last_updated_at":
			if err := func() error {
				s.LastUpdatedAt.Reset()
				if err := s.LastUpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated_at\"")
			}
		case "created_by":
			if err := func() error {
				s.CreatedBy.Reset()
				if err := s.CreatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_by\"")
			}
		case "last_updated_by":
			if err := func() error {
				s.LastUpdatedBy.Reset()
				if err := s.LastUpdatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated_by\"")
			}
		case "trace_visibility_mode":
			if err := func() error {
				s.TraceVisibilityMode.Reset()
				if err := s.TraceVisibilityMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trace_visibility_mode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ExperimentItemPublic")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00001110,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfExperimentItemPublic) {
					name = jsonFieldsNameOfExperimentItemPublic[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ExperimentItemPublic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExperimentItemPublic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ExperimentItemPublicTraceVisibilityMode as json.
func (s ExperimentItemPublicTraceVisibilityMode) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ExperimentItemPublicTraceVisibilityMode from json.
func (s *ExperimentItemPublicTraceVisibilityMode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExperimentItemPublicTraceVisibilityMode to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ExperimentItemPublicTraceVisibilityMode(v) {
	case ExperimentItemPublicTraceVisibilityModeDefault:
		*s = ExperimentItemPublicTraceVisibilityModeDefault
	case ExperimentItemPublicTraceVisibilityModeHidden:
		*s = ExperimentItemPublicTraceVisibilityModeHidden
	default:
		*s = ExperimentItemPublicTraceVisibilityMode(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ExperimentItemPublicTraceVisibilityMode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExperimentItemPublicTraceVisibilityMode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ExperimentItemTraceVisibilityMode as json.
func (s ExperimentItemTraceVisibilityMode) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ExperimentItemTraceVisibilityMode from json.
func (s *ExperimentItemTraceVisibilityMode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExperimentItemTraceVisibilityMode to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ExperimentItemTraceVisibilityMode(v) {
	case ExperimentItemTraceVisibilityModeDefault:
		*s = ExperimentItemTraceVisibilityModeDefault
	case ExperimentItemTraceVisibilityModeHidden:
		*s = ExperimentItemTraceVisibilityModeHidden
	default:
		*s = ExperimentItemTraceVisibilityMode(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ExperimentItemTraceVisibilityMode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExperimentItemTraceVisibilityMode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ExperimentItemUsage) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s ExperimentItemUsage) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Int64(elem)
	}
}

// Decode decodes ExperimentItemUsage from json.
func (s *ExperimentItemUsage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExperimentItemUsage to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem int64
		if err := func() error {
			v, err := d.Int64()
			elem = int64(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ExperimentItemUsage")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ExperimentItemUsage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExperimentItemUsage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ExperimentItemsBatch) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ExperimentItemsBatch) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("experiment_items")
		e.ArrStart()
		for _, elem := range s.ExperimentItems {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfExperimentItemsBatch = [1]string{
	0: "experiment_items",
}

// Decode decodes ExperimentItemsBatch from json.
func (s *ExperimentItemsBatch) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExperimentItemsBatch to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "experiment_items":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.ExperimentItems = make([]ExperimentItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ExperimentItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ExperimentItems = append(s.ExperimentItems, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"experiment_items\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ExperimentItemsBatch")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfExperimentItemsBatch) {
					name = jsonFieldsNameOfExperimentItemsBatch[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ExperimentItemsBatch) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExperimentItemsBatch) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ExperimentItemsBulkBadRequest as json.
func (s *ExperimentItemsBulkBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessage)(s)

	unwrapped.Encode(e)
}

// Decode decodes ExperimentItemsBulkBadRequest from json.
func (s *ExperimentItemsBulkBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExperimentItemsBulkBadRequest to nil")
	}
	var unwrapped ErrorMessage
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ExperimentItemsBulkBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ExperimentItemsBulkBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExperimentItemsBulkBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ExperimentItemsBulkConflict as json.
func (s *ExperimentItemsBulkConflict) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessage)(s)

	unwrapped.Encode(e)
}

// Decode decodes ExperimentItemsBulkConflict from json.
func (s *ExperimentItemsBulkConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExperimentItemsBulkConflict to nil")
	}
	var unwrapped ErrorMessage
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ExperimentItemsBulkConflict(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ExperimentItemsBulkConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExperimentItemsBulkConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ExperimentItemsBulkUnprocessableEntity as json.
func (s *ExperimentItemsBulkUnprocessableEntity) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessage)(s)

	unwrapped.Encode(e)
}

// Decode decodes ExperimentItemsBulkUnprocessableEntity from json.
func (s *ExperimentItemsBulkUnprocessableEntity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExperimentItemsBulkUnprocessableEntity to nil")
	}
	var unwrapped ErrorMessage
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ExperimentItemsBulkUnprocessableEntity(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ExperimentItemsBulkUnprocessableEntity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExperimentItemsBulkUnprocessableEntity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ExperimentItemsDelete) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ExperimentItemsDelete) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("ids")
		e.ArrStart()
		for _, elem := range s.Ids {
			json.EncodeUUID(e, elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfExperimentItemsDelete = [1]string{
	0: "ids",
}

// Decode decodes ExperimentItemsDelete from json.
func (s *ExperimentItemsDelete) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExperimentItemsDelete to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ids":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Ids = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.Ids = append(s.Ids, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ids\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ExperimentItemsDelete")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfExperimentItemsDelete) {
					name = jsonFieldsNameOfExperimentItemsDelete[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ExperimentItemsDelete) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExperimentItemsDelete) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ExperimentPagePublic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ExperimentPagePublic) encodeFields(e *jx.Encoder) {
	{
		if s.Page.Set {
			e.FieldStart("page")
			s.Page.Encode(e)
		}
	}
	{
		if s.Size.Set {
			e.FieldStart("size")
			s.Size.Encode(e)
		}
	}
	{
		if s.Total.Set {
			e.FieldStart("total")
			s.Total.Encode(e)
		}
	}
	{
		if s.Content != nil {
			e.FieldStart("content")
			e.ArrStart()
			for _, elem := range s.Content {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.SortableBy != nil {
			e.FieldStart("sortableBy")
			e.ArrStart()
			for _, elem := range s.SortableBy {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfExperimentPagePublic = [5]string{
	0: "page",
	1: "size",
	2: "total",
	3: "content",
	4: "sortableBy",
}

// Decode decodes ExperimentPagePublic from json.
func (s *ExperimentPagePublic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExperimentPagePublic to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "page":
			if err := func() error {
				s.Page.Reset()
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "size":
			if err := func() error {
				s.Size.Reset()
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "total":
			if err := func() error {
				s.Total.Reset()
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "content":
			if err := func() error {
				s.Content = make([]ExperimentPublic, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ExperimentPublic
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Content = append(s.Content, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		case "sortableBy":
			if err := func() error {
				s.SortableBy = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.SortableBy = append(s.SortableBy, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sortableBy\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ExperimentPagePublic")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ExperimentPagePublic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExperimentPagePublic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ExperimentPublic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ExperimentPublic) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		e.FieldStart("dataset_name")
		e.Str(s.DatasetName)
	}
	{
		if s.DatasetID.Set {
			e.FieldStart("dataset_id")
			s.DatasetID.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		e.FieldStart("metadata")
		s.Metadata.Encode(e)
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.OptimizationID.Set {
			e.FieldStart("optimization_id")
			s.OptimizationID.Encode(e)
		}
	}
	{
		if s.FeedbackScores != nil {
			e.FieldStart("feedback_scores")
			e.ArrStart()
			for _, elem := range s.FeedbackScores {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Comments != nil {
			e.FieldStart("comments")
			e.ArrStart()
			for _, elem := range s.Comments {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.TraceCount.Set {
			e.FieldStart("trace_count")
			s.TraceCount.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Duration.Set {
			e.FieldStart("duration")
			s.Duration.Encode(e)
		}
	}
	{
		if s.TotalEstimatedCost.Set {
			e.FieldStart("total_estimated_cost")
			s.TotalEstimatedCost.Encode(e)
		}
	}
	{
		if s.TotalEstimatedCostAvg.Set {
			e.FieldStart("total_estimated_cost_avg")
			s.TotalEstimatedCostAvg.Encode(e)
		}
	}
	{
		if s.Usage.Set {
			e.FieldStart("usage")
			s.Usage.Encode(e)
		}
	}
	{
		if s.LastUpdatedAt.Set {
			e.FieldStart("last_updated_at")
			s.LastUpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.CreatedBy.Set {
			e.FieldStart("created_by")
			s.CreatedBy.Encode(e)
		}
	}
	{
		if s.LastUpdatedBy.Set {
			e.FieldStart("last_updated_by")
			s.LastUpdatedBy.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.ExperimentScores != nil {
			e.FieldStart("experiment_scores")
			e.ArrStart()
			for _, elem := range s.ExperimentScores {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PromptVersion.Set {
			e.FieldStart("prompt_version")
			s.PromptVersion.Encode(e)
		}
	}
	{
		if s.PromptVersions != nil {
			e.FieldStart("prompt_versions")
			e.ArrStart()
			for _, elem := range s.PromptVersions {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfExperimentPublic = [22]string{
	0:  "id",
	1:  "dataset_name",
	2:  "dataset_id",
	3:  "name",
	4:  "metadata",
	5:  "type",
	6:  "optimization_id",
	7:  "feedback_scores",
	8:  "comments",
	9:  "trace_count",
	10: "created_at",
	11: "duration",
	12: "total_estimated_cost",
	13: "total_estimated_cost_avg",
	14: "usage",
	15: "last_updated_at",
	16: "created_by",
	17: "last_updated_by",
	18: "status",
	19: "experiment_scores",
	20: "prompt_version",
	21: "prompt_versions",
}

// Decode decodes ExperimentPublic from json.
func (s *ExperimentPublic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExperimentPublic to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "dataset_name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.DatasetName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dataset_name\"")
			}
		case "dataset_id":
			if err := func() error {
				s.DatasetID.Reset()
				if err := s.DatasetID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dataset_id\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "metadata":
			if err := func() error {
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "optimization_id":
			if err := func() error {
				s.OptimizationID.Reset()
				if err := s.OptimizationID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"optimization_id\"")
			}
		case "feedback_scores":
			if err := func() error {
				s.FeedbackScores = make([]FeedbackScoreAveragePublic, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem FeedbackScoreAveragePublic
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.FeedbackScores = append(s.FeedbackScores, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"feedback_scores\"")
			}
		case "comments":
			if err := func() error {
				s.Comments = make([]CommentPublic, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CommentPublic
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Comments = append(s.Comments, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comments\"")
			}
		case "trace_count":
			if err := func() error {
				s.TraceCount.Reset()
				if err := s.TraceCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trace_count\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "duration":
			if err := func() error {
				s.Duration.Reset()
				if err := s.Duration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration\"")
			}
		case "total_estimated_cost":
			if err := func() error {
				s.TotalEstimatedCost.Reset()
				if err := s.TotalEstimatedCost.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_estimated_cost\"")
			}
		case "total_estimated_cost_avg":
			if err := func() error {
				s.TotalEstimatedCostAvg.Reset()
				if err := s.TotalEstimatedCostAvg.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_estimated_cost_avg\"")
			}
		case "usage":
			if err := func() error {
				s.Usage.Reset()
				if err := s.Usage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usage\"")
			}
		case "last_updated_at":
			if err := func() error {
				s.LastUpdatedAt.Reset()
				if err := s.LastUpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated_at\"")
			}
		case "created_by":
			if err := func() error {
				s.CreatedBy.Reset()
				if err := s.CreatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_by\"")
			}
		case "last_updated_by":
			if err := func() error {
				s.LastUpdatedBy.Reset()
				if err := s.LastUpdatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated_by\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "experiment_scores":
			if err := func() error {
				s.ExperimentScores = make([]ExperimentScorePublic, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ExperimentScorePublic
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ExperimentScores = append(s.ExperimentScores, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"experiment_scores\"")
			}
		case "prompt_version":
			if err := func() error {
				s.PromptVersion.Reset()
				if err := s.PromptVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prompt_version\"")
			}
		case "prompt_versions":
			if err := func() error {
				s.PromptVersions = make([]PromptVersionLinkPublic, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PromptVersionLinkPublic
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.PromptVersions = append(s.PromptVersions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prompt_versions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ExperimentPublic")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b00000010,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfExperimentPublic) {
					name = jsonFieldsNameOfExperimentPublic[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ExperimentPublic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExperimentPublic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ExperimentPublicStatus as json.
func (s ExperimentPublicStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ExperimentPublicStatus from json.
func (s *ExperimentPublicStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExperimentPublicStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ExperimentPublicStatus(v) {
	case ExperimentPublicStatusRunning:
		*s = ExperimentPublicStatusRunning
	case ExperimentPublicStatusCompleted:
		*s = ExperimentPublicStatusCompleted
	case ExperimentPublicStatusCancelled:
		*s = ExperimentPublicStatusCancelled
	default:
		*s = ExperimentPublicStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ExperimentPublicStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExperimentPublicStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ExperimentPublicType as json.
func (s ExperimentPublicType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ExperimentPublicType from json.
func (s *ExperimentPublicType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExperimentPublicType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ExperimentPublicType(v) {
	case ExperimentPublicTypeRegular:
		*s = ExperimentPublicTypeRegular
	case ExperimentPublicTypeTrial:
		*s = ExperimentPublicTypeTrial
	case ExperimentPublicTypeMiniBatch:
		*s = ExperimentPublicTypeMiniBatch
	default:
		*s = ExperimentPublicType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ExperimentPublicType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExperimentPublicType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ExperimentPublicUsage) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s ExperimentPublicUsage) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Float64(elem)
	}
}

// Decode decodes ExperimentPublicUsage from json.
func (s *ExperimentPublicUsage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExperimentPublicUsage to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem float64
		if err := func() error {
			v, err := d.Float64()
			elem = float64(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ExperimentPublicUsage")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ExperimentPublicUsage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExperimentPublicUsage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ExperimentScore) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ExperimentScore) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("value")
		e.Float64(s.Value)
	}
}

var jsonFieldsNameOfExperimentScore = [2]string{
	0: "name",
	1: "value",
}

// Decode decodes ExperimentScore from json.
func (s *ExperimentScore) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExperimentScore to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.Value = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ExperimentScore")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfExperimentScore) {
					name = jsonFieldsNameOfExperimentScore[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ExperimentScore) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExperimentScore) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ExperimentScorePublic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ExperimentScorePublic) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("value")
		e.Float64(s.Value)
	}
}

var jsonFieldsNameOfExperimentScorePublic = [2]string{
	0: "name",
	1: "value",
}

// Decode decodes ExperimentScorePublic from json.
func (s *ExperimentScorePublic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExperimentScorePublic to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.Value = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ExperimentScorePublic")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfExperimentScorePublic) {
					name = jsonFieldsNameOfExperimentScorePublic[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ExperimentScorePublic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExperimentScorePublic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ExperimentScoreWrite) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ExperimentScoreWrite) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("value")
		e.Float64(s.Value)
	}
}

var jsonFieldsNameOfExperimentScoreWrite = [2]string{
	0: "name",
	1: "value",
}

// Decode decodes ExperimentScoreWrite from json.
func (s *ExperimentScoreWrite) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExperimentScoreWrite to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.Value = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ExperimentScoreWrite")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfExperimentScoreWrite) {
					name = jsonFieldsNameOfExperimentScoreWrite[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ExperimentScoreWrite) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExperimentScoreWrite) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ExperimentUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ExperimentUpdate) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.ExperimentScores != nil {
			e.FieldStart("experiment_scores")
			e.ArrStart()
			for _, elem := range s.ExperimentScores {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfExperimentUpdate = [5]string{
	0: "name",
	1: "metadata",
	2: "type",
	3: "status",
	4: "experiment_scores",
}

// Decode decodes ExperimentUpdate from json.
func (s *ExperimentUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExperimentUpdate to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "experiment_scores":
			if err := func() error {
				s.ExperimentScores = make([]ExperimentScore, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ExperimentScore
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ExperimentScores = append(s.ExperimentScores, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"experiment_scores\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ExperimentUpdate")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ExperimentUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExperimentUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ExperimentUpdateStatus as json.
func (s ExperimentUpdateStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ExperimentUpdateStatus from json.
func (s *ExperimentUpdateStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExperimentUpdateStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ExperimentUpdateStatus(v) {
	case ExperimentUpdateStatusRunning:
		*s = ExperimentUpdateStatusRunning
	case ExperimentUpdateStatusCompleted:
		*s = ExperimentUpdateStatusCompleted
	case ExperimentUpdateStatusCancelled:
		*s = ExperimentUpdateStatusCancelled
	default:
		*s = ExperimentUpdateStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ExperimentUpdateStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExperimentUpdateStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ExperimentUpdateType as json.
func (s ExperimentUpdateType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ExperimentUpdateType from json.
func (s *ExperimentUpdateType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExperimentUpdateType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ExperimentUpdateType(v) {
	case ExperimentUpdateTypeRegular:
		*s = ExperimentUpdateTypeRegular
	case ExperimentUpdateTypeTrial:
		*s = ExperimentUpdateTypeTrial
	case ExperimentUpdateTypeMiniBatch:
		*s = ExperimentUpdateTypeMiniBatch
	default:
		*s = ExperimentUpdateType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ExperimentUpdateType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExperimentUpdateType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ExperimentWrite) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ExperimentWrite) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		e.FieldStart("dataset_name")
		e.Str(s.DatasetName)
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		e.FieldStart("metadata")
		s.Metadata.Encode(e)
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.OptimizationID.Set {
			e.FieldStart("optimization_id")
			s.OptimizationID.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.ExperimentScores != nil {
			e.FieldStart("experiment_scores")
			e.ArrStart()
			for _, elem := range s.ExperimentScores {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PromptVersion.Set {
			e.FieldStart("prompt_version")
			s.PromptVersion.Encode(e)
		}
	}
	{
		if s.PromptVersions != nil {
			e.FieldStart("prompt_versions")
			e.ArrStart()
			for _, elem := range s.PromptVersions {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfExperimentWrite = [10]string{
	0: "id",
	1: "dataset_name",
	2: "name",
	3: "metadata",
	4: "type",
	5: "optimization_id",
	6: "status",
	7: "experiment_scores",
	8: "prompt_version",
	9: "prompt_versions",
}

// Decode decodes ExperimentWrite from json.
func (s *ExperimentWrite) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExperimentWrite to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "dataset_name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.DatasetName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dataset_name\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "metadata":
			if err := func() error {
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "optimization_id":
			if err := func() error {
				s.OptimizationID.Reset()
				if err := s.OptimizationID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"optimization_id\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "experiment_scores":
			if err := func() error {
				s.ExperimentScores = make([]ExperimentScoreWrite, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ExperimentScoreWrite
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ExperimentScores = append(s.ExperimentScores, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"experiment_scores\"")
			}
		case "prompt_version":
			if err := func() error {
				s.PromptVersion.Reset()
				if err := s.PromptVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prompt_version\"")
			}
		case "prompt_versions":
			if err := func() error {
				s.PromptVersions = make([]PromptVersionLinkWrite, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PromptVersionLinkWrite
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.PromptVersions = append(s.PromptVersions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prompt_versions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ExperimentWrite")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000010,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfExperimentWrite) {
					name = jsonFieldsNameOfExperimentWrite[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ExperimentWrite) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExperimentWrite) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ExperimentWriteStatus as json.
func (s ExperimentWriteStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ExperimentWriteStatus from json.
func (s *ExperimentWriteStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExperimentWriteStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ExperimentWriteStatus(v) {
	case ExperimentWriteStatusRunning:
		*s = ExperimentWriteStatusRunning
	case ExperimentWriteStatusCompleted:
		*s = ExperimentWriteStatusCompleted
	case ExperimentWriteStatusCancelled:
		*s = ExperimentWriteStatusCancelled
	default:
		*s = ExperimentWriteStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ExperimentWriteStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExperimentWriteStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ExperimentWriteType as json.
func (s ExperimentWriteType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ExperimentWriteType from json.
func (s *ExperimentWriteType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExperimentWriteType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ExperimentWriteType(v) {
	case ExperimentWriteTypeRegular:
		*s = ExperimentWriteTypeRegular
	case ExperimentWriteTypeTrial:
		*s = ExperimentWriteTypeTrial
	case ExperimentWriteTypeMiniBatch:
		*s = ExperimentWriteTypeMiniBatch
	default:
		*s = ExperimentWriteType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ExperimentWriteType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExperimentWriteType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FeedbackCreate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FeedbackCreate) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
}

var jsonFieldsNameOfFeedbackCreate = [4]string{
	0: "id",
	1: "name",
	2: "description",
	3: "type",
}

// Decode decodes FeedbackCreate from json.
func (s *FeedbackCreate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FeedbackCreate to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FeedbackCreate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFeedbackCreate) {
					name = jsonFieldsNameOfFeedbackCreate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FeedbackCreate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FeedbackCreate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FeedbackCreateType as json.
func (s FeedbackCreateType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes FeedbackCreateType from json.
func (s *FeedbackCreateType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FeedbackCreateType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch FeedbackCreateType(v) {
	case FeedbackCreateTypeNumerical:
		*s = FeedbackCreateTypeNumerical
	case FeedbackCreateTypeCategorical:
		*s = FeedbackCreateTypeCategorical
	case FeedbackCreateTypeBoolean:
		*s = FeedbackCreateTypeBoolean
	default:
		*s = FeedbackCreateType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FeedbackCreateType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FeedbackCreateType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FeedbackDefinitionPagePublic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FeedbackDefinitionPagePublic) encodeFields(e *jx.Encoder) {
	{
		if s.Page.Set {
			e.FieldStart("page")
			s.Page.Encode(e)
		}
	}
	{
		if s.Size.Set {
			e.FieldStart("size")
			s.Size.Encode(e)
		}
	}
	{
		if s.Total.Set {
			e.FieldStart("total")
			s.Total.Encode(e)
		}
	}
	{
		if s.Content != nil {
			e.FieldStart("content")
			e.ArrStart()
			for _, elem := range s.Content {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfFeedbackDefinitionPagePublic = [4]string{
	0: "page",
	1: "size",
	2: "total",
	3: "content",
}

// Decode decodes FeedbackDefinitionPagePublic from json.
func (s *FeedbackDefinitionPagePublic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FeedbackDefinitionPagePublic to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "page":
			if err := func() error {
				s.Page.Reset()
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "size":
			if err := func() error {
				s.Size.Reset()
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "total":
			if err := func() error {
				s.Total.Reset()
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "content":
			if err := func() error {
				s.Content = make([]FeedbackObjectPublic, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem FeedbackObjectPublic
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Content = append(s.Content, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FeedbackDefinitionPagePublic")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FeedbackDefinitionPagePublic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FeedbackDefinitionPagePublic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FeedbackObjectPublic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FeedbackObjectPublic) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("createdAt")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.CreatedBy.Set {
			e.FieldStart("createdBy")
			s.CreatedBy.Encode(e)
		}
	}
	{
		if s.LastUpdatedAt.Set {
			e.FieldStart("lastUpdatedAt")
			s.LastUpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.LastUpdatedBy.Set {
			e.FieldStart("lastUpdatedBy")
			s.LastUpdatedBy.Encode(e)
		}
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
}

var jsonFieldsNameOfFeedbackObjectPublic = [8]string{
	0: "id",
	1: "name",
	2: "description",
	3: "createdAt",
	4: "createdBy",
	5: "lastUpdatedAt",
	6: "lastUpdatedBy",
	7: "type",
}

// Decode decodes FeedbackObjectPublic from json.
func (s *FeedbackObjectPublic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FeedbackObjectPublic to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "createdAt":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "createdBy":
			if err := func() error {
				s.CreatedBy.Reset()
				if err := s.CreatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdBy\"")
			}
		case "lastUpdatedAt":
			if err := func() error {
				s.LastUpdatedAt.Reset()
				if err := s.LastUpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastUpdatedAt\"")
			}
		case "lastUpdatedBy":
			if err := func() error {
				s.LastUpdatedBy.Reset()
				if err := s.LastUpdatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastUpdatedBy\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FeedbackObjectPublic")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b10000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFeedbackObjectPublic) {
					name = jsonFieldsNameOfFeedbackObjectPublic[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FeedbackObjectPublic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FeedbackObjectPublic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FeedbackObjectPublicType as json.
func (s FeedbackObjectPublicType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes FeedbackObjectPublicType from json.
func (s *FeedbackObjectPublicType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FeedbackObjectPublicType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch FeedbackObjectPublicType(v) {
	case FeedbackObjectPublicTypeNumerical:
		*s = FeedbackObjectPublicTypeNumerical
	case FeedbackObjectPublicTypeCategorical:
		*s = FeedbackObjectPublicTypeCategorical
	case FeedbackObjectPublicTypeBoolean:
		*s = FeedbackObjectPublicTypeBoolean
	default:
		*s = FeedbackObjectPublicType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FeedbackObjectPublicType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FeedbackObjectPublicType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FeedbackPublic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FeedbackPublic) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("createdAt")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.CreatedBy.Set {
			e.FieldStart("createdBy")
			s.CreatedBy.Encode(e)
		}
	}
	{
		if s.LastUpdatedAt.Set {
			e.FieldStart("lastUpdatedAt")
			s.LastUpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.LastUpdatedBy.Set {
			e.FieldStart("lastUpdatedBy")
			s.LastUpdatedBy.Encode(e)
		}
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
}

var jsonFieldsNameOfFeedbackPublic = [8]string{
	0: "id",
	1: "name",
	2: "description",
	3: "createdAt",
	4: "createdBy",
	5: "lastUpdatedAt",
	6: "lastUpdatedBy",
	7: "type",
}

// Decode decodes FeedbackPublic from json.
func (s *FeedbackPublic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FeedbackPublic to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "createdAt":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "createdBy":
			if err := func() error {
				s.CreatedBy.Reset()
				if err := s.CreatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdBy\"")
			}
		case "lastUpdatedAt":
			if err := func() error {
				s.LastUpdatedAt.Reset()
				if err := s.LastUpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastUpdatedAt\"")
			}
		case "lastUpdatedBy":
			if err := func() error {
				s.LastUpdatedBy.Reset()
				if err := s.LastUpdatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastUpdatedBy\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FeedbackPublic")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b10000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFeedbackPublic) {
					name = jsonFieldsNameOfFeedbackPublic[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FeedbackPublic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FeedbackPublic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FeedbackPublicType as json.
func (s FeedbackPublicType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes FeedbackPublicType from json.
func (s *FeedbackPublicType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FeedbackPublicType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch FeedbackPublicType(v) {
	case FeedbackPublicTypeNumerical:
		*s = FeedbackPublicTypeNumerical
	case FeedbackPublicTypeCategorical:
		*s = FeedbackPublicTypeCategorical
	case FeedbackPublicTypeBoolean:
		*s = FeedbackPublicTypeBoolean
	default:
		*s = FeedbackPublicType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FeedbackPublicType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FeedbackPublicType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FeedbackScore) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FeedbackScore) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.CategoryName.Set {
			e.FieldStart("category_name")
			s.CategoryName.Encode(e)
		}
	}
	{
		e.FieldStart("value")
		e.Float64(s.Value)
	}
	{
		if s.Reason.Set {
			e.FieldStart("reason")
			s.Reason.Encode(e)
		}
	}
	{
		e.FieldStart("source")
		s.Source.Encode(e)
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.LastUpdatedAt.Set {
			e.FieldStart("last_updated_at")
			s.LastUpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.CreatedBy.Set {
			e.FieldStart("created_by")
			s.CreatedBy.Encode(e)
		}
	}
	{
		if s.LastUpdatedBy.Set {
			e.FieldStart("last_updated_by")
			s.LastUpdatedBy.Encode(e)
		}
	}
	{
		if s.ValueByAuthor.Set {
			e.FieldStart("value_by_author")
			s.ValueByAuthor.Encode(e)
		}
	}
}

var jsonFieldsNameOfFeedbackScore = [10]string{
	0: "name",
	1: "category_name",
	2: "value",
	3: "reason",
	4: "source",
	5: "created_at",
	6: "last_updated_at",
	7: "created_by",
	8: "last_updated_by",
	9: "value_by_author",
}

// Decode decodes FeedbackScore from json.
func (s *FeedbackScore) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FeedbackScore to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "category_name":
			if err := func() error {
				s.CategoryName.Reset()
				if err := s.CategoryName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"category_name\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float64()
				s.Value = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "source":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Source.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "last_updated_at":
			if err := func() error {
				s.LastUpdatedAt.Reset()
				if err := s.LastUpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated_at\"")
			}
		case "created_by":
			if err := func() error {
				s.CreatedBy.Reset()
				if err := s.CreatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_by\"")
			}
		case "last_updated_by":
			if err := func() error {
				s.LastUpdatedBy.Reset()
				if err := s.LastUpdatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated_by\"")
			}
		case "value_by_author":
			if err := func() error {
				s.ValueByAuthor.Reset()
				if err := s.ValueByAuthor.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value_by_author\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FeedbackScore")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00010101,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFeedbackScore) {
					name = jsonFieldsNameOfFeedbackScore[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FeedbackScore) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FeedbackScore) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FeedbackScoreAverage) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FeedbackScoreAverage) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("value")
		e.Float64(s.Value)
	}
}

var jsonFieldsNameOfFeedbackScoreAverage = [2]string{
	0: "name",
	1: "value",
}

// Decode decodes FeedbackScoreAverage from json.
func (s *FeedbackScoreAverage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FeedbackScoreAverage to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.Value = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FeedbackScoreAverage")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFeedbackScoreAverage) {
					name = jsonFieldsNameOfFeedbackScoreAverage[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FeedbackScoreAverage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FeedbackScoreAverage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FeedbackScoreAverageDetailed) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FeedbackScoreAverageDetailed) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("value")
		e.Float64(s.Value)
	}
}

var jsonFieldsNameOfFeedbackScoreAverageDetailed = [2]string{
	0: "name",
	1: "value",
}

// Decode decodes FeedbackScoreAverageDetailed from json.
func (s *FeedbackScoreAverageDetailed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FeedbackScoreAverageDetailed to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.Value = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FeedbackScoreAverageDetailed")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFeedbackScoreAverageDetailed) {
					name = jsonFieldsNameOfFeedbackScoreAverageDetailed[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FeedbackScoreAverageDetailed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FeedbackScoreAverageDetailed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FeedbackScoreAveragePublic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FeedbackScoreAveragePublic) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("value")
		e.Float64(s.Value)
	}
}

var jsonFieldsNameOfFeedbackScoreAveragePublic = [2]string{
	0: "name",
	1: "value",
}

// Decode decodes FeedbackScoreAveragePublic from json.
func (s *FeedbackScoreAveragePublic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FeedbackScoreAveragePublic to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.Value = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FeedbackScoreAveragePublic")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFeedbackScoreAveragePublic) {
					name = jsonFieldsNameOfFeedbackScoreAveragePublic[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FeedbackScoreAveragePublic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FeedbackScoreAveragePublic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FeedbackScoreBatch) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FeedbackScoreBatch) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("scores")
		e.ArrStart()
		for _, elem := range s.Scores {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfFeedbackScoreBatch = [1]string{
	0: "scores",
}

// Decode decodes FeedbackScoreBatch from json.
func (s *FeedbackScoreBatch) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FeedbackScoreBatch to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "scores":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Scores = make([]FeedbackScoreBatchItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem FeedbackScoreBatchItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Scores = append(s.Scores, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scores\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FeedbackScoreBatch")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFeedbackScoreBatch) {
					name = jsonFieldsNameOfFeedbackScoreBatch[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FeedbackScoreBatch) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FeedbackScoreBatch) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FeedbackScoreBatchItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FeedbackScoreBatchItem) encodeFields(e *jx.Encoder) {
	{
		if s.ProjectName.Set {
			e.FieldStart("project_name")
			s.ProjectName.Encode(e)
		}
	}
	{
		if s.ProjectID.Set {
			e.FieldStart("project_id")
			s.ProjectID.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.CategoryName.Set {
			e.FieldStart("category_name")
			s.CategoryName.Encode(e)
		}
	}
	{
		e.FieldStart("value")
		e.Float64(s.Value)
	}
	{
		if s.Reason.Set {
			e.FieldStart("reason")
			s.Reason.Encode(e)
		}
	}
	{
		e.FieldStart("source")
		s.Source.Encode(e)
	}
	{
		if s.Author.Set {
			e.FieldStart("author")
			s.Author.Encode(e)
		}
	}
	{
		e.FieldStart("id")
		json.EncodeUUID(e, s.ID)
	}
}

var jsonFieldsNameOfFeedbackScoreBatchItem = [9]string{
	0: "project_name",
	1: "project_id",
	2: "name",
	3: "category_name",
	4: "value",
	5: "reason",
	6: "source",
	7: "author",
	8: "id",
}

// Decode decodes FeedbackScoreBatchItem from json.
func (s *FeedbackScoreBatchItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FeedbackScoreBatchItem to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "project_name":
			if err := func() error {
				s.ProjectName.Reset()
				if err := s.ProjectName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"project_name\"")
			}
		case "project_id":
			if err := func() error {
				s.ProjectID.Reset()
				if err := s.ProjectID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"project_id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "category_name":
			if err := func() error {
				s.CategoryName.Reset()
				if err := s.CategoryName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"category_name\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Float64()
				s.Value = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "source":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Source.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		case "author":
			if err := func() error {
				s.Author.Reset()
				if err := s.Author.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"author\"")
			}
		case "id":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FeedbackScoreBatchItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01010100,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFeedbackScoreBatchItem) {
					name = jsonFieldsNameOfFeedbackScoreBatchItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FeedbackScoreBatchItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FeedbackScoreBatchItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FeedbackScoreBatchItemSource as json.
func (s FeedbackScoreBatchItemSource) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes FeedbackScoreBatchItemSource from json.
func (s *FeedbackScoreBatchItemSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FeedbackScoreBatchItemSource to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch FeedbackScoreBatchItemSource(v) {
	case FeedbackScoreBatchItemSourceUI:
		*s = FeedbackScoreBatchItemSourceUI
	case FeedbackScoreBatchItemSourceSdk:
		*s = FeedbackScoreBatchItemSourceSdk
	case FeedbackScoreBatchItemSourceOnlineScoring:
		*s = FeedbackScoreBatchItemSourceOnlineScoring
	default:
		*s = FeedbackScoreBatchItemSource(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FeedbackScoreBatchItemSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FeedbackScoreBatchItemSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FeedbackScoreBatchItemThread) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FeedbackScoreBatchItemThread) encodeFields(e *jx.Encoder) {
	{
		if s.ProjectName.Set {
			e.FieldStart("project_name")
			s.ProjectName.Encode(e)
		}
	}
	{
		if s.ProjectID.Set {
			e.FieldStart("project_id")
			s.ProjectID.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.CategoryName.Set {
			e.FieldStart("category_name")
			s.CategoryName.Encode(e)
		}
	}
	{
		e.FieldStart("value")
		e.Float64(s.Value)
	}
	{
		if s.Reason.Set {
			e.FieldStart("reason")
			s.Reason.Encode(e)
		}
	}
	{
		e.FieldStart("source")
		s.Source.Encode(e)
	}
	{
		if s.Author.Set {
			e.FieldStart("author")
			s.Author.Encode(e)
		}
	}
	{
		e.FieldStart("thread_id")
		e.Str(s.ThreadID)
	}
}

var jsonFieldsNameOfFeedbackScoreBatchItemThread = [9]string{
	0: "project_name",
	1: "project_id",
	2: "name",
	3: "category_name",
	4: "value",
	5: "reason",
	6: "source",
	7: "author",
	8: "thread_id",
}

// Decode decodes FeedbackScoreBatchItemThread from json.
func (s *FeedbackScoreBatchItemThread) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FeedbackScoreBatchItemThread to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "project_name":
			if err := func() error {
				s.ProjectName.Reset()
				if err := s.ProjectName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"project_name\"")
			}
		case "project_id":
			if err := func() error {
				s.ProjectID.Reset()
				if err := s.ProjectID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"project_id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "category_name":
			if err := func() error {
				s.CategoryName.Reset()
				if err := s.CategoryName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"category_name\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Float64()
				s.Value = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "source":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Source.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		case "author":
			if err := func() error {
				s.Author.Reset()
				if err := s.Author.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"author\"")
			}
		case "thread_id":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ThreadID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thread_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FeedbackScoreBatchItemThread")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01010100,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFeedbackScoreBatchItemThread) {
					name = jsonFieldsNameOfFeedbackScoreBatchItemThread[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FeedbackScoreBatchItemThread) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FeedbackScoreBatchItemThread) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FeedbackScoreBatchItemThreadSource as json.
func (s FeedbackScoreBatchItemThreadSource) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes FeedbackScoreBatchItemThreadSource from json.
func (s *FeedbackScoreBatchItemThreadSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FeedbackScoreBatchItemThreadSource to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch FeedbackScoreBatchItemThreadSource(v) {
	case FeedbackScoreBatchItemThreadSourceUI:
		*s = FeedbackScoreBatchItemThreadSourceUI
	case FeedbackScoreBatchItemThreadSourceSdk:
		*s = FeedbackScoreBatchItemThreadSourceSdk
	case FeedbackScoreBatchItemThreadSourceOnlineScoring:
		*s = FeedbackScoreBatchItemThreadSourceOnlineScoring
	default:
		*s = FeedbackScoreBatchItemThreadSource(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FeedbackScoreBatchItemThreadSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FeedbackScoreBatchItemThreadSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FeedbackScoreBatchThread) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FeedbackScoreBatchThread) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("scores")
		e.ArrStart()
		for _, elem := range s.Scores {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfFeedbackScoreBatchThread = [1]string{
	0: "scores",
}

// Decode decodes FeedbackScoreBatchThread from json.
func (s *FeedbackScoreBatchThread) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FeedbackScoreBatchThread to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "scores":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Scores = make([]FeedbackScoreBatchItemThread, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem FeedbackScoreBatchItemThread
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Scores = append(s.Scores, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scores\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FeedbackScoreBatchThread")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFeedbackScoreBatchThread) {
					name = jsonFieldsNameOfFeedbackScoreBatchThread[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FeedbackScoreBatchThread) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FeedbackScoreBatchThread) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FeedbackScoreCompare) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FeedbackScoreCompare) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.CategoryName.Set {
			e.FieldStart("category_name")
			s.CategoryName.Encode(e)
		}
	}
	{
		e.FieldStart("value")
		e.Float64(s.Value)
	}
	{
		if s.Reason.Set {
			e.FieldStart("reason")
			s.Reason.Encode(e)
		}
	}
	{
		e.FieldStart("source")
		s.Source.Encode(e)
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.LastUpdatedAt.Set {
			e.FieldStart("last_updated_at")
			s.LastUpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.CreatedBy.Set {
			e.FieldStart("created_by")
			s.CreatedBy.Encode(e)
		}
	}
	{
		if s.LastUpdatedBy.Set {
			e.FieldStart("last_updated_by")
			s.LastUpdatedBy.Encode(e)
		}
	}
	{
		if s.ValueByAuthor.Set {
			e.FieldStart("value_by_author")
			s.ValueByAuthor.Encode(e)
		}
	}
}

var jsonFieldsNameOfFeedbackScoreCompare = [10]string{
	0: "name",
	1: "category_name",
	2: "value",
	3: "reason",
	4: "source",
	5: "created_at",
	6: "last_updated_at",
	7: "created_by",
	8: "last_updated_by",
	9: "value_by_author",
}

// Decode decodes FeedbackScoreCompare from json.
func (s *FeedbackScoreCompare) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FeedbackScoreCompare to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "category_name":
			if err := func() error {
				s.CategoryName.Reset()
				if err := s.CategoryName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"category_name\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float64()
				s.Value = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "source":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Source.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "last_updated_at":
			if err := func() error {
				s.LastUpdatedAt.Reset()
				if err := s.LastUpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated_at\"")
			}
		case "created_by":
			if err := func() error {
				s.CreatedBy.Reset()
				if err := s.CreatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_by\"")
			}
		case "last_updated_by":
			if err := func() error {
				s.LastUpdatedBy.Reset()
				if err := s.LastUpdatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated_by\"")
			}
		case "value_by_author":
			if err := func() error {
				s.ValueByAuthor.Reset()
				if err := s.ValueByAuthor.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value_by_author\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FeedbackScoreCompare")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00010101,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFeedbackScoreCompare) {
					name = jsonFieldsNameOfFeedbackScoreCompare[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FeedbackScoreCompare) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FeedbackScoreCompare) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FeedbackScoreCompareSource as json.
func (s FeedbackScoreCompareSource) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes FeedbackScoreCompareSource from json.
func (s *FeedbackScoreCompareSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FeedbackScoreCompareSource to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch FeedbackScoreCompareSource(v) {
	case FeedbackScoreCompareSourceUI:
		*s = FeedbackScoreCompareSourceUI
	case FeedbackScoreCompareSourceSdk:
		*s = FeedbackScoreCompareSourceSdk
	case FeedbackScoreCompareSourceOnlineScoring:
		*s = FeedbackScoreCompareSourceOnlineScoring
	default:
		*s = FeedbackScoreCompareSource(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FeedbackScoreCompareSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FeedbackScoreCompareSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s FeedbackScoreCompareValueByAuthor) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s FeedbackScoreCompareValueByAuthor) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes FeedbackScoreCompareValueByAuthor from json.
func (s *FeedbackScoreCompareValueByAuthor) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FeedbackScoreCompareValueByAuthor to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem ValueEntryCompare
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FeedbackScoreCompareValueByAuthor")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FeedbackScoreCompareValueByAuthor) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FeedbackScoreCompareValueByAuthor) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FeedbackScoreExperimentItemBulkWriteView) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FeedbackScoreExperimentItemBulkWriteView) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.CategoryName.Set {
			e.FieldStart("category_name")
			s.CategoryName.Encode(e)
		}
	}
	{
		e.FieldStart("value")
		e.Float64(s.Value)
	}
	{
		if s.Reason.Set {
			e.FieldStart("reason")
			s.Reason.Encode(e)
		}
	}
	{
		e.FieldStart("source")
		s.Source.Encode(e)
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.LastUpdatedAt.Set {
			e.FieldStart("last_updated_at")
			s.LastUpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.CreatedBy.Set {
			e.FieldStart("created_by")
			s.CreatedBy.Encode(e)
		}
	}
	{
		if s.LastUpdatedBy.Set {
			e.FieldStart("last_updated_by")
			s.LastUpdatedBy.Encode(e)
		}
	}
	{
		if s.ValueByAuthor.Set {
			e.FieldStart("value_by_author")
			s.ValueByAuthor.Encode(e)
		}
	}
}

var jsonFieldsNameOfFeedbackScoreExperimentItemBulkWriteView = [10]string{
	0: "name",
	1: "category_name",
	2: "value",
	3: "reason",
	4: "source",
	5: "created_at",
	6: "last_updated_at",
	7: "created_by",
	8: "last_updated_by",
	9: "value_by_author",
}

// Decode decodes FeedbackScoreExperimentItemBulkWriteView from json.
func (s *FeedbackScoreExperimentItemBulkWriteView) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FeedbackScoreExperimentItemBulkWriteView to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "category_name":
			if err := func() error {
				s.CategoryName.Reset()
				if err := s.CategoryName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"category_name\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float64()
				s.Value = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "source":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Source.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "last_updated_at":
			if err := func() error {
				s.LastUpdatedAt.Reset()
				if err := s.LastUpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated_at\"")
			}
		case "created_by":
			if err := func() error {
				s.CreatedBy.Reset()
				if err := s.CreatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_by\"")
			}
		case "last_updated_by":
			if err := func() error {
				s.LastUpdatedBy.Reset()
				if err := s.LastUpdatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated_by\"")
			}
		case "value_by_author":
			if err := func() error {
				s.ValueByAuthor.Reset()
				if err := s.ValueByAuthor.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value_by_author\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FeedbackScoreExperimentItemBulkWriteView")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00010101,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFeedbackScoreExperimentItemBulkWriteView) {
					name = jsonFieldsNameOfFeedbackScoreExperimentItemBulkWriteView[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FeedbackScoreExperimentItemBulkWriteView) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FeedbackScoreExperimentItemBulkWriteView) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FeedbackScoreExperimentItemBulkWriteViewSource as json.
func (s FeedbackScoreExperimentItemBulkWriteViewSource) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes FeedbackScoreExperimentItemBulkWriteViewSource from json.
func (s *FeedbackScoreExperimentItemBulkWriteViewSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FeedbackScoreExperimentItemBulkWriteViewSource to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch FeedbackScoreExperimentItemBulkWriteViewSource(v) {
	case FeedbackScoreExperimentItemBulkWriteViewSourceUI:
		*s = FeedbackScoreExperimentItemBulkWriteViewSourceUI
	case FeedbackScoreExperimentItemBulkWriteViewSourceSdk:
		*s = FeedbackScoreExperimentItemBulkWriteViewSourceSdk
	case FeedbackScoreExperimentItemBulkWriteViewSourceOnlineScoring:
		*s = FeedbackScoreExperimentItemBulkWriteViewSourceOnlineScoring
	default:
		*s = FeedbackScoreExperimentItemBulkWriteViewSource(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FeedbackScoreExperimentItemBulkWriteViewSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FeedbackScoreExperimentItemBulkWriteViewSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s FeedbackScoreExperimentItemBulkWriteViewValueByAuthor) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s FeedbackScoreExperimentItemBulkWriteViewValueByAuthor) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes FeedbackScoreExperimentItemBulkWriteViewValueByAuthor from json.
func (s *FeedbackScoreExperimentItemBulkWriteViewValueByAuthor) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FeedbackScoreExperimentItemBulkWriteViewValueByAuthor to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem ValueEntryExperimentItemBulkWriteView
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FeedbackScoreExperimentItemBulkWriteViewValueByAuthor")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FeedbackScoreExperimentItemBulkWriteViewValueByAuthor) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FeedbackScoreExperimentItemBulkWriteViewValueByAuthor) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FeedbackScoreNames) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FeedbackScoreNames) encodeFields(e *jx.Encoder) {
	{
		if s.Scores != nil {
			e.FieldStart("scores")
			e.ArrStart()
			for _, elem := range s.Scores {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfFeedbackScoreNames = [1]string{
	0: "scores",
}

// Decode decodes FeedbackScoreNames from json.
func (s *FeedbackScoreNames) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FeedbackScoreNames to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "scores":
			if err := func() error {
				s.Scores = make([]ScoreName, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ScoreName
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Scores = append(s.Scores, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scores\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FeedbackScoreNames")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FeedbackScoreNames) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FeedbackScoreNames) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FeedbackScorePublic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FeedbackScorePublic) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.CategoryName.Set {
			e.FieldStart("category_name")
			s.CategoryName.Encode(e)
		}
	}
	{
		e.FieldStart("value")
		e.Float64(s.Value)
	}
	{
		if s.Reason.Set {
			e.FieldStart("reason")
			s.Reason.Encode(e)
		}
	}
	{
		e.FieldStart("source")
		s.Source.Encode(e)
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.LastUpdatedAt.Set {
			e.FieldStart("last_updated_at")
			s.LastUpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.CreatedBy.Set {
			e.FieldStart("created_by")
			s.CreatedBy.Encode(e)
		}
	}
	{
		if s.LastUpdatedBy.Set {
			e.FieldStart("last_updated_by")
			s.LastUpdatedBy.Encode(e)
		}
	}
	{
		if s.ValueByAuthor.Set {
			e.FieldStart("value_by_author")
			s.ValueByAuthor.Encode(e)
		}
	}
}

var jsonFieldsNameOfFeedbackScorePublic = [10]string{
	0: "name",
	1: "category_name",
	2: "value",
	3: "reason",
	4: "source",
	5: "created_at",
	6: "last_updated_at",
	7: "created_by",
	8: "last_updated_by",
	9: "value_by_author",
}

// Decode decodes FeedbackScorePublic from json.
func (s *FeedbackScorePublic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FeedbackScorePublic to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "category_name":
			if err := func() error {
				s.CategoryName.Reset()
				if err := s.CategoryName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"category_name\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float64()
				s.Value = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "source":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Source.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "last_updated_at":
			if err := func() error {
				s.LastUpdatedAt.Reset()
				if err := s.LastUpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated_at\"")
			}
		case "created_by":
			if err := func() error {
				s.CreatedBy.Reset()
				if err := s.CreatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_by\"")
			}
		case "last_updated_by":
			if err := func() error {
				s.LastUpdatedBy.Reset()
				if err := s.LastUpdatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated_by\"")
			}
		case "value_by_author":
			if err := func() error {
				s.ValueByAuthor.Reset()
				if err := s.ValueByAuthor.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value_by_author\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FeedbackScorePublic")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00010101,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFeedbackScorePublic) {
					name = jsonFieldsNameOfFeedbackScorePublic[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FeedbackScorePublic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FeedbackScorePublic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FeedbackScorePublicSource as json.
func (s FeedbackScorePublicSource) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes FeedbackScorePublicSource from json.
func (s *FeedbackScorePublicSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FeedbackScorePublicSource to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch FeedbackScorePublicSource(v) {
	case FeedbackScorePublicSourceUI:
		*s = FeedbackScorePublicSourceUI
	case FeedbackScorePublicSourceSdk:
		*s = FeedbackScorePublicSourceSdk
	case FeedbackScorePublicSourceOnlineScoring:
		*s = FeedbackScorePublicSourceOnlineScoring
	default:
		*s = FeedbackScorePublicSource(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FeedbackScorePublicSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FeedbackScorePublicSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s FeedbackScorePublicValueByAuthor) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s FeedbackScorePublicValueByAuthor) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes FeedbackScorePublicValueByAuthor from json.
func (s *FeedbackScorePublicValueByAuthor) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FeedbackScorePublicValueByAuthor to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem ValueEntryPublic
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FeedbackScorePublicValueByAuthor")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FeedbackScorePublicValueByAuthor) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FeedbackScorePublicValueByAuthor) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FeedbackScoreSource as json.
func (s FeedbackScoreSource) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes FeedbackScoreSource from json.
func (s *FeedbackScoreSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FeedbackScoreSource to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch FeedbackScoreSource(v) {
	case FeedbackScoreSourceUI:
		*s = FeedbackScoreSourceUI
	case FeedbackScoreSourceSdk:
		*s = FeedbackScoreSourceSdk
	case FeedbackScoreSourceOnlineScoring:
		*s = FeedbackScoreSourceOnlineScoring
	default:
		*s = FeedbackScoreSource(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FeedbackScoreSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FeedbackScoreSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s FeedbackScoreValueByAuthor) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s FeedbackScoreValueByAuthor) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes FeedbackScoreValueByAuthor from json.
func (s *FeedbackScoreValueByAuthor) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FeedbackScoreValueByAuthor to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem ValueEntry
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FeedbackScoreValueByAuthor")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FeedbackScoreValueByAuthor) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FeedbackScoreValueByAuthor) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FeedbackUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FeedbackUpdate) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
}

var jsonFieldsNameOfFeedbackUpdate = [4]string{
	0: "id",
	1: "name",
	2: "description",
	3: "type",
}

// Decode decodes FeedbackUpdate from json.
func (s *FeedbackUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FeedbackUpdate to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FeedbackUpdate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFeedbackUpdate) {
					name = jsonFieldsNameOfFeedbackUpdate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FeedbackUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FeedbackUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FeedbackUpdateType as json.
func (s FeedbackUpdateType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes FeedbackUpdateType from json.
func (s *FeedbackUpdateType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FeedbackUpdateType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch FeedbackUpdateType(v) {
	case FeedbackUpdateTypeNumerical:
		*s = FeedbackUpdateTypeNumerical
	case FeedbackUpdateTypeCategorical:
		*s = FeedbackUpdateTypeCategorical
	case FeedbackUpdateTypeBoolean:
		*s = FeedbackUpdateTypeBoolean
	default:
		*s = FeedbackUpdateType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FeedbackUpdateType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FeedbackUpdateType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Function) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Function) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Strict.Set {
			e.FieldStart("strict")
			s.Strict.Encode(e)
		}
	}
	{
		if s.Parameters.Set {
			e.FieldStart("parameters")
			s.Parameters.Encode(e)
		}
	}
}

var jsonFieldsNameOfFunction = [4]string{
	0: "name",
	1: "description",
	2: "strict",
	3: "parameters",
}

// Decode decodes Function from json.
func (s *Function) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Function to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "strict":
			if err := func() error {
				s.Strict.Reset()
				if err := s.Strict.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"strict\"")
			}
		case "parameters":
			if err := func() error {
				s.Parameters.Reset()
				if err := s.Parameters.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parameters\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Function")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Function) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Function) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FunctionCall) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FunctionCall) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Arguments.Set {
			e.FieldStart("arguments")
			s.Arguments.Encode(e)
		}
	}
}

var jsonFieldsNameOfFunctionCall = [2]string{
	0: "name",
	1: "arguments",
}

// Decode decodes FunctionCall from json.
func (s *FunctionCall) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FunctionCall to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "arguments":
			if err := func() error {
				s.Arguments.Reset()
				if err := s.Arguments.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"arguments\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FunctionCall")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FunctionCall) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FunctionCall) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s FunctionParameters) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s FunctionParameters) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes FunctionParameters from json.
func (s *FunctionParameters) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FunctionParameters to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem FunctionParametersItem
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FunctionParameters")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FunctionParameters) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FunctionParameters) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FunctionParametersItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FunctionParametersItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfFunctionParametersItem = [0]string{}

// Decode decodes FunctionParametersItem from json.
func (s *FunctionParametersItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FunctionParametersItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode FunctionParametersItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FunctionParametersItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FunctionParametersItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetProjectMetricsBadRequest as json.
func (s *GetProjectMetricsBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessagePublic)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetProjectMetricsBadRequest from json.
func (s *GetProjectMetricsBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetProjectMetricsBadRequest to nil")
	}
	var unwrapped ErrorMessagePublic
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetProjectMetricsBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetProjectMetricsBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetProjectMetricsBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetProjectMetricsNotFound as json.
func (s *GetProjectMetricsNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessagePublic)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetProjectMetricsNotFound from json.
func (s *GetProjectMetricsNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetProjectMetricsNotFound to nil")
	}
	var unwrapped ErrorMessagePublic
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetProjectMetricsNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetProjectMetricsNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetProjectMetricsNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetSpanByIdNotFound as json.
func (s *GetSpanByIdNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*SpanPublic)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetSpanByIdNotFound from json.
func (s *GetSpanByIdNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSpanByIdNotFound to nil")
	}
	var unwrapped SpanPublic
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetSpanByIdNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSpanByIdNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSpanByIdNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetSpanByIdOK as json.
func (s *GetSpanByIdOK) Encode(e *jx.Encoder) {
	unwrapped := (*SpanPublic)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetSpanByIdOK from json.
func (s *GetSpanByIdOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSpanByIdOK to nil")
	}
	var unwrapped SpanPublic
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetSpanByIdOK(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSpanByIdOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSpanByIdOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetWorkspaceNameForbidden as json.
func (s *GetWorkspaceNameForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessage)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetWorkspaceNameForbidden from json.
func (s *GetWorkspaceNameForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetWorkspaceNameForbidden to nil")
	}
	var unwrapped ErrorMessage
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetWorkspaceNameForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetWorkspaceNameForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetWorkspaceNameForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetWorkspaceNameUnauthorized as json.
func (s *GetWorkspaceNameUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessage)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetWorkspaceNameUnauthorized from json.
func (s *GetWorkspaceNameUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetWorkspaceNameUnauthorized to nil")
	}
	var unwrapped ErrorMessage
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetWorkspaceNameUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetWorkspaceNameUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetWorkspaceNameUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GroupContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GroupContent) encodeFields(e *jx.Encoder) {
	{
		if s.Label.Set {
			e.FieldStart("label")
			s.Label.Encode(e)
		}
	}
}

var jsonFieldsNameOfGroupContent = [1]string{
	0: "label",
}

// Decode decodes GroupContent from json.
func (s *GroupContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GroupContent to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "label":
			if err := func() error {
				s.Label.Reset()
				if err := s.Label.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"label\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GroupContent")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GroupContent) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GroupContent) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GroupContentWithAggregations) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GroupContentWithAggregations) encodeFields(e *jx.Encoder) {
	{
		if s.Label.Set {
			e.FieldStart("label")
			s.Label.Encode(e)
		}
	}
	{
		if s.Aggregations.Set {
			e.FieldStart("aggregations")
			s.Aggregations.Encode(e)
		}
	}
}

var jsonFieldsNameOfGroupContentWithAggregations = [2]string{
	0: "label",
	1: "aggregations",
}

// Decode decodes GroupContentWithAggregations from json.
func (s *GroupContentWithAggregations) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GroupContentWithAggregations to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "label":
			if err := func() error {
				s.Label.Reset()
				if err := s.Label.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"label\"")
			}
		case "aggregations":
			if err := func() error {
				s.Aggregations.Reset()
				if err := s.Aggregations.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"aggregations\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GroupContentWithAggregations")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GroupContentWithAggregations) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GroupContentWithAggregations) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GroupDetail) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GroupDetail) encodeFields(e *jx.Encoder) {
	{
		if s.GroupSorting != nil {
			e.FieldStart("group_sorting")
			e.ArrStart()
			for _, elem := range s.GroupSorting {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfGroupDetail = [1]string{
	0: "group_sorting",
}

// Decode decodes GroupDetail from json.
func (s *GroupDetail) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GroupDetail to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "group_sorting":
			if err := func() error {
				s.GroupSorting = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.GroupSorting = append(s.GroupSorting, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"group_sorting\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GroupDetail")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GroupDetail) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GroupDetail) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GroupDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GroupDetails) encodeFields(e *jx.Encoder) {
	{
		if s.GroupsDetails != nil {
			e.FieldStart("groups_details")
			e.ArrStart()
			for _, elem := range s.GroupsDetails {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfGroupDetails = [1]string{
	0: "groups_details",
}

// Decode decodes GroupDetails from json.
func (s *GroupDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GroupDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "groups_details":
			if err := func() error {
				s.GroupsDetails = make([]GroupDetail, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GroupDetail
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.GroupsDetails = append(s.GroupsDetails, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"groups_details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GroupDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GroupDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GroupDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GuardrailBatchWrite) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GuardrailBatchWrite) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("guardrails")
		e.ArrStart()
		for _, elem := range s.Guardrails {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGuardrailBatchWrite = [1]string{
	0: "guardrails",
}

// Decode decodes GuardrailBatchWrite from json.
func (s *GuardrailBatchWrite) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GuardrailBatchWrite to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "guardrails":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Guardrails = make([]GuardrailWrite, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GuardrailWrite
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Guardrails = append(s.Guardrails, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"guardrails\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GuardrailBatchWrite")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGuardrailBatchWrite) {
					name = jsonFieldsNameOfGuardrailBatchWrite[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GuardrailBatchWrite) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GuardrailBatchWrite) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GuardrailWrite) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GuardrailWrite) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("entity_id")
		json.EncodeUUID(e, s.EntityID)
	}
	{
		e.FieldStart("secondary_id")
		json.EncodeUUID(e, s.SecondaryID)
	}
	{
		if s.ProjectName.Set {
			e.FieldStart("project_name")
			s.ProjectName.Encode(e)
		}
	}
	{
		if s.ProjectID.Set {
			e.FieldStart("project_id")
			s.ProjectID.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	{
		e.FieldStart("result")
		s.Result.Encode(e)
	}
	{
		e.FieldStart("config")
		s.Config.Encode(e)
	}
	{
		e.FieldStart("details")
		s.Details.Encode(e)
	}
}

var jsonFieldsNameOfGuardrailWrite = [8]string{
	0: "entity_id",
	1: "secondary_id",
	2: "project_name",
	3: "project_id",
	4: "name",
	5: "result",
	6: "config",
	7: "details",
}

// Decode decodes GuardrailWrite from json.
func (s *GuardrailWrite) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GuardrailWrite to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "entity_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.EntityID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"entity_id\"")
			}
		case "secondary_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.SecondaryID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secondary_id\"")
			}
		case "project_name":
			if err := func() error {
				s.ProjectName.Reset()
				if err := s.ProjectName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"project_name\"")
			}
		case "project_id":
			if err := func() error {
				s.ProjectID.Reset()
				if err := s.ProjectID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"project_id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "result":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Result.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		case "config":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Config.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"config\"")
			}
		case "details":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Details.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GuardrailWrite")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11110011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGuardrailWrite) {
					name = jsonFieldsNameOfGuardrailWrite[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GuardrailWrite) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GuardrailWrite) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GuardrailWriteName as json.
func (s GuardrailWriteName) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GuardrailWriteName from json.
func (s *GuardrailWriteName) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GuardrailWriteName to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GuardrailWriteName(v) {
	case GuardrailWriteNameTOPIC:
		*s = GuardrailWriteNameTOPIC
	case GuardrailWriteNamePII:
		*s = GuardrailWriteNamePII
	default:
		*s = GuardrailWriteName(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GuardrailWriteName) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GuardrailWriteName) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GuardrailWriteResult as json.
func (s GuardrailWriteResult) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GuardrailWriteResult from json.
func (s *GuardrailWriteResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GuardrailWriteResult to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GuardrailWriteResult(v) {
	case GuardrailWriteResultPassed:
		*s = GuardrailWriteResultPassed
	case GuardrailWriteResultFailed:
		*s = GuardrailWriteResultFailed
	default:
		*s = GuardrailWriteResult(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GuardrailWriteResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GuardrailWriteResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GuardrailsValidationPublic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GuardrailsValidationPublic) encodeFields(e *jx.Encoder) {
	{
		if s.SpanID.Set {
			e.FieldStart("span_id")
			s.SpanID.Encode(e)
		}
	}
	{
		if s.Checks != nil {
			e.FieldStart("checks")
			e.ArrStart()
			for _, elem := range s.Checks {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfGuardrailsValidationPublic = [2]string{
	0: "span_id",
	1: "checks",
}

// Decode decodes GuardrailsValidationPublic from json.
func (s *GuardrailsValidationPublic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GuardrailsValidationPublic to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "span_id":
			if err := func() error {
				s.SpanID.Reset()
				if err := s.SpanID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"span_id\"")
			}
		case "checks":
			if err := func() error {
				s.Checks = make([]CheckPublic, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CheckPublic
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Checks = append(s.Checks, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"checks\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GuardrailsValidationPublic")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GuardrailsValidationPublic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GuardrailsValidationPublic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes JsonListString as json.
func (s JsonListString) Encode(e *jx.Encoder) {
	unwrapped := jx.Raw(s)

	if len(unwrapped) != 0 {
		e.Raw(unwrapped)
	}
}

// Decode decodes JsonListString from json.
func (s *JsonListString) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode JsonListString to nil")
	}
	var unwrapped jx.Raw
	if err := func() error {
		v, err := d.RawAppend(nil)
		unwrapped = jx.Raw(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = JsonListString(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s JsonListString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *JsonListString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes JsonListStringCompare as json.
func (s JsonListStringCompare) Encode(e *jx.Encoder) {
	unwrapped := jx.Raw(s)

	if len(unwrapped) != 0 {
		e.Raw(unwrapped)
	}
}

// Decode decodes JsonListStringCompare from json.
func (s *JsonListStringCompare) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode JsonListStringCompare to nil")
	}
	var unwrapped jx.Raw
	if err := func() error {
		v, err := d.RawAppend(nil)
		unwrapped = jx.Raw(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = JsonListStringCompare(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s JsonListStringCompare) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *JsonListStringCompare) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes JsonListStringExperimentItemBulkWriteView as json.
func (s JsonListStringExperimentItemBulkWriteView) Encode(e *jx.Encoder) {
	unwrapped := jx.Raw(s)

	if len(unwrapped) != 0 {
		e.Raw(unwrapped)
	}
}

// Decode decodes JsonListStringExperimentItemBulkWriteView from json.
func (s *JsonListStringExperimentItemBulkWriteView) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode JsonListStringExperimentItemBulkWriteView to nil")
	}
	var unwrapped jx.Raw
	if err := func() error {
		v, err := d.RawAppend(nil)
		unwrapped = jx.Raw(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = JsonListStringExperimentItemBulkWriteView(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s JsonListStringExperimentItemBulkWriteView) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *JsonListStringExperimentItemBulkWriteView) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes JsonListStringPublic as json.
func (s JsonListStringPublic) Encode(e *jx.Encoder) {
	unwrapped := jx.Raw(s)

	if len(unwrapped) != 0 {
		e.Raw(unwrapped)
	}
}

// Decode decodes JsonListStringPublic from json.
func (s *JsonListStringPublic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode JsonListStringPublic to nil")
	}
	var unwrapped jx.Raw
	if err := func() error {
		v, err := d.RawAppend(nil)
		unwrapped = jx.Raw(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = JsonListStringPublic(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s JsonListStringPublic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *JsonListStringPublic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes JsonListStringWrite as json.
func (s JsonListStringWrite) Encode(e *jx.Encoder) {
	unwrapped := jx.Raw(s)

	if len(unwrapped) != 0 {
		e.Raw(unwrapped)
	}
}

// Decode decodes JsonListStringWrite from json.
func (s *JsonListStringWrite) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode JsonListStringWrite to nil")
	}
	var unwrapped jx.Raw
	if err := func() error {
		v, err := d.RawAppend(nil)
		unwrapped = jx.Raw(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = JsonListStringWrite(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s JsonListStringWrite) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *JsonListStringWrite) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s JsonNode) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s JsonNode) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes JsonNode from json.
func (s *JsonNode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode JsonNode to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode JsonNode")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s JsonNode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *JsonNode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s JsonNodeDetail) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s JsonNodeDetail) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes JsonNodeDetail from json.
func (s *JsonNodeDetail) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode JsonNodeDetail to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode JsonNodeDetail")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s JsonNodeDetail) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *JsonNodeDetail) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s JsonNodePublic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s JsonNodePublic) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes JsonNodePublic from json.
func (s *JsonNodePublic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode JsonNodePublic to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode JsonNodePublic")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s JsonNodePublic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *JsonNodePublic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s JsonNodeWrite) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s JsonNodeWrite) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes JsonNodeWrite from json.
func (s *JsonNodeWrite) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode JsonNodeWrite to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode JsonNodeWrite")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s JsonNodeWrite) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *JsonNodeWrite) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *JsonSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *JsonSchema) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Strict.Set {
			e.FieldStart("strict")
			s.Strict.Encode(e)
		}
	}
	{
		if s.Schema.Set {
			e.FieldStart("schema")
			s.Schema.Encode(e)
		}
	}
}

var jsonFieldsNameOfJsonSchema = [3]string{
	0: "name",
	1: "strict",
	2: "schema",
}

// Decode decodes JsonSchema from json.
func (s *JsonSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode JsonSchema to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "strict":
			if err := func() error {
				s.Strict.Reset()
				if err := s.Strict.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"strict\"")
			}
		case "schema":
			if err := func() error {
				s.Schema.Reset()
				if err := s.Schema.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"schema\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode JsonSchema")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *JsonSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *JsonSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s JsonSchemaSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s JsonSchemaSchema) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes JsonSchemaSchema from json.
func (s *JsonSchemaSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode JsonSchemaSchema to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem JsonSchemaSchemaItem
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode JsonSchemaSchema")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s JsonSchemaSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *JsonSchemaSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *JsonSchemaSchemaItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *JsonSchemaSchemaItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfJsonSchemaSchemaItem = [0]string{}

// Decode decodes JsonSchemaSchemaItem from json.
func (s *JsonSchemaSchemaItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode JsonSchemaSchemaItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode JsonSchemaSchemaItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *JsonSchemaSchemaItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *JsonSchemaSchemaItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LogItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LogItem) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.RuleID.Set {
			e.FieldStart("rule_id")
			s.RuleID.Encode(e)
		}
	}
	{
		if s.Level.Set {
			e.FieldStart("level")
			s.Level.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.Markers.Set {
			e.FieldStart("markers")
			s.Markers.Encode(e)
		}
	}
}

var jsonFieldsNameOfLogItem = [5]string{
	0: "timestamp",
	1: "rule_id",
	2: "level",
	3: "message",
	4: "markers",
}

// Decode decodes LogItem from json.
func (s *LogItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LogItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "rule_id":
			if err := func() error {
				s.RuleID.Reset()
				if err := s.RuleID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rule_id\"")
			}
		case "level":
			if err := func() error {
				s.Level.Reset()
				if err := s.Level.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "markers":
			if err := func() error {
				s.Markers.Reset()
				if err := s.Markers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"markers\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LogItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LogItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LogItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LogItemLevel as json.
func (s LogItemLevel) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes LogItemLevel from json.
func (s *LogItemLevel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LogItemLevel to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch LogItemLevel(v) {
	case LogItemLevelINFO:
		*s = LogItemLevelINFO
	case LogItemLevelWARN:
		*s = LogItemLevelWARN
	case LogItemLevelERROR:
		*s = LogItemLevelERROR
	case LogItemLevelDEBUG:
		*s = LogItemLevelDEBUG
	case LogItemLevelTRACE:
		*s = LogItemLevelTRACE
	default:
		*s = LogItemLevel(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s LogItemLevel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LogItemLevel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s LogItemMarkers) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s LogItemMarkers) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes LogItemMarkers from json.
func (s *LogItemMarkers) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LogItemMarkers to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LogItemMarkers")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s LogItemMarkers) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LogItemMarkers) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LogPage) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LogPage) encodeFields(e *jx.Encoder) {
	{
		if s.Content != nil {
			e.FieldStart("content")
			e.ArrStart()
			for _, elem := range s.Content {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Page.Set {
			e.FieldStart("page")
			s.Page.Encode(e)
		}
	}
	{
		if s.Size.Set {
			e.FieldStart("size")
			s.Size.Encode(e)
		}
	}
	{
		if s.Total.Set {
			e.FieldStart("total")
			s.Total.Encode(e)
		}
	}
}

var jsonFieldsNameOfLogPage = [4]string{
	0: "content",
	1: "page",
	2: "size",
	3: "total",
}

// Decode decodes LogPage from json.
func (s *LogPage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LogPage to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "content":
			if err := func() error {
				s.Content = make([]LogItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem LogItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Content = append(s.Content, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		case "page":
			if err := func() error {
				s.Page.Reset()
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "size":
			if err := func() error {
				s.Size.Reset()
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "total":
			if err := func() error {
				s.Total.Reset()
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LogPage")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LogPage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LogPage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ManualEvaluationRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ManualEvaluationRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("project_id")
		json.EncodeUUID(e, s.ProjectID)
	}
	{
		e.FieldStart("entity_ids")
		e.ArrStart()
		for _, elem := range s.EntityIds {
			json.EncodeUUID(e, elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("rule_ids")
		e.ArrStart()
		for _, elem := range s.RuleIds {
			json.EncodeUUID(e, elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("entity_type")
		s.EntityType.Encode(e)
	}
}

var jsonFieldsNameOfManualEvaluationRequest = [4]string{
	0: "project_id",
	1: "entity_ids",
	2: "rule_ids",
	3: "entity_type",
}

// Decode decodes ManualEvaluationRequest from json.
func (s *ManualEvaluationRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ManualEvaluationRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "project_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ProjectID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"project_id\"")
			}
		case "entity_ids":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.EntityIds = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.EntityIds = append(s.EntityIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"entity_ids\"")
			}
		case "rule_ids":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.RuleIds = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.RuleIds = append(s.RuleIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rule_ids\"")
			}
		case "entity_type":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.EntityType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"entity_type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ManualEvaluationRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfManualEvaluationRequest) {
					name = jsonFieldsNameOfManualEvaluationRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ManualEvaluationRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ManualEvaluationRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ManualEvaluationRequestEntityType as json.
func (s ManualEvaluationRequestEntityType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ManualEvaluationRequestEntityType from json.
func (s *ManualEvaluationRequestEntityType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ManualEvaluationRequestEntityType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ManualEvaluationRequestEntityType(v) {
	case ManualEvaluationRequestEntityTypeTrace:
		*s = ManualEvaluationRequestEntityTypeTrace
	case ManualEvaluationRequestEntityTypeThread:
		*s = ManualEvaluationRequestEntityTypeThread
	case ManualEvaluationRequestEntityTypeSpan:
		*s = ManualEvaluationRequestEntityTypeSpan
	default:
		*s = ManualEvaluationRequestEntityType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ManualEvaluationRequestEntityType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ManualEvaluationRequestEntityType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ManualEvaluationResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ManualEvaluationResponse) encodeFields(e *jx.Encoder) {
	{
		if s.EntitiesQueued.Set {
			e.FieldStart("entities_queued")
			s.EntitiesQueued.Encode(e)
		}
	}
	{
		if s.RulesApplied.Set {
			e.FieldStart("rules_applied")
			s.RulesApplied.Encode(e)
		}
	}
}

var jsonFieldsNameOfManualEvaluationResponse = [2]string{
	0: "entities_queued",
	1: "rules_applied",
}

// Decode decodes ManualEvaluationResponse from json.
func (s *ManualEvaluationResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ManualEvaluationResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "entities_queued":
			if err := func() error {
				s.EntitiesQueued.Reset()
				if err := s.EntitiesQueued.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"entities_queued\"")
			}
		case "rules_applied":
			if err := func() error {
				s.RulesApplied.Reset()
				if err := s.RulesApplied.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rules_applied\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ManualEvaluationResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ManualEvaluationResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ManualEvaluationResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Message) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Message) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfMessage = [0]string{}

// Decode decodes Message from json.
func (s *Message) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Message to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode Message")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Message) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Message) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MultipartUploadPart) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MultipartUploadPart) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("e_tag")
		e.Str(s.ETag)
	}
	{
		e.FieldStart("part_number")
		e.Int32(s.PartNumber)
	}
}

var jsonFieldsNameOfMultipartUploadPart = [2]string{
	0: "e_tag",
	1: "part_number",
}

// Decode decodes MultipartUploadPart from json.
func (s *MultipartUploadPart) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MultipartUploadPart to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "e_tag":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ETag = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"e_tag\"")
			}
		case "part_number":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.PartNumber = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"part_number\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MultipartUploadPart")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMultipartUploadPart) {
					name = jsonFieldsNameOfMultipartUploadPart[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MultipartUploadPart) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MultipartUploadPart) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AggregationData as json.
func (o OptAggregationData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AggregationData from json.
func (o *OptAggregationData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAggregationData to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAggregationData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAggregationData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AlertPublicAlertType as json.
func (o OptAlertPublicAlertType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AlertPublicAlertType from json.
func (o *OptAlertPublicAlertType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAlertPublicAlertType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAlertPublicAlertType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAlertPublicAlertType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AlertPublicMetadata as json.
func (o OptAlertPublicMetadata) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AlertPublicMetadata from json.
func (o *OptAlertPublicMetadata) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAlertPublicMetadata to nil")
	}
	o.Set = true
	o.Value = make(AlertPublicMetadata)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAlertPublicMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAlertPublicMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AlertTriggerConfigPublicConfigValue as json.
func (o OptAlertTriggerConfigPublicConfigValue) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AlertTriggerConfigPublicConfigValue from json.
func (o *OptAlertTriggerConfigPublicConfigValue) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAlertTriggerConfigPublicConfigValue to nil")
	}
	o.Set = true
	o.Value = make(AlertTriggerConfigPublicConfigValue)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAlertTriggerConfigPublicConfigValue) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAlertTriggerConfigPublicConfigValue) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AlertTriggerConfigWriteConfigValue as json.
func (o OptAlertTriggerConfigWriteConfigValue) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AlertTriggerConfigWriteConfigValue from json.
func (o *OptAlertTriggerConfigWriteConfigValue) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAlertTriggerConfigWriteConfigValue to nil")
	}
	o.Set = true
	o.Value = make(AlertTriggerConfigWriteConfigValue)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAlertTriggerConfigWriteConfigValue) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAlertTriggerConfigWriteConfigValue) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AlertWrite as json.
func (o OptAlertWrite) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AlertWrite from json.
func (o *OptAlertWrite) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAlertWrite to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAlertWrite) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAlertWrite) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AlertWriteAlertType as json.
func (o OptAlertWriteAlertType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AlertWriteAlertType from json.
func (o *OptAlertWriteAlertType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAlertWriteAlertType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAlertWriteAlertType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAlertWriteAlertType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AlertWriteMetadata as json.
func (o OptAlertWriteMetadata) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AlertWriteMetadata from json.
func (o *OptAlertWriteMetadata) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAlertWriteMetadata to nil")
	}
	o.Set = true
	o.Value = make(AlertWriteMetadata)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAlertWriteMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAlertWriteMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AnnotationQueueBatchWrite as json.
func (o OptAnnotationQueueBatchWrite) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AnnotationQueueBatchWrite from json.
func (o *OptAnnotationQueueBatchWrite) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAnnotationQueueBatchWrite to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAnnotationQueueBatchWrite) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAnnotationQueueBatchWrite) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AnnotationQueueItemIds as json.
func (o OptAnnotationQueueItemIds) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AnnotationQueueItemIds from json.
func (o *OptAnnotationQueueItemIds) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAnnotationQueueItemIds to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAnnotationQueueItemIds) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAnnotationQueueItemIds) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AnnotationQueueUpdate as json.
func (o OptAnnotationQueueUpdate) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AnnotationQueueUpdate from json.
func (o *OptAnnotationQueueUpdate) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAnnotationQueueUpdate to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAnnotationQueueUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAnnotationQueueUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AnnotationQueueWrite as json.
func (o OptAnnotationQueueWrite) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AnnotationQueueWrite from json.
func (o *OptAnnotationQueueWrite) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAnnotationQueueWrite to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAnnotationQueueWrite) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAnnotationQueueWrite) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AssistantMessage as json.
func (o OptAssistantMessage) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AssistantMessage from json.
func (o *OptAssistantMessage) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAssistantMessage to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAssistantMessage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAssistantMessage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AssistantMessageRole as json.
func (o OptAssistantMessageRole) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AssistantMessageRole from json.
func (o *OptAssistantMessageRole) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAssistantMessageRole to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAssistantMessageRole) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAssistantMessageRole) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AutomationRuleEvaluatorUpdate as json.
func (o OptAutomationRuleEvaluatorUpdate) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AutomationRuleEvaluatorUpdate from json.
func (o *OptAutomationRuleEvaluatorUpdate) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAutomationRuleEvaluatorUpdate to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAutomationRuleEvaluatorUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAutomationRuleEvaluatorUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AutomationRuleEvaluatorUpdateType as json.
func (o OptAutomationRuleEvaluatorUpdateType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AutomationRuleEvaluatorUpdateType from json.
func (o *OptAutomationRuleEvaluatorUpdateType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAutomationRuleEvaluatorUpdateType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAutomationRuleEvaluatorUpdateType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAutomationRuleEvaluatorUpdateType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AutomationRuleEvaluatorWrite as json.
func (o OptAutomationRuleEvaluatorWrite) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AutomationRuleEvaluatorWrite from json.
func (o *OptAutomationRuleEvaluatorWrite) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAutomationRuleEvaluatorWrite to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAutomationRuleEvaluatorWrite) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAutomationRuleEvaluatorWrite) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BatchDelete as json.
func (o OptBatchDelete) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes BatchDelete from json.
func (o *OptBatchDelete) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBatchDelete to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBatchDelete) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBatchDelete) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ChatCompletionRequest as json.
func (o OptChatCompletionRequest) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ChatCompletionRequest from json.
func (o *OptChatCompletionRequest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptChatCompletionRequest to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptChatCompletionRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptChatCompletionRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ChatCompletionRequestLogitBias as json.
func (o OptChatCompletionRequestLogitBias) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ChatCompletionRequestLogitBias from json.
func (o *OptChatCompletionRequestLogitBias) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptChatCompletionRequestLogitBias to nil")
	}
	o.Set = true
	o.Value = make(ChatCompletionRequestLogitBias)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptChatCompletionRequestLogitBias) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptChatCompletionRequestLogitBias) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ChatCompletionRequestMetadata as json.
func (o OptChatCompletionRequestMetadata) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ChatCompletionRequestMetadata from json.
func (o *OptChatCompletionRequestMetadata) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptChatCompletionRequestMetadata to nil")
	}
	o.Set = true
	o.Value = make(ChatCompletionRequestMetadata)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptChatCompletionRequestMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptChatCompletionRequestMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CheckPublicName as json.
func (o OptCheckPublicName) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CheckPublicName from json.
func (o *OptCheckPublicName) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCheckPublicName to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCheckPublicName) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCheckPublicName) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CheckPublicResult as json.
func (o OptCheckPublicResult) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CheckPublicResult from json.
func (o *OptCheckPublicResult) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCheckPublicResult to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCheckPublicResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCheckPublicResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Comment as json.
func (o OptComment) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Comment from json.
func (o *OptComment) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptComment to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptComment) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptComment) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CompleteMultipartUploadRequest as json.
func (o OptCompleteMultipartUploadRequest) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CompleteMultipartUploadRequest from json.
func (o *OptCompleteMultipartUploadRequest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCompleteMultipartUploadRequest to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCompleteMultipartUploadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCompleteMultipartUploadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CompletionTokensDetails as json.
func (o OptCompletionTokensDetails) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CompletionTokensDetails from json.
func (o *OptCompletionTokensDetails) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCompletionTokensDetails to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCompletionTokensDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCompletionTokensDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateDatasetItemsFromSpansRequest as json.
func (o OptCreateDatasetItemsFromSpansRequest) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CreateDatasetItemsFromSpansRequest from json.
func (o *OptCreateDatasetItemsFromSpansRequest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateDatasetItemsFromSpansRequest to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateDatasetItemsFromSpansRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateDatasetItemsFromSpansRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateDatasetItemsFromTracesRequest as json.
func (o OptCreateDatasetItemsFromTracesRequest) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CreateDatasetItemsFromTracesRequest from json.
func (o *OptCreateDatasetItemsFromTracesRequest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateDatasetItemsFromTracesRequest to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateDatasetItemsFromTracesRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateDatasetItemsFromTracesRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreatePromptVersionDetail as json.
func (o OptCreatePromptVersionDetail) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CreatePromptVersionDetail from json.
func (o *OptCreatePromptVersionDetail) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreatePromptVersionDetail to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreatePromptVersionDetail) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreatePromptVersionDetail) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreatePromptVersionDetailTemplateStructure as json.
func (o OptCreatePromptVersionDetailTemplateStructure) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CreatePromptVersionDetailTemplateStructure from json.
func (o *OptCreatePromptVersionDetailTemplateStructure) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreatePromptVersionDetailTemplateStructure to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreatePromptVersionDetailTemplateStructure) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreatePromptVersionDetailTemplateStructure) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DashboardUpdatePublic as json.
func (o OptDashboardUpdatePublic) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DashboardUpdatePublic from json.
func (o *OptDashboardUpdatePublic) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDashboardUpdatePublic to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDashboardUpdatePublic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDashboardUpdatePublic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DashboardWrite as json.
func (o OptDashboardWrite) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DashboardWrite from json.
func (o *OptDashboardWrite) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDashboardWrite to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDashboardWrite) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDashboardWrite) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatasetExpansionWrite as json.
func (o OptDatasetExpansionWrite) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatasetExpansionWrite from json.
func (o *OptDatasetExpansionWrite) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatasetExpansionWrite to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatasetExpansionWrite) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatasetExpansionWrite) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatasetIdentifier as json.
func (o OptDatasetIdentifier) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatasetIdentifier from json.
func (o *OptDatasetIdentifier) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatasetIdentifier to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatasetIdentifier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatasetIdentifier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatasetIdentifierPublic as json.
func (o OptDatasetIdentifierPublic) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatasetIdentifierPublic from json.
func (o *OptDatasetIdentifierPublic) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatasetIdentifierPublic to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatasetIdentifierPublic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatasetIdentifierPublic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatasetItemBatchUpdate as json.
func (o OptDatasetItemBatchUpdate) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatasetItemBatchUpdate from json.
func (o *OptDatasetItemBatchUpdate) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatasetItemBatchUpdate to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatasetItemBatchUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatasetItemBatchUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatasetItemBatchWrite as json.
func (o OptDatasetItemBatchWrite) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatasetItemBatchWrite from json.
func (o *OptDatasetItemBatchWrite) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatasetItemBatchWrite to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatasetItemBatchWrite) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatasetItemBatchWrite) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatasetItemFilterOperator as json.
func (o OptDatasetItemFilterOperator) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes DatasetItemFilterOperator from json.
func (o *OptDatasetItemFilterOperator) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatasetItemFilterOperator to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatasetItemFilterOperator) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatasetItemFilterOperator) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatasetItemWrite as json.
func (o OptDatasetItemWrite) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatasetItemWrite from json.
func (o *OptDatasetItemWrite) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatasetItemWrite to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatasetItemWrite) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatasetItemWrite) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatasetItemsDelete as json.
func (o OptDatasetItemsDelete) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatasetItemsDelete from json.
func (o *OptDatasetItemsDelete) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatasetItemsDelete to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatasetItemsDelete) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatasetItemsDelete) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatasetPublicStatus as json.
func (o OptDatasetPublicStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes DatasetPublicStatus from json.
func (o *OptDatasetPublicStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatasetPublicStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatasetPublicStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatasetPublicStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatasetPublicVisibility as json.
func (o OptDatasetPublicVisibility) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes DatasetPublicVisibility from json.
func (o *OptDatasetPublicVisibility) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatasetPublicVisibility to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatasetPublicVisibility) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatasetPublicVisibility) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatasetUpdate as json.
func (o OptDatasetUpdate) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatasetUpdate from json.
func (o *OptDatasetUpdate) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatasetUpdate to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatasetUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatasetUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatasetUpdateVisibility as json.
func (o OptDatasetUpdateVisibility) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes DatasetUpdateVisibility from json.
func (o *OptDatasetUpdateVisibility) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatasetUpdateVisibility to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatasetUpdateVisibility) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatasetUpdateVisibility) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatasetVersionCreatePublic as json.
func (o OptDatasetVersionCreatePublic) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatasetVersionCreatePublic from json.
func (o *OptDatasetVersionCreatePublic) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatasetVersionCreatePublic to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatasetVersionCreatePublic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatasetVersionCreatePublic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatasetVersionCreatePublicMetadata as json.
func (o OptDatasetVersionCreatePublicMetadata) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatasetVersionCreatePublicMetadata from json.
func (o *OptDatasetVersionCreatePublicMetadata) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatasetVersionCreatePublicMetadata to nil")
	}
	o.Set = true
	o.Value = make(DatasetVersionCreatePublicMetadata)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatasetVersionCreatePublicMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatasetVersionCreatePublicMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatasetVersionDiffStats as json.
func (o OptDatasetVersionDiffStats) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatasetVersionDiffStats from json.
func (o *OptDatasetVersionDiffStats) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatasetVersionDiffStats to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatasetVersionDiffStats) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatasetVersionDiffStats) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatasetVersionPublicMetadata as json.
func (o OptDatasetVersionPublicMetadata) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatasetVersionPublicMetadata from json.
func (o *OptDatasetVersionPublicMetadata) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatasetVersionPublicMetadata to nil")
	}
	o.Set = true
	o.Value = make(DatasetVersionPublicMetadata)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatasetVersionPublicMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatasetVersionPublicMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatasetVersionRestorePublic as json.
func (o OptDatasetVersionRestorePublic) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatasetVersionRestorePublic from json.
func (o *OptDatasetVersionRestorePublic) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatasetVersionRestorePublic to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatasetVersionRestorePublic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatasetVersionRestorePublic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatasetVersionSummaryPublic as json.
func (o OptDatasetVersionSummaryPublic) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatasetVersionSummaryPublic from json.
func (o *OptDatasetVersionSummaryPublic) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatasetVersionSummaryPublic to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatasetVersionSummaryPublic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatasetVersionSummaryPublic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatasetVersionTag as json.
func (o OptDatasetVersionTag) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatasetVersionTag from json.
func (o *OptDatasetVersionTag) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatasetVersionTag to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatasetVersionTag) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatasetVersionTag) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatasetVersionUpdatePublic as json.
func (o OptDatasetVersionUpdatePublic) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatasetVersionUpdatePublic from json.
func (o *OptDatasetVersionUpdatePublic) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatasetVersionUpdatePublic to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatasetVersionUpdatePublic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatasetVersionUpdatePublic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatasetWrite as json.
func (o OptDatasetWrite) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DatasetWrite from json.
func (o *OptDatasetWrite) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatasetWrite to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatasetWrite) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatasetWrite) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DatasetWriteVisibility as json.
func (o OptDatasetWriteVisibility) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes DatasetWriteVisibility from json.
func (o *OptDatasetWriteVisibility) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDatasetWriteVisibility to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDatasetWriteVisibility) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDatasetWriteVisibility) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes time.Time as json.
func (o OptDateTime) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptDateTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDateTime to nil")
	}
	o.Set = true
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDateTime) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDateTime)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDateTime) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDateTime)
}

// Encode encodes DeleteFeedbackScore as json.
func (o OptDeleteFeedbackScore) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DeleteFeedbackScore from json.
func (o *OptDeleteFeedbackScore) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDeleteFeedbackScore to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDeleteFeedbackScore) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDeleteFeedbackScore) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteIdsHolder as json.
func (o OptDeleteIdsHolder) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DeleteIdsHolder from json.
func (o *OptDeleteIdsHolder) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDeleteIdsHolder to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDeleteIdsHolder) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDeleteIdsHolder) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteThreadFeedbackScores as json.
func (o OptDeleteThreadFeedbackScores) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DeleteThreadFeedbackScores from json.
func (o *OptDeleteThreadFeedbackScores) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDeleteThreadFeedbackScores to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDeleteThreadFeedbackScores) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDeleteThreadFeedbackScores) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteTraceThreads as json.
func (o OptDeleteTraceThreads) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DeleteTraceThreads from json.
func (o *OptDeleteTraceThreads) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDeleteTraceThreads to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDeleteTraceThreads) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDeleteTraceThreads) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Delta as json.
func (o OptDelta) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Delta from json.
func (o *OptDelta) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDelta to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDelta) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDelta) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ErrorCountWithDeviation as json.
func (o OptErrorCountWithDeviation) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ErrorCountWithDeviation from json.
func (o *OptErrorCountWithDeviation) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptErrorCountWithDeviation to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptErrorCountWithDeviation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptErrorCountWithDeviation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ErrorCountWithDeviationDetailed as json.
func (o OptErrorCountWithDeviationDetailed) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ErrorCountWithDeviationDetailed from json.
func (o *OptErrorCountWithDeviationDetailed) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptErrorCountWithDeviationDetailed to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptErrorCountWithDeviationDetailed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptErrorCountWithDeviationDetailed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ErrorInfo as json.
func (o OptErrorInfo) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ErrorInfo from json.
func (o *OptErrorInfo) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptErrorInfo to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptErrorInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptErrorInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ErrorInfoExperimentItemBulkWriteView as json.
func (o OptErrorInfoExperimentItemBulkWriteView) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ErrorInfoExperimentItemBulkWriteView from json.
func (o *OptErrorInfoExperimentItemBulkWriteView) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptErrorInfoExperimentItemBulkWriteView to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptErrorInfoExperimentItemBulkWriteView) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptErrorInfoExperimentItemBulkWriteView) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ErrorInfoPublic as json.
func (o OptErrorInfoPublic) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ErrorInfoPublic from json.
func (o *OptErrorInfoPublic) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptErrorInfoPublic to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptErrorInfoPublic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptErrorInfoPublic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ErrorInfoWrite as json.
func (o OptErrorInfoWrite) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ErrorInfoWrite from json.
func (o *OptErrorInfoWrite) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptErrorInfoWrite to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptErrorInfoWrite) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptErrorInfoWrite) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ExperimentGroupAggregationsResponseContent as json.
func (o OptExperimentGroupAggregationsResponseContent) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ExperimentGroupAggregationsResponseContent from json.
func (o *OptExperimentGroupAggregationsResponseContent) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptExperimentGroupAggregationsResponseContent to nil")
	}
	o.Set = true
	o.Value = make(ExperimentGroupAggregationsResponseContent)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptExperimentGroupAggregationsResponseContent) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptExperimentGroupAggregationsResponseContent) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ExperimentGroupResponseContent as json.
func (o OptExperimentGroupResponseContent) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ExperimentGroupResponseContent from json.
func (o *OptExperimentGroupResponseContent) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptExperimentGroupResponseContent to nil")
	}
	o.Set = true
	o.Value = make(ExperimentGroupResponseContent)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptExperimentGroupResponseContent) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptExperimentGroupResponseContent) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ExperimentItemBulkUploadExperimentItemBulkWriteView as json.
func (o OptExperimentItemBulkUploadExperimentItemBulkWriteView) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ExperimentItemBulkUploadExperimentItemBulkWriteView from json.
func (o *OptExperimentItemBulkUploadExperimentItemBulkWriteView) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptExperimentItemBulkUploadExperimentItemBulkWriteView to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptExperimentItemBulkUploadExperimentItemBulkWriteView) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptExperimentItemBulkUploadExperimentItemBulkWriteView) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ExperimentItemCompareTraceVisibilityMode as json.
func (o OptExperimentItemCompareTraceVisibilityMode) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ExperimentItemCompareTraceVisibilityMode from json.
func (o *OptExperimentItemCompareTraceVisibilityMode) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptExperimentItemCompareTraceVisibilityMode to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptExperimentItemCompareTraceVisibilityMode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptExperimentItemCompareTraceVisibilityMode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ExperimentItemCompareUsage as json.
func (o OptExperimentItemCompareUsage) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ExperimentItemCompareUsage from json.
func (o *OptExperimentItemCompareUsage) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptExperimentItemCompareUsage to nil")
	}
	o.Set = true
	o.Value = make(ExperimentItemCompareUsage)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptExperimentItemCompareUsage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptExperimentItemCompareUsage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ExperimentItemPublicTraceVisibilityMode as json.
func (o OptExperimentItemPublicTraceVisibilityMode) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ExperimentItemPublicTraceVisibilityMode from json.
func (o *OptExperimentItemPublicTraceVisibilityMode) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptExperimentItemPublicTraceVisibilityMode to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptExperimentItemPublicTraceVisibilityMode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptExperimentItemPublicTraceVisibilityMode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ExperimentItemTraceVisibilityMode as json.
func (o OptExperimentItemTraceVisibilityMode) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ExperimentItemTraceVisibilityMode from json.
func (o *OptExperimentItemTraceVisibilityMode) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptExperimentItemTraceVisibilityMode to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptExperimentItemTraceVisibilityMode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptExperimentItemTraceVisibilityMode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ExperimentItemUsage as json.
func (o OptExperimentItemUsage) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ExperimentItemUsage from json.
func (o *OptExperimentItemUsage) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptExperimentItemUsage to nil")
	}
	o.Set = true
	o.Value = make(ExperimentItemUsage)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptExperimentItemUsage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptExperimentItemUsage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ExperimentItemsBatch as json.
func (o OptExperimentItemsBatch) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ExperimentItemsBatch from json.
func (o *OptExperimentItemsBatch) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptExperimentItemsBatch to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptExperimentItemsBatch) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptExperimentItemsBatch) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ExperimentItemsDelete as json.
func (o OptExperimentItemsDelete) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ExperimentItemsDelete from json.
func (o *OptExperimentItemsDelete) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptExperimentItemsDelete to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptExperimentItemsDelete) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptExperimentItemsDelete) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ExperimentPublicStatus as json.
func (o OptExperimentPublicStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ExperimentPublicStatus from json.
func (o *OptExperimentPublicStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptExperimentPublicStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptExperimentPublicStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptExperimentPublicStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ExperimentPublicType as json.
func (o OptExperimentPublicType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ExperimentPublicType from json.
func (o *OptExperimentPublicType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptExperimentPublicType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptExperimentPublicType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptExperimentPublicType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ExperimentPublicUsage as json.
func (o OptExperimentPublicUsage) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ExperimentPublicUsage from json.
func (o *OptExperimentPublicUsage) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptExperimentPublicUsage to nil")
	}
	o.Set = true
	o.Value = make(ExperimentPublicUsage)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptExperimentPublicUsage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptExperimentPublicUsage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ExperimentUpdate as json.
func (o OptExperimentUpdate) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ExperimentUpdate from json.
func (o *OptExperimentUpdate) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptExperimentUpdate to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptExperimentUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptExperimentUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ExperimentUpdateStatus as json.
func (o OptExperimentUpdateStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ExperimentUpdateStatus from json.
func (o *OptExperimentUpdateStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptExperimentUpdateStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptExperimentUpdateStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptExperimentUpdateStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ExperimentUpdateType as json.
func (o OptExperimentUpdateType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ExperimentUpdateType from json.
func (o *OptExperimentUpdateType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptExperimentUpdateType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptExperimentUpdateType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptExperimentUpdateType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ExperimentWrite as json.
func (o OptExperimentWrite) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ExperimentWrite from json.
func (o *OptExperimentWrite) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptExperimentWrite to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptExperimentWrite) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptExperimentWrite) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ExperimentWriteStatus as json.
func (o OptExperimentWriteStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ExperimentWriteStatus from json.
func (o *OptExperimentWriteStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptExperimentWriteStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptExperimentWriteStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptExperimentWriteStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ExperimentWriteType as json.
func (o OptExperimentWriteType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ExperimentWriteType from json.
func (o *OptExperimentWriteType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptExperimentWriteType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptExperimentWriteType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptExperimentWriteType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FeedbackCreate as json.
func (o OptFeedbackCreate) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes FeedbackCreate from json.
func (o *OptFeedbackCreate) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFeedbackCreate to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFeedbackCreate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFeedbackCreate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FeedbackScore as json.
func (o OptFeedbackScore) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes FeedbackScore from json.
func (o *OptFeedbackScore) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFeedbackScore to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFeedbackScore) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFeedbackScore) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FeedbackScoreBatch as json.
func (o OptFeedbackScoreBatch) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes FeedbackScoreBatch from json.
func (o *OptFeedbackScoreBatch) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFeedbackScoreBatch to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFeedbackScoreBatch) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFeedbackScoreBatch) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FeedbackScoreBatchThread as json.
func (o OptFeedbackScoreBatchThread) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes FeedbackScoreBatchThread from json.
func (o *OptFeedbackScoreBatchThread) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFeedbackScoreBatchThread to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFeedbackScoreBatchThread) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFeedbackScoreBatchThread) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FeedbackScoreCompareValueByAuthor as json.
func (o OptFeedbackScoreCompareValueByAuthor) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes FeedbackScoreCompareValueByAuthor from json.
func (o *OptFeedbackScoreCompareValueByAuthor) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFeedbackScoreCompareValueByAuthor to nil")
	}
	o.Set = true
	o.Value = make(FeedbackScoreCompareValueByAuthor)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFeedbackScoreCompareValueByAuthor) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFeedbackScoreCompareValueByAuthor) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FeedbackScoreExperimentItemBulkWriteViewValueByAuthor as json.
func (o OptFeedbackScoreExperimentItemBulkWriteViewValueByAuthor) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes FeedbackScoreExperimentItemBulkWriteViewValueByAuthor from json.
func (o *OptFeedbackScoreExperimentItemBulkWriteViewValueByAuthor) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFeedbackScoreExperimentItemBulkWriteViewValueByAuthor to nil")
	}
	o.Set = true
	o.Value = make(FeedbackScoreExperimentItemBulkWriteViewValueByAuthor)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFeedbackScoreExperimentItemBulkWriteViewValueByAuthor) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFeedbackScoreExperimentItemBulkWriteViewValueByAuthor) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FeedbackScorePublicValueByAuthor as json.
func (o OptFeedbackScorePublicValueByAuthor) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes FeedbackScorePublicValueByAuthor from json.
func (o *OptFeedbackScorePublicValueByAuthor) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFeedbackScorePublicValueByAuthor to nil")
	}
	o.Set = true
	o.Value = make(FeedbackScorePublicValueByAuthor)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFeedbackScorePublicValueByAuthor) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFeedbackScorePublicValueByAuthor) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FeedbackScoreValueByAuthor as json.
func (o OptFeedbackScoreValueByAuthor) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes FeedbackScoreValueByAuthor from json.
func (o *OptFeedbackScoreValueByAuthor) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFeedbackScoreValueByAuthor to nil")
	}
	o.Set = true
	o.Value = make(FeedbackScoreValueByAuthor)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFeedbackScoreValueByAuthor) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFeedbackScoreValueByAuthor) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FeedbackUpdate as json.
func (o OptFeedbackUpdate) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes FeedbackUpdate from json.
func (o *OptFeedbackUpdate) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFeedbackUpdate to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFeedbackUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFeedbackUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes float32 as json.
func (o OptFloat32) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Float32(float32(o.Value))
}

// Decode decodes float32 from json.
func (o *OptFloat32) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFloat32 to nil")
	}
	o.Set = true
	v, err := d.Float32()
	if err != nil {
		return err
	}
	o.Value = float32(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFloat32) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFloat32) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes float64 as json.
func (o OptFloat64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Float64(float64(o.Value))
}

// Decode decodes float64 from json.
func (o *OptFloat64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFloat64 to nil")
	}
	o.Set = true
	v, err := d.Float64()
	if err != nil {
		return err
	}
	o.Value = float64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFloat64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFloat64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Function as json.
func (o OptFunction) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Function from json.
func (o *OptFunction) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFunction to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFunction) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFunction) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FunctionCall as json.
func (o OptFunctionCall) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes FunctionCall from json.
func (o *OptFunctionCall) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFunctionCall to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFunctionCall) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFunctionCall) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FunctionParameters as json.
func (o OptFunctionParameters) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes FunctionParameters from json.
func (o *OptFunctionParameters) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFunctionParameters to nil")
	}
	o.Set = true
	o.Value = make(FunctionParameters)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFunctionParameters) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFunctionParameters) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GroupDetails as json.
func (o OptGroupDetails) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GroupDetails from json.
func (o *OptGroupDetails) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGroupDetails to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGroupDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGroupDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GuardrailBatchWrite as json.
func (o OptGuardrailBatchWrite) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GuardrailBatchWrite from json.
func (o *OptGuardrailBatchWrite) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGuardrailBatchWrite to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGuardrailBatchWrite) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGuardrailBatchWrite) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int32 as json.
func (o OptInt32) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int32(int32(o.Value))
}

// Decode decodes int32 from json.
func (o *OptInt32) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt32 to nil")
	}
	o.Set = true
	v, err := d.Int32()
	if err != nil {
		return err
	}
	o.Value = int32(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt32) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt32) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int64 as json.
func (o OptInt64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int64(int64(o.Value))
}

// Decode decodes int64 from json.
func (o *OptInt64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt64 to nil")
	}
	o.Set = true
	v, err := d.Int64()
	if err != nil {
		return err
	}
	o.Value = int64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes JsonNode as json.
func (o OptJsonNode) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes JsonNode from json.
func (o *OptJsonNode) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptJsonNode to nil")
	}
	o.Set = true
	o.Value = make(JsonNode)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptJsonNode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptJsonNode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes JsonNodeDetail as json.
func (o OptJsonNodeDetail) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes JsonNodeDetail from json.
func (o *OptJsonNodeDetail) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptJsonNodeDetail to nil")
	}
	o.Set = true
	o.Value = make(JsonNodeDetail)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptJsonNodeDetail) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptJsonNodeDetail) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes JsonNodePublic as json.
func (o OptJsonNodePublic) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes JsonNodePublic from json.
func (o *OptJsonNodePublic) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptJsonNodePublic to nil")
	}
	o.Set = true
	o.Value = make(JsonNodePublic)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptJsonNodePublic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptJsonNodePublic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes JsonNodeWrite as json.
func (o OptJsonNodeWrite) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes JsonNodeWrite from json.
func (o *OptJsonNodeWrite) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptJsonNodeWrite to nil")
	}
	o.Set = true
	o.Value = make(JsonNodeWrite)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptJsonNodeWrite) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptJsonNodeWrite) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes JsonSchema as json.
func (o OptJsonSchema) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes JsonSchema from json.
func (o *OptJsonSchema) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptJsonSchema to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptJsonSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptJsonSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes JsonSchemaSchema as json.
func (o OptJsonSchemaSchema) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes JsonSchemaSchema from json.
func (o *OptJsonSchemaSchema) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptJsonSchemaSchema to nil")
	}
	o.Set = true
	o.Value = make(JsonSchemaSchema)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptJsonSchemaSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptJsonSchemaSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LogItemLevel as json.
func (o OptLogItemLevel) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes LogItemLevel from json.
func (o *OptLogItemLevel) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptLogItemLevel to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptLogItemLevel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptLogItemLevel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LogItemMarkers as json.
func (o OptLogItemMarkers) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes LogItemMarkers from json.
func (o *OptLogItemMarkers) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptLogItemMarkers to nil")
	}
	o.Set = true
	o.Value = make(LogItemMarkers)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptLogItemMarkers) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptLogItemMarkers) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ManualEvaluationRequest as json.
func (o OptManualEvaluationRequest) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ManualEvaluationRequest from json.
func (o *OptManualEvaluationRequest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptManualEvaluationRequest to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptManualEvaluationRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptManualEvaluationRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OptimizationStudioConfigPublic as json.
func (o OptOptimizationStudioConfigPublic) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes OptimizationStudioConfigPublic from json.
func (o *OptOptimizationStudioConfigPublic) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptOptimizationStudioConfigPublic to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptOptimizationStudioConfigPublic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptOptimizationStudioConfigPublic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OptimizationStudioConfigWrite as json.
func (o OptOptimizationStudioConfigWrite) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes OptimizationStudioConfigWrite from json.
func (o *OptOptimizationStudioConfigWrite) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptOptimizationStudioConfigWrite to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptOptimizationStudioConfigWrite) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptOptimizationStudioConfigWrite) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OptimizationUpdate as json.
func (o OptOptimizationUpdate) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes OptimizationUpdate from json.
func (o *OptOptimizationUpdate) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptOptimizationUpdate to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptOptimizationUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptOptimizationUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OptimizationUpdateStatus as json.
func (o OptOptimizationUpdateStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes OptimizationUpdateStatus from json.
func (o *OptOptimizationUpdateStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptOptimizationUpdateStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptOptimizationUpdateStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptOptimizationUpdateStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OptimizationWrite as json.
func (o OptOptimizationWrite) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes OptimizationWrite from json.
func (o *OptOptimizationWrite) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptOptimizationWrite to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptOptimizationWrite) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptOptimizationWrite) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PercentageValues as json.
func (o OptPercentageValues) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PercentageValues from json.
func (o *OptPercentageValues) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPercentageValues to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPercentageValues) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPercentageValues) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PercentageValuesDetailed as json.
func (o OptPercentageValuesDetailed) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PercentageValuesDetailed from json.
func (o *OptPercentageValuesDetailed) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPercentageValuesDetailed to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPercentageValuesDetailed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPercentageValuesDetailed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PercentageValuesPublic as json.
func (o OptPercentageValuesPublic) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PercentageValuesPublic from json.
func (o *OptPercentageValuesPublic) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPercentageValuesPublic to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPercentageValuesPublic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPercentageValuesPublic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectDetailedUsage as json.
func (o OptProjectDetailedUsage) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ProjectDetailedUsage from json.
func (o *OptProjectDetailedUsage) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptProjectDetailedUsage to nil")
	}
	o.Set = true
	o.Value = make(ProjectDetailedUsage)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptProjectDetailedUsage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptProjectDetailedUsage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectDetailedVisibility as json.
func (o OptProjectDetailedVisibility) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ProjectDetailedVisibility from json.
func (o *OptProjectDetailedVisibility) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptProjectDetailedVisibility to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptProjectDetailedVisibility) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptProjectDetailedVisibility) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectMetricRequestPublic as json.
func (o OptProjectMetricRequestPublic) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ProjectMetricRequestPublic from json.
func (o *OptProjectMetricRequestPublic) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptProjectMetricRequestPublic to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptProjectMetricRequestPublic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptProjectMetricRequestPublic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectMetricRequestPublicInterval as json.
func (o OptProjectMetricRequestPublicInterval) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ProjectMetricRequestPublicInterval from json.
func (o *OptProjectMetricRequestPublicInterval) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptProjectMetricRequestPublicInterval to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptProjectMetricRequestPublicInterval) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptProjectMetricRequestPublicInterval) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectMetricRequestPublicMetricType as json.
func (o OptProjectMetricRequestPublicMetricType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ProjectMetricRequestPublicMetricType from json.
func (o *OptProjectMetricRequestPublicMetricType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptProjectMetricRequestPublicMetricType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptProjectMetricRequestPublicMetricType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptProjectMetricRequestPublicMetricType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectMetricResponsePublicInterval as json.
func (o OptProjectMetricResponsePublicInterval) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ProjectMetricResponsePublicInterval from json.
func (o *OptProjectMetricResponsePublicInterval) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptProjectMetricResponsePublicInterval to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptProjectMetricResponsePublicInterval) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptProjectMetricResponsePublicInterval) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectMetricResponsePublicMetricType as json.
func (o OptProjectMetricResponsePublicMetricType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ProjectMetricResponsePublicMetricType from json.
func (o *OptProjectMetricResponsePublicMetricType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptProjectMetricResponsePublicMetricType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptProjectMetricResponsePublicMetricType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptProjectMetricResponsePublicMetricType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectPublicVisibility as json.
func (o OptProjectPublicVisibility) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ProjectPublicVisibility from json.
func (o *OptProjectPublicVisibility) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptProjectPublicVisibility to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptProjectPublicVisibility) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptProjectPublicVisibility) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectRetrieveDetailed as json.
func (o OptProjectRetrieveDetailed) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ProjectRetrieveDetailed from json.
func (o *OptProjectRetrieveDetailed) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptProjectRetrieveDetailed to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptProjectRetrieveDetailed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptProjectRetrieveDetailed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectStatItemObjectPublicType as json.
func (o OptProjectStatItemObjectPublicType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ProjectStatItemObjectPublicType from json.
func (o *OptProjectStatItemObjectPublicType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptProjectStatItemObjectPublicType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptProjectStatItemObjectPublicType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptProjectStatItemObjectPublicType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectStatsSummaryItemUsage as json.
func (o OptProjectStatsSummaryItemUsage) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ProjectStatsSummaryItemUsage from json.
func (o *OptProjectStatsSummaryItemUsage) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptProjectStatsSummaryItemUsage to nil")
	}
	o.Set = true
	o.Value = make(ProjectStatsSummaryItemUsage)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptProjectStatsSummaryItemUsage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptProjectStatsSummaryItemUsage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectUpdate as json.
func (o OptProjectUpdate) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ProjectUpdate from json.
func (o *OptProjectUpdate) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptProjectUpdate to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptProjectUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptProjectUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectUpdateVisibility as json.
func (o OptProjectUpdateVisibility) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ProjectUpdateVisibility from json.
func (o *OptProjectUpdateVisibility) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptProjectUpdateVisibility to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptProjectUpdateVisibility) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptProjectUpdateVisibility) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectWrite as json.
func (o OptProjectWrite) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ProjectWrite from json.
func (o *OptProjectWrite) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptProjectWrite to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptProjectWrite) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptProjectWrite) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectWriteVisibility as json.
func (o OptProjectWriteVisibility) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ProjectWriteVisibility from json.
func (o *OptProjectWriteVisibility) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptProjectWriteVisibility to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptProjectWriteVisibility) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptProjectWriteVisibility) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PromptDetailTemplateStructure as json.
func (o OptPromptDetailTemplateStructure) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes PromptDetailTemplateStructure from json.
func (o *OptPromptDetailTemplateStructure) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPromptDetailTemplateStructure to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPromptDetailTemplateStructure) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPromptDetailTemplateStructure) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PromptPublicTemplateStructure as json.
func (o OptPromptPublicTemplateStructure) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes PromptPublicTemplateStructure from json.
func (o *OptPromptPublicTemplateStructure) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPromptPublicTemplateStructure to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPromptPublicTemplateStructure) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPromptPublicTemplateStructure) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PromptTokensDetails as json.
func (o OptPromptTokensDetails) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PromptTokensDetails from json.
func (o *OptPromptTokensDetails) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPromptTokensDetails to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPromptTokensDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPromptTokensDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PromptUpdatable as json.
func (o OptPromptUpdatable) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PromptUpdatable from json.
func (o *OptPromptUpdatable) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPromptUpdatable to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPromptUpdatable) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPromptUpdatable) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PromptVersionBatchUpdate as json.
func (o OptPromptVersionBatchUpdate) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PromptVersionBatchUpdate from json.
func (o *OptPromptVersionBatchUpdate) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPromptVersionBatchUpdate to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPromptVersionBatchUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPromptVersionBatchUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PromptVersionDetail as json.
func (o OptPromptVersionDetail) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PromptVersionDetail from json.
func (o *OptPromptVersionDetail) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPromptVersionDetail to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPromptVersionDetail) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPromptVersionDetail) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PromptVersionDetailTemplateStructure as json.
func (o OptPromptVersionDetailTemplateStructure) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes PromptVersionDetailTemplateStructure from json.
func (o *OptPromptVersionDetailTemplateStructure) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPromptVersionDetailTemplateStructure to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPromptVersionDetailTemplateStructure) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPromptVersionDetailTemplateStructure) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PromptVersionDetailType as json.
func (o OptPromptVersionDetailType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes PromptVersionDetailType from json.
func (o *OptPromptVersionDetailType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPromptVersionDetailType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPromptVersionDetailType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPromptVersionDetailType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PromptVersionLinkPublic as json.
func (o OptPromptVersionLinkPublic) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PromptVersionLinkPublic from json.
func (o *OptPromptVersionLinkPublic) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPromptVersionLinkPublic to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPromptVersionLinkPublic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPromptVersionLinkPublic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PromptVersionLinkWrite as json.
func (o OptPromptVersionLinkWrite) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PromptVersionLinkWrite from json.
func (o *OptPromptVersionLinkWrite) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPromptVersionLinkWrite to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPromptVersionLinkWrite) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPromptVersionLinkWrite) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PromptVersionPublicTemplateStructure as json.
func (o OptPromptVersionPublicTemplateStructure) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes PromptVersionPublicTemplateStructure from json.
func (o *OptPromptVersionPublicTemplateStructure) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPromptVersionPublicTemplateStructure to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPromptVersionPublicTemplateStructure) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPromptVersionPublicTemplateStructure) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PromptVersionPublicType as json.
func (o OptPromptVersionPublicType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes PromptVersionPublicType from json.
func (o *OptPromptVersionPublicType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPromptVersionPublicType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPromptVersionPublicType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPromptVersionPublicType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PromptVersionRetrieveDetail as json.
func (o OptPromptVersionRetrieveDetail) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PromptVersionRetrieveDetail from json.
func (o *OptPromptVersionRetrieveDetail) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPromptVersionRetrieveDetail to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPromptVersionRetrieveDetail) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPromptVersionRetrieveDetail) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PromptWrite as json.
func (o OptPromptWrite) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PromptWrite from json.
func (o *OptPromptWrite) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPromptWrite to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPromptWrite) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPromptWrite) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PromptWriteTemplateStructure as json.
func (o OptPromptWriteTemplateStructure) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes PromptWriteTemplateStructure from json.
func (o *OptPromptWriteTemplateStructure) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPromptWriteTemplateStructure to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPromptWriteTemplateStructure) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPromptWriteTemplateStructure) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PromptWriteType as json.
func (o OptPromptWriteType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes PromptWriteType from json.
func (o *OptPromptWriteType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPromptWriteType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPromptWriteType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPromptWriteType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProviderApiKeyPublicConfiguration as json.
func (o OptProviderApiKeyPublicConfiguration) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ProviderApiKeyPublicConfiguration from json.
func (o *OptProviderApiKeyPublicConfiguration) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptProviderApiKeyPublicConfiguration to nil")
	}
	o.Set = true
	o.Value = make(ProviderApiKeyPublicConfiguration)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptProviderApiKeyPublicConfiguration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptProviderApiKeyPublicConfiguration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProviderApiKeyPublicHeaders as json.
func (o OptProviderApiKeyPublicHeaders) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ProviderApiKeyPublicHeaders from json.
func (o *OptProviderApiKeyPublicHeaders) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptProviderApiKeyPublicHeaders to nil")
	}
	o.Set = true
	o.Value = make(ProviderApiKeyPublicHeaders)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptProviderApiKeyPublicHeaders) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptProviderApiKeyPublicHeaders) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProviderApiKeyUpdate as json.
func (o OptProviderApiKeyUpdate) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ProviderApiKeyUpdate from json.
func (o *OptProviderApiKeyUpdate) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptProviderApiKeyUpdate to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptProviderApiKeyUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptProviderApiKeyUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProviderApiKeyUpdateConfiguration as json.
func (o OptProviderApiKeyUpdateConfiguration) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ProviderApiKeyUpdateConfiguration from json.
func (o *OptProviderApiKeyUpdateConfiguration) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptProviderApiKeyUpdateConfiguration to nil")
	}
	o.Set = true
	o.Value = make(ProviderApiKeyUpdateConfiguration)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptProviderApiKeyUpdateConfiguration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptProviderApiKeyUpdateConfiguration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProviderApiKeyUpdateHeaders as json.
func (o OptProviderApiKeyUpdateHeaders) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ProviderApiKeyUpdateHeaders from json.
func (o *OptProviderApiKeyUpdateHeaders) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptProviderApiKeyUpdateHeaders to nil")
	}
	o.Set = true
	o.Value = make(ProviderApiKeyUpdateHeaders)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptProviderApiKeyUpdateHeaders) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptProviderApiKeyUpdateHeaders) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProviderApiKeyWrite as json.
func (o OptProviderApiKeyWrite) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ProviderApiKeyWrite from json.
func (o *OptProviderApiKeyWrite) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptProviderApiKeyWrite to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptProviderApiKeyWrite) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptProviderApiKeyWrite) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProviderApiKeyWriteConfiguration as json.
func (o OptProviderApiKeyWriteConfiguration) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ProviderApiKeyWriteConfiguration from json.
func (o *OptProviderApiKeyWriteConfiguration) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptProviderApiKeyWriteConfiguration to nil")
	}
	o.Set = true
	o.Value = make(ProviderApiKeyWriteConfiguration)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptProviderApiKeyWriteConfiguration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptProviderApiKeyWriteConfiguration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProviderApiKeyWriteHeaders as json.
func (o OptProviderApiKeyWriteHeaders) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ProviderApiKeyWriteHeaders from json.
func (o *OptProviderApiKeyWriteHeaders) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptProviderApiKeyWriteHeaders to nil")
	}
	o.Set = true
	o.Value = make(ProviderApiKeyWriteHeaders)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptProviderApiKeyWriteHeaders) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptProviderApiKeyWriteHeaders) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ResponseFormat as json.
func (o OptResponseFormat) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ResponseFormat from json.
func (o *OptResponseFormat) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptResponseFormat to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptResponseFormat) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptResponseFormat) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ResponseFormatType as json.
func (o OptResponseFormatType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ResponseFormatType from json.
func (o *OptResponseFormatType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptResponseFormatType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptResponseFormatType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptResponseFormatType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SpanBatchUpdate as json.
func (o OptSpanBatchUpdate) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SpanBatchUpdate from json.
func (o *OptSpanBatchUpdate) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSpanBatchUpdate to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSpanBatchUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSpanBatchUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SpanBatchWrite as json.
func (o OptSpanBatchWrite) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SpanBatchWrite from json.
func (o *OptSpanBatchWrite) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSpanBatchWrite to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSpanBatchWrite) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSpanBatchWrite) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SpanExperimentItemBulkWriteViewType as json.
func (o OptSpanExperimentItemBulkWriteViewType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes SpanExperimentItemBulkWriteViewType from json.
func (o *OptSpanExperimentItemBulkWriteViewType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSpanExperimentItemBulkWriteViewType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSpanExperimentItemBulkWriteViewType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSpanExperimentItemBulkWriteViewType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SpanExperimentItemBulkWriteViewUsage as json.
func (o OptSpanExperimentItemBulkWriteViewUsage) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SpanExperimentItemBulkWriteViewUsage from json.
func (o *OptSpanExperimentItemBulkWriteViewUsage) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSpanExperimentItemBulkWriteViewUsage to nil")
	}
	o.Set = true
	o.Value = make(SpanExperimentItemBulkWriteViewUsage)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSpanExperimentItemBulkWriteViewUsage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSpanExperimentItemBulkWriteViewUsage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SpanPublicType as json.
func (o OptSpanPublicType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes SpanPublicType from json.
func (o *OptSpanPublicType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSpanPublicType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSpanPublicType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSpanPublicType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SpanPublicUsage as json.
func (o OptSpanPublicUsage) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SpanPublicUsage from json.
func (o *OptSpanPublicUsage) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSpanPublicUsage to nil")
	}
	o.Set = true
	o.Value = make(SpanPublicUsage)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSpanPublicUsage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSpanPublicUsage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SpanUpdate as json.
func (o OptSpanUpdate) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SpanUpdate from json.
func (o *OptSpanUpdate) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSpanUpdate to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSpanUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSpanUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SpanUpdateType as json.
func (o OptSpanUpdateType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes SpanUpdateType from json.
func (o *OptSpanUpdateType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSpanUpdateType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSpanUpdateType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSpanUpdateType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SpanUpdateUsage as json.
func (o OptSpanUpdateUsage) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SpanUpdateUsage from json.
func (o *OptSpanUpdateUsage) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSpanUpdateUsage to nil")
	}
	o.Set = true
	o.Value = make(SpanUpdateUsage)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSpanUpdateUsage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSpanUpdateUsage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SpanWrite as json.
func (o OptSpanWrite) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SpanWrite from json.
func (o *OptSpanWrite) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSpanWrite to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSpanWrite) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSpanWrite) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SpanWriteType as json.
func (o OptSpanWriteType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes SpanWriteType from json.
func (o *OptSpanWriteType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSpanWriteType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSpanWriteType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSpanWriteType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SpanWriteUsage as json.
func (o OptSpanWriteUsage) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SpanWriteUsage from json.
func (o *OptSpanWriteUsage) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSpanWriteUsage to nil")
	}
	o.Set = true
	o.Value = make(SpanWriteUsage)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSpanWriteUsage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSpanWriteUsage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StartMultipartUploadRequest as json.
func (o OptStartMultipartUploadRequest) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes StartMultipartUploadRequest from json.
func (o *OptStartMultipartUploadRequest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptStartMultipartUploadRequest to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptStartMultipartUploadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptStartMultipartUploadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StreamOptions as json.
func (o OptStreamOptions) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes StreamOptions from json.
func (o *OptStreamOptions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptStreamOptions to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptStreamOptions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptStreamOptions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ToolCallType as json.
func (o OptToolCallType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ToolCallType from json.
func (o *OptToolCallType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptToolCallType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptToolCallType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptToolCallType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ToolType as json.
func (o OptToolType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ToolType from json.
func (o *OptToolType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptToolType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptToolType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptToolType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TraceBatchUpdate as json.
func (o OptTraceBatchUpdate) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TraceBatchUpdate from json.
func (o *OptTraceBatchUpdate) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTraceBatchUpdate to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTraceBatchUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTraceBatchUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TraceBatchWrite as json.
func (o OptTraceBatchWrite) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TraceBatchWrite from json.
func (o *OptTraceBatchWrite) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTraceBatchWrite to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTraceBatchWrite) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTraceBatchWrite) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TraceExperimentItemBulkWriteView as json.
func (o OptTraceExperimentItemBulkWriteView) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TraceExperimentItemBulkWriteView from json.
func (o *OptTraceExperimentItemBulkWriteView) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTraceExperimentItemBulkWriteView to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTraceExperimentItemBulkWriteView) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTraceExperimentItemBulkWriteView) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TraceFilterPublicOperator as json.
func (o OptTraceFilterPublicOperator) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes TraceFilterPublicOperator from json.
func (o *OptTraceFilterPublicOperator) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTraceFilterPublicOperator to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTraceFilterPublicOperator) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTraceFilterPublicOperator) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TracePublicUsage as json.
func (o OptTracePublicUsage) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TracePublicUsage from json.
func (o *OptTracePublicUsage) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTracePublicUsage to nil")
	}
	o.Set = true
	o.Value = make(TracePublicUsage)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTracePublicUsage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTracePublicUsage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TracePublicVisibilityMode as json.
func (o OptTracePublicVisibilityMode) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes TracePublicVisibilityMode from json.
func (o *OptTracePublicVisibilityMode) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTracePublicVisibilityMode to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTracePublicVisibilityMode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTracePublicVisibilityMode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TraceThreadBatchIdentifier as json.
func (o OptTraceThreadBatchIdentifier) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TraceThreadBatchIdentifier from json.
func (o *OptTraceThreadBatchIdentifier) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTraceThreadBatchIdentifier to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTraceThreadBatchIdentifier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTraceThreadBatchIdentifier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TraceThreadBatchUpdate as json.
func (o OptTraceThreadBatchUpdate) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TraceThreadBatchUpdate from json.
func (o *OptTraceThreadBatchUpdate) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTraceThreadBatchUpdate to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTraceThreadBatchUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTraceThreadBatchUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TraceThreadFilterPublicOperator as json.
func (o OptTraceThreadFilterPublicOperator) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes TraceThreadFilterPublicOperator from json.
func (o *OptTraceThreadFilterPublicOperator) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTraceThreadFilterPublicOperator to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTraceThreadFilterPublicOperator) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTraceThreadFilterPublicOperator) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TraceThreadIdentifier as json.
func (o OptTraceThreadIdentifier) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TraceThreadIdentifier from json.
func (o *OptTraceThreadIdentifier) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTraceThreadIdentifier to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTraceThreadIdentifier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTraceThreadIdentifier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TraceThreadStatus as json.
func (o OptTraceThreadStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes TraceThreadStatus from json.
func (o *OptTraceThreadStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTraceThreadStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTraceThreadStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTraceThreadStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TraceThreadUpdate as json.
func (o OptTraceThreadUpdate) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TraceThreadUpdate from json.
func (o *OptTraceThreadUpdate) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTraceThreadUpdate to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTraceThreadUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTraceThreadUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TraceThreadUsage as json.
func (o OptTraceThreadUsage) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TraceThreadUsage from json.
func (o *OptTraceThreadUsage) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTraceThreadUsage to nil")
	}
	o.Set = true
	o.Value = make(TraceThreadUsage)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTraceThreadUsage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTraceThreadUsage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TraceUpdate as json.
func (o OptTraceUpdate) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TraceUpdate from json.
func (o *OptTraceUpdate) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTraceUpdate to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTraceUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTraceUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TraceWrite as json.
func (o OptTraceWrite) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TraceWrite from json.
func (o *OptTraceWrite) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTraceWrite to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTraceWrite) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTraceWrite) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes uuid.UUID as json.
func (o OptUUID) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	json.EncodeUUID(e, o.Value)
}

// Decode decodes uuid.UUID from json.
func (o *OptUUID) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUUID to nil")
	}
	o.Set = true
	v, err := json.DecodeUUID(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUUID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUUID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Usage as json.
func (o OptUsage) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Usage from json.
func (o *OptUsage) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUsage to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUsage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUsage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ValueEntryCompareSource as json.
func (o OptValueEntryCompareSource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ValueEntryCompareSource from json.
func (o *OptValueEntryCompareSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptValueEntryCompareSource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptValueEntryCompareSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptValueEntryCompareSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ValueEntryExperimentItemBulkWriteViewSource as json.
func (o OptValueEntryExperimentItemBulkWriteViewSource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ValueEntryExperimentItemBulkWriteViewSource from json.
func (o *OptValueEntryExperimentItemBulkWriteViewSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptValueEntryExperimentItemBulkWriteViewSource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptValueEntryExperimentItemBulkWriteViewSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptValueEntryExperimentItemBulkWriteViewSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ValueEntryPublicSource as json.
func (o OptValueEntryPublicSource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ValueEntryPublicSource from json.
func (o *OptValueEntryPublicSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptValueEntryPublicSource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptValueEntryPublicSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptValueEntryPublicSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ValueEntrySource as json.
func (o OptValueEntrySource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ValueEntrySource from json.
func (o *OptValueEntrySource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptValueEntrySource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptValueEntrySource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptValueEntrySource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WebhookExamplesResponseExamples as json.
func (o OptWebhookExamplesResponseExamples) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes WebhookExamplesResponseExamples from json.
func (o *OptWebhookExamplesResponseExamples) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptWebhookExamplesResponseExamples to nil")
	}
	o.Set = true
	o.Value = make(WebhookExamplesResponseExamples)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptWebhookExamplesResponseExamples) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptWebhookExamplesResponseExamples) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WebhookPublicHeaders as json.
func (o OptWebhookPublicHeaders) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes WebhookPublicHeaders from json.
func (o *OptWebhookPublicHeaders) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptWebhookPublicHeaders to nil")
	}
	o.Set = true
	o.Value = make(WebhookPublicHeaders)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptWebhookPublicHeaders) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptWebhookPublicHeaders) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WebhookTestResultStatus as json.
func (o OptWebhookTestResultStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes WebhookTestResultStatus from json.
func (o *OptWebhookTestResultStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptWebhookTestResultStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptWebhookTestResultStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptWebhookTestResultStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WebhookWriteHeaders as json.
func (o OptWebhookWriteHeaders) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes WebhookWriteHeaders from json.
func (o *OptWebhookWriteHeaders) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptWebhookWriteHeaders to nil")
	}
	o.Set = true
	o.Value = make(WebhookWriteHeaders)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptWebhookWriteHeaders) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptWebhookWriteHeaders) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WelcomeWizardSubmission as json.
func (o OptWelcomeWizardSubmission) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes WelcomeWizardSubmission from json.
func (o *OptWelcomeWizardSubmission) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptWelcomeWizardSubmission to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptWelcomeWizardSubmission) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptWelcomeWizardSubmission) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WorkspaceConfiguration as json.
func (o OptWorkspaceConfiguration) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes WorkspaceConfiguration from json.
func (o *OptWorkspaceConfiguration) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptWorkspaceConfiguration to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptWorkspaceConfiguration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptWorkspaceConfiguration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WorkspaceMetricsSummaryRequest as json.
func (o OptWorkspaceMetricsSummaryRequest) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes WorkspaceMetricsSummaryRequest from json.
func (o *OptWorkspaceMetricsSummaryRequest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptWorkspaceMetricsSummaryRequest to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptWorkspaceMetricsSummaryRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptWorkspaceMetricsSummaryRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *OptimizationPagePublic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *OptimizationPagePublic) encodeFields(e *jx.Encoder) {
	{
		if s.Page.Set {
			e.FieldStart("page")
			s.Page.Encode(e)
		}
	}
	{
		if s.Size.Set {
			e.FieldStart("size")
			s.Size.Encode(e)
		}
	}
	{
		if s.Total.Set {
			e.FieldStart("total")
			s.Total.Encode(e)
		}
	}
	{
		if s.Content != nil {
			e.FieldStart("content")
			e.ArrStart()
			for _, elem := range s.Content {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.SortableBy != nil {
			e.FieldStart("sortableBy")
			e.ArrStart()
			for _, elem := range s.SortableBy {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfOptimizationPagePublic = [5]string{
	0: "page",
	1: "size",
	2: "total",
	3: "content",
	4: "sortableBy",
}

// Decode decodes OptimizationPagePublic from json.
func (s *OptimizationPagePublic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OptimizationPagePublic to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "page":
			if err := func() error {
				s.Page.Reset()
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "size":
			if err := func() error {
				s.Size.Reset()
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "total":
			if err := func() error {
				s.Total.Reset()
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "content":
			if err := func() error {
				s.Content = make([]OptimizationPublic, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem OptimizationPublic
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Content = append(s.Content, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		case "sortableBy":
			if err := func() error {
				s.SortableBy = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.SortableBy = append(s.SortableBy, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sortableBy\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OptimizationPagePublic")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OptimizationPagePublic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptimizationPagePublic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *OptimizationPublic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *OptimizationPublic) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		e.FieldStart("dataset_name")
		e.Str(s.DatasetName)
	}
	{
		e.FieldStart("objective_name")
		e.Str(s.ObjectiveName)
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		e.FieldStart("metadata")
		s.Metadata.Encode(e)
	}
	{
		if s.StudioConfig.Set {
			e.FieldStart("studio_config")
			s.StudioConfig.Encode(e)
		}
	}
	{
		if s.DatasetID.Set {
			e.FieldStart("dataset_id")
			s.DatasetID.Encode(e)
		}
	}
	{
		if s.NumTrials.Set {
			e.FieldStart("num_trials")
			s.NumTrials.Encode(e)
		}
	}
	{
		if s.FeedbackScores != nil {
			e.FieldStart("feedback_scores")
			e.ArrStart()
			for _, elem := range s.FeedbackScores {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.CreatedBy.Set {
			e.FieldStart("created_by")
			s.CreatedBy.Encode(e)
		}
	}
	{
		if s.LastUpdatedAt.Set {
			e.FieldStart("last_updated_at")
			s.LastUpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.LastUpdatedBy.Set {
			e.FieldStart("last_updated_by")
			s.LastUpdatedBy.Encode(e)
		}
	}
}

var jsonFieldsNameOfOptimizationPublic = [14]string{
	0:  "id",
	1:  "name",
	2:  "dataset_name",
	3:  "objective_name",
	4:  "status",
	5:  "metadata",
	6:  "studio_config",
	7:  "dataset_id",
	8:  "num_trials",
	9:  "feedback_scores",
	10: "created_at",
	11: "created_by",
	12: "last_updated_at",
	13: "last_updated_by",
}

// Decode decodes OptimizationPublic from json.
func (s *OptimizationPublic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OptimizationPublic to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "dataset_name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.DatasetName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dataset_name\"")
			}
		case "objective_name":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.ObjectiveName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"objective_name\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "metadata":
			if err := func() error {
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "studio_config":
			if err := func() error {
				s.StudioConfig.Reset()
				if err := s.StudioConfig.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"studio_config\"")
			}
		case "dataset_id":
			if err := func() error {
				s.DatasetID.Reset()
				if err := s.DatasetID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dataset_id\"")
			}
		case "num_trials":
			if err := func() error {
				s.NumTrials.Reset()
				if err := s.NumTrials.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"num_trials\"")
			}
		case "feedback_scores":
			if err := func() error {
				s.FeedbackScores = make([]FeedbackScoreAveragePublic, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem FeedbackScoreAveragePublic
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.FeedbackScores = append(s.FeedbackScores, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"feedback_scores\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "created_by":
			if err := func() error {
				s.CreatedBy.Reset()
				if err := s.CreatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_by\"")
			}
		case "last_updated_at":
			if err := func() error {
				s.LastUpdatedAt.Reset()
				if err := s.LastUpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated_at\"")
			}
		case "last_updated_by":
			if err := func() error {
				s.LastUpdatedBy.Reset()
				if err := s.LastUpdatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated_by\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OptimizationPublic")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00011100,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfOptimizationPublic) {
					name = jsonFieldsNameOfOptimizationPublic[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OptimizationPublic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptimizationPublic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OptimizationPublicStatus as json.
func (s OptimizationPublicStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes OptimizationPublicStatus from json.
func (s *OptimizationPublicStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OptimizationPublicStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch OptimizationPublicStatus(v) {
	case OptimizationPublicStatusRunning:
		*s = OptimizationPublicStatusRunning
	case OptimizationPublicStatusCompleted:
		*s = OptimizationPublicStatusCompleted
	case OptimizationPublicStatusCancelled:
		*s = OptimizationPublicStatusCancelled
	case OptimizationPublicStatusInitialized:
		*s = OptimizationPublicStatusInitialized
	case OptimizationPublicStatusError:
		*s = OptimizationPublicStatusError
	default:
		*s = OptimizationPublicStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptimizationPublicStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptimizationPublicStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *OptimizationStudioConfigPublic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *OptimizationStudioConfigPublic) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("dataset_name")
		e.Str(s.DatasetName)
	}
	{
		e.FieldStart("prompt")
		s.Prompt.Encode(e)
	}
	{
		e.FieldStart("llm_model")
		s.LlmModel.Encode(e)
	}
	{
		e.FieldStart("evaluation")
		s.Evaluation.Encode(e)
	}
	{
		e.FieldStart("optimizer")
		s.Optimizer.Encode(e)
	}
}

var jsonFieldsNameOfOptimizationStudioConfigPublic = [5]string{
	0: "dataset_name",
	1: "prompt",
	2: "llm_model",
	3: "evaluation",
	4: "optimizer",
}

// Decode decodes OptimizationStudioConfigPublic from json.
func (s *OptimizationStudioConfigPublic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OptimizationStudioConfigPublic to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "dataset_name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.DatasetName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dataset_name\"")
			}
		case "prompt":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Prompt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prompt\"")
			}
		case "llm_model":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.LlmModel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"llm_model\"")
			}
		case "evaluation":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Evaluation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"evaluation\"")
			}
		case "optimizer":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Optimizer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"optimizer\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OptimizationStudioConfigPublic")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfOptimizationStudioConfigPublic) {
					name = jsonFieldsNameOfOptimizationStudioConfigPublic[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OptimizationStudioConfigPublic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptimizationStudioConfigPublic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *OptimizationStudioConfigWrite) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *OptimizationStudioConfigWrite) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("dataset_name")
		e.Str(s.DatasetName)
	}
	{
		e.FieldStart("prompt")
		s.Prompt.Encode(e)
	}
	{
		e.FieldStart("llm_model")
		s.LlmModel.Encode(e)
	}
	{
		e.FieldStart("evaluation")
		s.Evaluation.Encode(e)
	}
	{
		e.FieldStart("optimizer")
		s.Optimizer.Encode(e)
	}
}

var jsonFieldsNameOfOptimizationStudioConfigWrite = [5]string{
	0: "dataset_name",
	1: "prompt",
	2: "llm_model",
	3: "evaluation",
	4: "optimizer",
}

// Decode decodes OptimizationStudioConfigWrite from json.
func (s *OptimizationStudioConfigWrite) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OptimizationStudioConfigWrite to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "dataset_name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.DatasetName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dataset_name\"")
			}
		case "prompt":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Prompt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prompt\"")
			}
		case "llm_model":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.LlmModel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"llm_model\"")
			}
		case "evaluation":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Evaluation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"evaluation\"")
			}
		case "optimizer":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Optimizer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"optimizer\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OptimizationStudioConfigWrite")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfOptimizationStudioConfigWrite) {
					name = jsonFieldsNameOfOptimizationStudioConfigWrite[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OptimizationStudioConfigWrite) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptimizationStudioConfigWrite) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *OptimizationStudioLog) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *OptimizationStudioLog) encodeFields(e *jx.Encoder) {
	{
		if s.URL.Set {
			e.FieldStart("url")
			s.URL.Encode(e)
		}
	}
	{
		if s.LastModified.Set {
			e.FieldStart("last_modified")
			s.LastModified.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.ExpiresAt.Set {
			e.FieldStart("expires_at")
			s.ExpiresAt.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfOptimizationStudioLog = [3]string{
	0: "url",
	1: "last_modified",
	2: "expires_at",
}

// Decode decodes OptimizationStudioLog from json.
func (s *OptimizationStudioLog) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OptimizationStudioLog to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "last_modified":
			if err := func() error {
				s.LastModified.Reset()
				if err := s.LastModified.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_modified\"")
			}
		case "expires_at":
			if err := func() error {
				s.ExpiresAt.Reset()
				if err := s.ExpiresAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expires_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OptimizationStudioLog")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OptimizationStudioLog) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptimizationStudioLog) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *OptimizationUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *OptimizationUpdate) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
}

var jsonFieldsNameOfOptimizationUpdate = [2]string{
	0: "name",
	1: "status",
}

// Decode decodes OptimizationUpdate from json.
func (s *OptimizationUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OptimizationUpdate to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OptimizationUpdate")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OptimizationUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptimizationUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OptimizationUpdateStatus as json.
func (s OptimizationUpdateStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes OptimizationUpdateStatus from json.
func (s *OptimizationUpdateStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OptimizationUpdateStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch OptimizationUpdateStatus(v) {
	case OptimizationUpdateStatusRunning:
		*s = OptimizationUpdateStatusRunning
	case OptimizationUpdateStatusCompleted:
		*s = OptimizationUpdateStatusCompleted
	case OptimizationUpdateStatusCancelled:
		*s = OptimizationUpdateStatusCancelled
	case OptimizationUpdateStatusInitialized:
		*s = OptimizationUpdateStatusInitialized
	case OptimizationUpdateStatusError:
		*s = OptimizationUpdateStatusError
	default:
		*s = OptimizationUpdateStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptimizationUpdateStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptimizationUpdateStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *OptimizationWrite) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *OptimizationWrite) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		e.FieldStart("dataset_name")
		e.Str(s.DatasetName)
	}
	{
		e.FieldStart("objective_name")
		e.Str(s.ObjectiveName)
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		e.FieldStart("metadata")
		s.Metadata.Encode(e)
	}
	{
		if s.StudioConfig.Set {
			e.FieldStart("studio_config")
			s.StudioConfig.Encode(e)
		}
	}
	{
		if s.LastUpdatedAt.Set {
			e.FieldStart("last_updated_at")
			s.LastUpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfOptimizationWrite = [8]string{
	0: "id",
	1: "name",
	2: "dataset_name",
	3: "objective_name",
	4: "status",
	5: "metadata",
	6: "studio_config",
	7: "last_updated_at",
}

// Decode decodes OptimizationWrite from json.
func (s *OptimizationWrite) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OptimizationWrite to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "dataset_name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.DatasetName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dataset_name\"")
			}
		case "objective_name":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.ObjectiveName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"objective_name\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "metadata":
			if err := func() error {
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "studio_config":
			if err := func() error {
				s.StudioConfig.Reset()
				if err := s.StudioConfig.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"studio_config\"")
			}
		case "last_updated_at":
			if err := func() error {
				s.LastUpdatedAt.Reset()
				if err := s.LastUpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OptimizationWrite")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfOptimizationWrite) {
					name = jsonFieldsNameOfOptimizationWrite[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OptimizationWrite) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptimizationWrite) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OptimizationWriteStatus as json.
func (s OptimizationWriteStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes OptimizationWriteStatus from json.
func (s *OptimizationWriteStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OptimizationWriteStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch OptimizationWriteStatus(v) {
	case OptimizationWriteStatusRunning:
		*s = OptimizationWriteStatusRunning
	case OptimizationWriteStatusCompleted:
		*s = OptimizationWriteStatusCompleted
	case OptimizationWriteStatusCancelled:
		*s = OptimizationWriteStatusCancelled
	case OptimizationWriteStatusInitialized:
		*s = OptimizationWriteStatusInitialized
	case OptimizationWriteStatusError:
		*s = OptimizationWriteStatusError
	default:
		*s = OptimizationWriteStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptimizationWriteStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptimizationWriteStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PageColumns) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PageColumns) encodeFields(e *jx.Encoder) {
	{
		if s.Columns != nil {
			e.FieldStart("columns")
			e.ArrStart()
			for _, elem := range s.Columns {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfPageColumns = [1]string{
	0: "columns",
}

// Decode decodes PageColumns from json.
func (s *PageColumns) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PageColumns to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "columns":
			if err := func() error {
				s.Columns = make([]Column, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Column
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Columns = append(s.Columns, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"columns\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PageColumns")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PageColumns) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PageColumns) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PercentageValues) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PercentageValues) encodeFields(e *jx.Encoder) {
	{
		if s.P50.Set {
			e.FieldStart("p50")
			s.P50.Encode(e)
		}
	}
	{
		if s.P90.Set {
			e.FieldStart("p90")
			s.P90.Encode(e)
		}
	}
	{
		if s.P99.Set {
			e.FieldStart("p99")
			s.P99.Encode(e)
		}
	}
}

var jsonFieldsNameOfPercentageValues = [3]string{
	0: "p50",
	1: "p90",
	2: "p99",
}

// Decode decodes PercentageValues from json.
func (s *PercentageValues) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PercentageValues to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "p50":
			if err := func() error {
				s.P50.Reset()
				if err := s.P50.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"p50\"")
			}
		case "p90":
			if err := func() error {
				s.P90.Reset()
				if err := s.P90.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"p90\"")
			}
		case "p99":
			if err := func() error {
				s.P99.Reset()
				if err := s.P99.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"p99\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PercentageValues")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PercentageValues) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PercentageValues) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PercentageValuesDetailed) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PercentageValuesDetailed) encodeFields(e *jx.Encoder) {
	{
		if s.P50.Set {
			e.FieldStart("p50")
			s.P50.Encode(e)
		}
	}
	{
		if s.P90.Set {
			e.FieldStart("p90")
			s.P90.Encode(e)
		}
	}
	{
		if s.P99.Set {
			e.FieldStart("p99")
			s.P99.Encode(e)
		}
	}
}

var jsonFieldsNameOfPercentageValuesDetailed = [3]string{
	0: "p50",
	1: "p90",
	2: "p99",
}

// Decode decodes PercentageValuesDetailed from json.
func (s *PercentageValuesDetailed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PercentageValuesDetailed to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "p50":
			if err := func() error {
				s.P50.Reset()
				if err := s.P50.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"p50\"")
			}
		case "p90":
			if err := func() error {
				s.P90.Reset()
				if err := s.P90.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"p90\"")
			}
		case "p99":
			if err := func() error {
				s.P99.Reset()
				if err := s.P99.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"p99\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PercentageValuesDetailed")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PercentageValuesDetailed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PercentageValuesDetailed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PercentageValuesPublic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PercentageValuesPublic) encodeFields(e *jx.Encoder) {
	{
		if s.P50.Set {
			e.FieldStart("p50")
			s.P50.Encode(e)
		}
	}
	{
		if s.P90.Set {
			e.FieldStart("p90")
			s.P90.Encode(e)
		}
	}
	{
		if s.P99.Set {
			e.FieldStart("p99")
			s.P99.Encode(e)
		}
	}
}

var jsonFieldsNameOfPercentageValuesPublic = [3]string{
	0: "p50",
	1: "p90",
	2: "p99",
}

// Decode decodes PercentageValuesPublic from json.
func (s *PercentageValuesPublic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PercentageValuesPublic to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "p50":
			if err := func() error {
				s.P50.Reset()
				if err := s.P50.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"p50\"")
			}
		case "p90":
			if err := func() error {
				s.P90.Reset()
				if err := s.P90.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"p90\"")
			}
		case "p99":
			if err := func() error {
				s.P99.Reset()
				if err := s.P99.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"p99\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PercentageValuesPublic")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PercentageValuesPublic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PercentageValuesPublic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProjectDetailed) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProjectDetailed) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Visibility.Set {
			e.FieldStart("visibility")
			s.Visibility.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.CreatedBy.Set {
			e.FieldStart("created_by")
			s.CreatedBy.Encode(e)
		}
	}
	{
		if s.LastUpdatedAt.Set {
			e.FieldStart("last_updated_at")
			s.LastUpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.LastUpdatedBy.Set {
			e.FieldStart("last_updated_by")
			s.LastUpdatedBy.Encode(e)
		}
	}
	{
		if s.LastUpdatedTraceAt.Set {
			e.FieldStart("last_updated_trace_at")
			s.LastUpdatedTraceAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.FeedbackScores != nil {
			e.FieldStart("feedback_scores")
			e.ArrStart()
			for _, elem := range s.FeedbackScores {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Duration.Set {
			e.FieldStart("duration")
			s.Duration.Encode(e)
		}
	}
	{
		if s.TotalEstimatedCost.Set {
			e.FieldStart("total_estimated_cost")
			s.TotalEstimatedCost.Encode(e)
		}
	}
	{
		if s.TotalEstimatedCostSum.Set {
			e.FieldStart("total_estimated_cost_sum")
			s.TotalEstimatedCostSum.Encode(e)
		}
	}
	{
		if s.Usage.Set {
			e.FieldStart("usage")
			s.Usage.Encode(e)
		}
	}
	{
		if s.TraceCount.Set {
			e.FieldStart("trace_count")
			s.TraceCount.Encode(e)
		}
	}
	{
		if s.ThreadCount.Set {
			e.FieldStart("thread_count")
			s.ThreadCount.Encode(e)
		}
	}
	{
		if s.GuardrailsFailedCount.Set {
			e.FieldStart("guardrails_failed_count")
			s.GuardrailsFailedCount.Encode(e)
		}
	}
	{
		if s.ErrorCount.Set {
			e.FieldStart("error_count")
			s.ErrorCount.Encode(e)
		}
	}
}

var jsonFieldsNameOfProjectDetailed = [18]string{
	0:  "id",
	1:  "name",
	2:  "visibility",
	3:  "description",
	4:  "created_at",
	5:  "created_by",
	6:  "last_updated_at",
	7:  "last_updated_by",
	8:  "last_updated_trace_at",
	9:  "feedback_scores",
	10: "duration",
	11: "total_estimated_cost",
	12: "total_estimated_cost_sum",
	13: "usage",
	14: "trace_count",
	15: "thread_count",
	16: "guardrails_failed_count",
	17: "error_count",
}

// Decode decodes ProjectDetailed from json.
func (s *ProjectDetailed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectDetailed to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "visibility":
			if err := func() error {
				s.Visibility.Reset()
				if err := s.Visibility.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"visibility\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "created_by":
			if err := func() error {
				s.CreatedBy.Reset()
				if err := s.CreatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_by\"")
			}
		case "last_updated_at":
			if err := func() error {
				s.LastUpdatedAt.Reset()
				if err := s.LastUpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated_at\"")
			}
		case "last_updated_by":
			if err := func() error {
				s.LastUpdatedBy.Reset()
				if err := s.LastUpdatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated_by\"")
			}
		case "last_updated_trace_at":
			if err := func() error {
				s.LastUpdatedTraceAt.Reset()
				if err := s.LastUpdatedTraceAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated_trace_at\"")
			}
		case "feedback_scores":
			if err := func() error {
				s.FeedbackScores = make([]FeedbackScoreAverageDetailed, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem FeedbackScoreAverageDetailed
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.FeedbackScores = append(s.FeedbackScores, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"feedback_scores\"")
			}
		case "duration":
			if err := func() error {
				s.Duration.Reset()
				if err := s.Duration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration\"")
			}
		case "total_estimated_cost":
			if err := func() error {
				s.TotalEstimatedCost.Reset()
				if err := s.TotalEstimatedCost.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_estimated_cost\"")
			}
		case "total_estimated_cost_sum":
			if err := func() error {
				s.TotalEstimatedCostSum.Reset()
				if err := s.TotalEstimatedCostSum.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_estimated_cost_sum\"")
			}
		case "usage":
			if err := func() error {
				s.Usage.Reset()
				if err := s.Usage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usage\"")
			}
		case "trace_count":
			if err := func() error {
				s.TraceCount.Reset()
				if err := s.TraceCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trace_count\"")
			}
		case "thread_count":
			if err := func() error {
				s.ThreadCount.Reset()
				if err := s.ThreadCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thread_count\"")
			}
		case "guardrails_failed_count":
			if err := func() error {
				s.GuardrailsFailedCount.Reset()
				if err := s.GuardrailsFailedCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"guardrails_failed_count\"")
			}
		case "error_count":
			if err := func() error {
				s.ErrorCount.Reset()
				if err := s.ErrorCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error_count\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProjectDetailed")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b00000010,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfProjectDetailed) {
					name = jsonFieldsNameOfProjectDetailed[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectDetailed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectDetailed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ProjectDetailedUsage) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s ProjectDetailedUsage) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Float64(elem)
	}
}

// Decode decodes ProjectDetailedUsage from json.
func (s *ProjectDetailedUsage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectDetailedUsage to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem float64
		if err := func() error {
			v, err := d.Float64()
			elem = float64(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProjectDetailedUsage")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ProjectDetailedUsage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectDetailedUsage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectDetailedVisibility as json.
func (s ProjectDetailedVisibility) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ProjectDetailedVisibility from json.
func (s *ProjectDetailedVisibility) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectDetailedVisibility to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ProjectDetailedVisibility(v) {
	case ProjectDetailedVisibilityPrivate:
		*s = ProjectDetailedVisibilityPrivate
	case ProjectDetailedVisibilityPublic:
		*s = ProjectDetailedVisibilityPublic
	default:
		*s = ProjectDetailedVisibility(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ProjectDetailedVisibility) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectDetailedVisibility) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProjectMetricRequestPublic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProjectMetricRequestPublic) encodeFields(e *jx.Encoder) {
	{
		if s.MetricType.Set {
			e.FieldStart("metric_type")
			s.MetricType.Encode(e)
		}
	}
	{
		if s.Interval.Set {
			e.FieldStart("interval")
			s.Interval.Encode(e)
		}
	}
	{
		if s.IntervalStart.Set {
			e.FieldStart("interval_start")
			s.IntervalStart.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.IntervalEnd.Set {
			e.FieldStart("interval_end")
			s.IntervalEnd.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.TraceFilters != nil {
			e.FieldStart("trace_filters")
			e.ArrStart()
			for _, elem := range s.TraceFilters {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ThreadFilters != nil {
			e.FieldStart("thread_filters")
			e.ArrStart()
			for _, elem := range s.ThreadFilters {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfProjectMetricRequestPublic = [6]string{
	0: "metric_type",
	1: "interval",
	2: "interval_start",
	3: "interval_end",
	4: "trace_filters",
	5: "thread_filters",
}

// Decode decodes ProjectMetricRequestPublic from json.
func (s *ProjectMetricRequestPublic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectMetricRequestPublic to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "metric_type":
			if err := func() error {
				s.MetricType.Reset()
				if err := s.MetricType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metric_type\"")
			}
		case "interval":
			if err := func() error {
				s.Interval.Reset()
				if err := s.Interval.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"interval\"")
			}
		case "interval_start":
			if err := func() error {
				s.IntervalStart.Reset()
				if err := s.IntervalStart.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"interval_start\"")
			}
		case "interval_end":
			if err := func() error {
				s.IntervalEnd.Reset()
				if err := s.IntervalEnd.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"interval_end\"")
			}
		case "trace_filters":
			if err := func() error {
				s.TraceFilters = make([]TraceFilterPublic, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem TraceFilterPublic
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.TraceFilters = append(s.TraceFilters, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trace_filters\"")
			}
		case "thread_filters":
			if err := func() error {
				s.ThreadFilters = make([]TraceThreadFilterPublic, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem TraceThreadFilterPublic
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ThreadFilters = append(s.ThreadFilters, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thread_filters\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProjectMetricRequestPublic")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectMetricRequestPublic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectMetricRequestPublic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectMetricRequestPublicInterval as json.
func (s ProjectMetricRequestPublicInterval) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ProjectMetricRequestPublicInterval from json.
func (s *ProjectMetricRequestPublicInterval) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectMetricRequestPublicInterval to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ProjectMetricRequestPublicInterval(v) {
	case ProjectMetricRequestPublicIntervalHOURLY:
		*s = ProjectMetricRequestPublicIntervalHOURLY
	case ProjectMetricRequestPublicIntervalDAILY:
		*s = ProjectMetricRequestPublicIntervalDAILY
	case ProjectMetricRequestPublicIntervalWEEKLY:
		*s = ProjectMetricRequestPublicIntervalWEEKLY
	default:
		*s = ProjectMetricRequestPublicInterval(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ProjectMetricRequestPublicInterval) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectMetricRequestPublicInterval) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectMetricRequestPublicMetricType as json.
func (s ProjectMetricRequestPublicMetricType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ProjectMetricRequestPublicMetricType from json.
func (s *ProjectMetricRequestPublicMetricType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectMetricRequestPublicMetricType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ProjectMetricRequestPublicMetricType(v) {
	case ProjectMetricRequestPublicMetricTypeFEEDBACKSCORES:
		*s = ProjectMetricRequestPublicMetricTypeFEEDBACKSCORES
	case ProjectMetricRequestPublicMetricTypeTRACECOUNT:
		*s = ProjectMetricRequestPublicMetricTypeTRACECOUNT
	case ProjectMetricRequestPublicMetricTypeTOKENUSAGE:
		*s = ProjectMetricRequestPublicMetricTypeTOKENUSAGE
	case ProjectMetricRequestPublicMetricTypeDURATION:
		*s = ProjectMetricRequestPublicMetricTypeDURATION
	case ProjectMetricRequestPublicMetricTypeCOST:
		*s = ProjectMetricRequestPublicMetricTypeCOST
	case ProjectMetricRequestPublicMetricTypeGUARDRAILSFAILEDCOUNT:
		*s = ProjectMetricRequestPublicMetricTypeGUARDRAILSFAILEDCOUNT
	case ProjectMetricRequestPublicMetricTypeTHREADCOUNT:
		*s = ProjectMetricRequestPublicMetricTypeTHREADCOUNT
	case ProjectMetricRequestPublicMetricTypeTHREADDURATION:
		*s = ProjectMetricRequestPublicMetricTypeTHREADDURATION
	case ProjectMetricRequestPublicMetricTypeTHREADFEEDBACKSCORES:
		*s = ProjectMetricRequestPublicMetricTypeTHREADFEEDBACKSCORES
	default:
		*s = ProjectMetricRequestPublicMetricType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ProjectMetricRequestPublicMetricType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectMetricRequestPublicMetricType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProjectMetricResponsePublic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProjectMetricResponsePublic) encodeFields(e *jx.Encoder) {
	{
		if s.ProjectID.Set {
			e.FieldStart("project_id")
			s.ProjectID.Encode(e)
		}
	}
	{
		if s.MetricType.Set {
			e.FieldStart("metric_type")
			s.MetricType.Encode(e)
		}
	}
	{
		if s.Interval.Set {
			e.FieldStart("interval")
			s.Interval.Encode(e)
		}
	}
	{
		if s.Results != nil {
			e.FieldStart("results")
			e.ArrStart()
			for _, elem := range s.Results {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfProjectMetricResponsePublic = [4]string{
	0: "project_id",
	1: "metric_type",
	2: "interval",
	3: "results",
}

// Decode decodes ProjectMetricResponsePublic from json.
func (s *ProjectMetricResponsePublic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectMetricResponsePublic to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "project_id":
			if err := func() error {
				s.ProjectID.Reset()
				if err := s.ProjectID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"project_id\"")
			}
		case "metric_type":
			if err := func() error {
				s.MetricType.Reset()
				if err := s.MetricType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metric_type\"")
			}
		case "interval":
			if err := func() error {
				s.Interval.Reset()
				if err := s.Interval.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"interval\"")
			}
		case "results":
			if err := func() error {
				s.Results = make([]ResultsNumberPublic, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ResultsNumberPublic
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Results = append(s.Results, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"results\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProjectMetricResponsePublic")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectMetricResponsePublic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectMetricResponsePublic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectMetricResponsePublicInterval as json.
func (s ProjectMetricResponsePublicInterval) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ProjectMetricResponsePublicInterval from json.
func (s *ProjectMetricResponsePublicInterval) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectMetricResponsePublicInterval to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ProjectMetricResponsePublicInterval(v) {
	case ProjectMetricResponsePublicIntervalHOURLY:
		*s = ProjectMetricResponsePublicIntervalHOURLY
	case ProjectMetricResponsePublicIntervalDAILY:
		*s = ProjectMetricResponsePublicIntervalDAILY
	case ProjectMetricResponsePublicIntervalWEEKLY:
		*s = ProjectMetricResponsePublicIntervalWEEKLY
	default:
		*s = ProjectMetricResponsePublicInterval(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ProjectMetricResponsePublicInterval) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectMetricResponsePublicInterval) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectMetricResponsePublicMetricType as json.
func (s ProjectMetricResponsePublicMetricType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ProjectMetricResponsePublicMetricType from json.
func (s *ProjectMetricResponsePublicMetricType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectMetricResponsePublicMetricType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ProjectMetricResponsePublicMetricType(v) {
	case ProjectMetricResponsePublicMetricTypeFEEDBACKSCORES:
		*s = ProjectMetricResponsePublicMetricTypeFEEDBACKSCORES
	case ProjectMetricResponsePublicMetricTypeTRACECOUNT:
		*s = ProjectMetricResponsePublicMetricTypeTRACECOUNT
	case ProjectMetricResponsePublicMetricTypeTOKENUSAGE:
		*s = ProjectMetricResponsePublicMetricTypeTOKENUSAGE
	case ProjectMetricResponsePublicMetricTypeDURATION:
		*s = ProjectMetricResponsePublicMetricTypeDURATION
	case ProjectMetricResponsePublicMetricTypeCOST:
		*s = ProjectMetricResponsePublicMetricTypeCOST
	case ProjectMetricResponsePublicMetricTypeGUARDRAILSFAILEDCOUNT:
		*s = ProjectMetricResponsePublicMetricTypeGUARDRAILSFAILEDCOUNT
	case ProjectMetricResponsePublicMetricTypeTHREADCOUNT:
		*s = ProjectMetricResponsePublicMetricTypeTHREADCOUNT
	case ProjectMetricResponsePublicMetricTypeTHREADDURATION:
		*s = ProjectMetricResponsePublicMetricTypeTHREADDURATION
	case ProjectMetricResponsePublicMetricTypeTHREADFEEDBACKSCORES:
		*s = ProjectMetricResponsePublicMetricTypeTHREADFEEDBACKSCORES
	default:
		*s = ProjectMetricResponsePublicMetricType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ProjectMetricResponsePublicMetricType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectMetricResponsePublicMetricType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProjectPagePublic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProjectPagePublic) encodeFields(e *jx.Encoder) {
	{
		if s.Page.Set {
			e.FieldStart("page")
			s.Page.Encode(e)
		}
	}
	{
		if s.Size.Set {
			e.FieldStart("size")
			s.Size.Encode(e)
		}
	}
	{
		if s.Total.Set {
			e.FieldStart("total")
			s.Total.Encode(e)
		}
	}
	{
		if s.Content != nil {
			e.FieldStart("content")
			e.ArrStart()
			for _, elem := range s.Content {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.SortableBy != nil {
			e.FieldStart("sortableBy")
			e.ArrStart()
			for _, elem := range s.SortableBy {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfProjectPagePublic = [5]string{
	0: "page",
	1: "size",
	2: "total",
	3: "content",
	4: "sortableBy",
}

// Decode decodes ProjectPagePublic from json.
func (s *ProjectPagePublic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectPagePublic to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "page":
			if err := func() error {
				s.Page.Reset()
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "size":
			if err := func() error {
				s.Size.Reset()
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "total":
			if err := func() error {
				s.Total.Reset()
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "content":
			if err := func() error {
				s.Content = make([]ProjectPublic, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ProjectPublic
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Content = append(s.Content, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		case "sortableBy":
			if err := func() error {
				s.SortableBy = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.SortableBy = append(s.SortableBy, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sortableBy\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProjectPagePublic")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectPagePublic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectPagePublic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProjectPublic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProjectPublic) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Visibility.Set {
			e.FieldStart("visibility")
			s.Visibility.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.CreatedBy.Set {
			e.FieldStart("created_by")
			s.CreatedBy.Encode(e)
		}
	}
	{
		if s.LastUpdatedAt.Set {
			e.FieldStart("last_updated_at")
			s.LastUpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.LastUpdatedBy.Set {
			e.FieldStart("last_updated_by")
			s.LastUpdatedBy.Encode(e)
		}
	}
	{
		if s.LastUpdatedTraceAt.Set {
			e.FieldStart("last_updated_trace_at")
			s.LastUpdatedTraceAt.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfProjectPublic = [9]string{
	0: "id",
	1: "name",
	2: "visibility",
	3: "description",
	4: "created_at",
	5: "created_by",
	6: "last_updated_at",
	7: "last_updated_by",
	8: "last_updated_trace_at",
}

// Decode decodes ProjectPublic from json.
func (s *ProjectPublic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectPublic to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "visibility":
			if err := func() error {
				s.Visibility.Reset()
				if err := s.Visibility.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"visibility\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "created_by":
			if err := func() error {
				s.CreatedBy.Reset()
				if err := s.CreatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_by\"")
			}
		case "last_updated_at":
			if err := func() error {
				s.LastUpdatedAt.Reset()
				if err := s.LastUpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated_at\"")
			}
		case "last_updated_by":
			if err := func() error {
				s.LastUpdatedBy.Reset()
				if err := s.LastUpdatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated_by\"")
			}
		case "last_updated_trace_at":
			if err := func() error {
				s.LastUpdatedTraceAt.Reset()
				if err := s.LastUpdatedTraceAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated_trace_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProjectPublic")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000010,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfProjectPublic) {
					name = jsonFieldsNameOfProjectPublic[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectPublic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectPublic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectPublicVisibility as json.
func (s ProjectPublicVisibility) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ProjectPublicVisibility from json.
func (s *ProjectPublicVisibility) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectPublicVisibility to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ProjectPublicVisibility(v) {
	case ProjectPublicVisibilityPrivate:
		*s = ProjectPublicVisibilityPrivate
	case ProjectPublicVisibilityPublic:
		*s = ProjectPublicVisibilityPublic
	default:
		*s = ProjectPublicVisibility(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ProjectPublicVisibility) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectPublicVisibility) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProjectRetrieveDetailed) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProjectRetrieveDetailed) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfProjectRetrieveDetailed = [1]string{
	0: "name",
}

// Decode decodes ProjectRetrieveDetailed from json.
func (s *ProjectRetrieveDetailed) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectRetrieveDetailed to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProjectRetrieveDetailed")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfProjectRetrieveDetailed) {
					name = jsonFieldsNameOfProjectRetrieveDetailed[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectRetrieveDetailed) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectRetrieveDetailed) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProjectStatItemObjectPublic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProjectStatItemObjectPublic) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
}

var jsonFieldsNameOfProjectStatItemObjectPublic = [2]string{
	0: "name",
	1: "type",
}

// Decode decodes ProjectStatItemObjectPublic from json.
func (s *ProjectStatItemObjectPublic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectStatItemObjectPublic to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProjectStatItemObjectPublic")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectStatItemObjectPublic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectStatItemObjectPublic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectStatItemObjectPublicType as json.
func (s ProjectStatItemObjectPublicType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ProjectStatItemObjectPublicType from json.
func (s *ProjectStatItemObjectPublicType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectStatItemObjectPublicType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ProjectStatItemObjectPublicType(v) {
	case ProjectStatItemObjectPublicTypeCOUNT:
		*s = ProjectStatItemObjectPublicTypeCOUNT
	case ProjectStatItemObjectPublicTypePERCENTAGE:
		*s = ProjectStatItemObjectPublicTypePERCENTAGE
	case ProjectStatItemObjectPublicTypeAVG:
		*s = ProjectStatItemObjectPublicTypeAVG
	default:
		*s = ProjectStatItemObjectPublicType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ProjectStatItemObjectPublicType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectStatItemObjectPublicType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProjectStatsPublic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProjectStatsPublic) encodeFields(e *jx.Encoder) {
	{
		if s.Stats != nil {
			e.FieldStart("stats")
			e.ArrStart()
			for _, elem := range s.Stats {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfProjectStatsPublic = [1]string{
	0: "stats",
}

// Decode decodes ProjectStatsPublic from json.
func (s *ProjectStatsPublic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectStatsPublic to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "stats":
			if err := func() error {
				s.Stats = make([]ProjectStatItemObjectPublic, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ProjectStatItemObjectPublic
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Stats = append(s.Stats, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stats\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProjectStatsPublic")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectStatsPublic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectStatsPublic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProjectStatsSummary) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProjectStatsSummary) encodeFields(e *jx.Encoder) {
	{
		if s.Content != nil {
			e.FieldStart("content")
			e.ArrStart()
			for _, elem := range s.Content {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfProjectStatsSummary = [1]string{
	0: "content",
}

// Decode decodes ProjectStatsSummary from json.
func (s *ProjectStatsSummary) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectStatsSummary to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "content":
			if err := func() error {
				s.Content = make([]ProjectStatsSummaryItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ProjectStatsSummaryItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Content = append(s.Content, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProjectStatsSummary")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectStatsSummary) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectStatsSummary) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProjectStatsSummaryItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProjectStatsSummaryItem) encodeFields(e *jx.Encoder) {
	{
		if s.ProjectID.Set {
			e.FieldStart("project_id")
			s.ProjectID.Encode(e)
		}
	}
	{
		if s.FeedbackScores != nil {
			e.FieldStart("feedback_scores")
			e.ArrStart()
			for _, elem := range s.FeedbackScores {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Duration.Set {
			e.FieldStart("duration")
			s.Duration.Encode(e)
		}
	}
	{
		if s.TotalEstimatedCost.Set {
			e.FieldStart("total_estimated_cost")
			s.TotalEstimatedCost.Encode(e)
		}
	}
	{
		if s.TotalEstimatedCostSum.Set {
			e.FieldStart("total_estimated_cost_sum")
			s.TotalEstimatedCostSum.Encode(e)
		}
	}
	{
		if s.Usage.Set {
			e.FieldStart("usage")
			s.Usage.Encode(e)
		}
	}
	{
		if s.TraceCount.Set {
			e.FieldStart("trace_count")
			s.TraceCount.Encode(e)
		}
	}
	{
		if s.ThreadCount.Set {
			e.FieldStart("thread_count")
			s.ThreadCount.Encode(e)
		}
	}
	{
		if s.GuardrailsFailedCount.Set {
			e.FieldStart("guardrails_failed_count")
			s.GuardrailsFailedCount.Encode(e)
		}
	}
	{
		if s.ErrorCount.Set {
			e.FieldStart("error_count")
			s.ErrorCount.Encode(e)
		}
	}
}

var jsonFieldsNameOfProjectStatsSummaryItem = [10]string{
	0: "project_id",
	1: "feedback_scores",
	2: "duration",
	3: "total_estimated_cost",
	4: "total_estimated_cost_sum",
	5: "usage",
	6: "trace_count",
	7: "thread_count",
	8: "guardrails_failed_count",
	9: "error_count",
}

// Decode decodes ProjectStatsSummaryItem from json.
func (s *ProjectStatsSummaryItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectStatsSummaryItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "project_id":
			if err := func() error {
				s.ProjectID.Reset()
				if err := s.ProjectID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"project_id\"")
			}
		case "feedback_scores":
			if err := func() error {
				s.FeedbackScores = make([]FeedbackScoreAverage, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem FeedbackScoreAverage
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.FeedbackScores = append(s.FeedbackScores, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"feedback_scores\"")
			}
		case "duration":
			if err := func() error {
				s.Duration.Reset()
				if err := s.Duration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration\"")
			}
		case "total_estimated_cost":
			if err := func() error {
				s.TotalEstimatedCost.Reset()
				if err := s.TotalEstimatedCost.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_estimated_cost\"")
			}
		case "total_estimated_cost_sum":
			if err := func() error {
				s.TotalEstimatedCostSum.Reset()
				if err := s.TotalEstimatedCostSum.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_estimated_cost_sum\"")
			}
		case "usage":
			if err := func() error {
				s.Usage.Reset()
				if err := s.Usage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usage\"")
			}
		case "trace_count":
			if err := func() error {
				s.TraceCount.Reset()
				if err := s.TraceCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trace_count\"")
			}
		case "thread_count":
			if err := func() error {
				s.ThreadCount.Reset()
				if err := s.ThreadCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thread_count\"")
			}
		case "guardrails_failed_count":
			if err := func() error {
				s.GuardrailsFailedCount.Reset()
				if err := s.GuardrailsFailedCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"guardrails_failed_count\"")
			}
		case "error_count":
			if err := func() error {
				s.ErrorCount.Reset()
				if err := s.ErrorCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error_count\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProjectStatsSummaryItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectStatsSummaryItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectStatsSummaryItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ProjectStatsSummaryItemUsage) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s ProjectStatsSummaryItemUsage) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Float64(elem)
	}
}

// Decode decodes ProjectStatsSummaryItemUsage from json.
func (s *ProjectStatsSummaryItemUsage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectStatsSummaryItemUsage to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem float64
		if err := func() error {
			v, err := d.Float64()
			elem = float64(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProjectStatsSummaryItemUsage")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ProjectStatsSummaryItemUsage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectStatsSummaryItemUsage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProjectUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProjectUpdate) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Visibility.Set {
			e.FieldStart("visibility")
			s.Visibility.Encode(e)
		}
	}
}

var jsonFieldsNameOfProjectUpdate = [3]string{
	0: "name",
	1: "description",
	2: "visibility",
}

// Decode decodes ProjectUpdate from json.
func (s *ProjectUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectUpdate to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "visibility":
			if err := func() error {
				s.Visibility.Reset()
				if err := s.Visibility.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"visibility\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProjectUpdate")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectUpdateVisibility as json.
func (s ProjectUpdateVisibility) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ProjectUpdateVisibility from json.
func (s *ProjectUpdateVisibility) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectUpdateVisibility to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ProjectUpdateVisibility(v) {
	case ProjectUpdateVisibilityPrivate:
		*s = ProjectUpdateVisibilityPrivate
	case ProjectUpdateVisibilityPublic:
		*s = ProjectUpdateVisibilityPublic
	default:
		*s = ProjectUpdateVisibility(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ProjectUpdateVisibility) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectUpdateVisibility) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProjectWrite) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProjectWrite) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Visibility.Set {
			e.FieldStart("visibility")
			s.Visibility.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
}

var jsonFieldsNameOfProjectWrite = [3]string{
	0: "name",
	1: "visibility",
	2: "description",
}

// Decode decodes ProjectWrite from json.
func (s *ProjectWrite) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectWrite to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "visibility":
			if err := func() error {
				s.Visibility.Reset()
				if err := s.Visibility.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"visibility\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProjectWrite")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfProjectWrite) {
					name = jsonFieldsNameOfProjectWrite[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectWrite) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectWrite) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectWriteVisibility as json.
func (s ProjectWriteVisibility) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ProjectWriteVisibility from json.
func (s *ProjectWriteVisibility) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectWriteVisibility to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ProjectWriteVisibility(v) {
	case ProjectWriteVisibilityPrivate:
		*s = ProjectWriteVisibilityPrivate
	case ProjectWriteVisibilityPublic:
		*s = ProjectWriteVisibilityPublic
	default:
		*s = ProjectWriteVisibility(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ProjectWriteVisibility) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectWriteVisibility) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PromptDetail) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PromptDetail) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.TemplateStructure.Set {
			e.FieldStart("template_structure")
			s.TemplateStructure.Encode(e)
		}
	}
	{
		if s.Tags != nil {
			e.FieldStart("tags")
			e.ArrStart()
			for _, elem := range s.Tags {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.CreatedBy.Set {
			e.FieldStart("created_by")
			s.CreatedBy.Encode(e)
		}
	}
	{
		if s.LastUpdatedAt.Set {
			e.FieldStart("last_updated_at")
			s.LastUpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.LastUpdatedBy.Set {
			e.FieldStart("last_updated_by")
			s.LastUpdatedBy.Encode(e)
		}
	}
	{
		if s.VersionCount.Set {
			e.FieldStart("version_count")
			s.VersionCount.Encode(e)
		}
	}
	{
		if s.LatestVersion.Set {
			e.FieldStart("latest_version")
			s.LatestVersion.Encode(e)
		}
	}
}

var jsonFieldsNameOfPromptDetail = [11]string{
	0:  "id",
	1:  "name",
	2:  "description",
	3:  "template_structure",
	4:  "tags",
	5:  "created_at",
	6:  "created_by",
	7:  "last_updated_at",
	8:  "last_updated_by",
	9:  "version_count",
	10: "latest_version",
}

// Decode decodes PromptDetail from json.
func (s *PromptDetail) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptDetail to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "template_structure":
			if err := func() error {
				s.TemplateStructure.Reset()
				if err := s.TemplateStructure.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"template_structure\"")
			}
		case "tags":
			if err := func() error {
				s.Tags = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Tags = append(s.Tags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "created_by":
			if err := func() error {
				s.CreatedBy.Reset()
				if err := s.CreatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_by\"")
			}
		case "last_updated_at":
			if err := func() error {
				s.LastUpdatedAt.Reset()
				if err := s.LastUpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated_at\"")
			}
		case "last_updated_by":
			if err := func() error {
				s.LastUpdatedBy.Reset()
				if err := s.LastUpdatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated_by\"")
			}
		case "version_count":
			if err := func() error {
				s.VersionCount.Reset()
				if err := s.VersionCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version_count\"")
			}
		case "latest_version":
			if err := func() error {
				s.LatestVersion.Reset()
				if err := s.LatestVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"latest_version\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PromptDetail")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000010,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPromptDetail) {
					name = jsonFieldsNameOfPromptDetail[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PromptDetail) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptDetail) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PromptDetailTemplateStructure as json.
func (s PromptDetailTemplateStructure) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PromptDetailTemplateStructure from json.
func (s *PromptDetailTemplateStructure) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptDetailTemplateStructure to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PromptDetailTemplateStructure(v) {
	case PromptDetailTemplateStructureText:
		*s = PromptDetailTemplateStructureText
	case PromptDetailTemplateStructureChat:
		*s = PromptDetailTemplateStructureChat
	default:
		*s = PromptDetailTemplateStructure(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PromptDetailTemplateStructure) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptDetailTemplateStructure) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PromptPagePublic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PromptPagePublic) encodeFields(e *jx.Encoder) {
	{
		if s.Page.Set {
			e.FieldStart("page")
			s.Page.Encode(e)
		}
	}
	{
		if s.Size.Set {
			e.FieldStart("size")
			s.Size.Encode(e)
		}
	}
	{
		if s.Total.Set {
			e.FieldStart("total")
			s.Total.Encode(e)
		}
	}
	{
		if s.Content != nil {
			e.FieldStart("content")
			e.ArrStart()
			for _, elem := range s.Content {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.SortableBy != nil {
			e.FieldStart("sortableBy")
			e.ArrStart()
			for _, elem := range s.SortableBy {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfPromptPagePublic = [5]string{
	0: "page",
	1: "size",
	2: "total",
	3: "content",
	4: "sortableBy",
}

// Decode decodes PromptPagePublic from json.
func (s *PromptPagePublic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptPagePublic to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "page":
			if err := func() error {
				s.Page.Reset()
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "size":
			if err := func() error {
				s.Size.Reset()
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "total":
			if err := func() error {
				s.Total.Reset()
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "content":
			if err := func() error {
				s.Content = make([]PromptPublic, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PromptPublic
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Content = append(s.Content, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		case "sortableBy":
			if err := func() error {
				s.SortableBy = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.SortableBy = append(s.SortableBy, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sortableBy\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PromptPagePublic")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PromptPagePublic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptPagePublic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PromptPublic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PromptPublic) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.TemplateStructure.Set {
			e.FieldStart("template_structure")
			s.TemplateStructure.Encode(e)
		}
	}
	{
		if s.Tags != nil {
			e.FieldStart("tags")
			e.ArrStart()
			for _, elem := range s.Tags {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.CreatedBy.Set {
			e.FieldStart("created_by")
			s.CreatedBy.Encode(e)
		}
	}
	{
		if s.LastUpdatedAt.Set {
			e.FieldStart("last_updated_at")
			s.LastUpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.LastUpdatedBy.Set {
			e.FieldStart("last_updated_by")
			s.LastUpdatedBy.Encode(e)
		}
	}
	{
		if s.VersionCount.Set {
			e.FieldStart("version_count")
			s.VersionCount.Encode(e)
		}
	}
}

var jsonFieldsNameOfPromptPublic = [10]string{
	0: "id",
	1: "name",
	2: "description",
	3: "template_structure",
	4: "tags",
	5: "created_at",
	6: "created_by",
	7: "last_updated_at",
	8: "last_updated_by",
	9: "version_count",
}

// Decode decodes PromptPublic from json.
func (s *PromptPublic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptPublic to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "template_structure":
			if err := func() error {
				s.TemplateStructure.Reset()
				if err := s.TemplateStructure.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"template_structure\"")
			}
		case "tags":
			if err := func() error {
				s.Tags = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Tags = append(s.Tags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "created_by":
			if err := func() error {
				s.CreatedBy.Reset()
				if err := s.CreatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_by\"")
			}
		case "last_updated_at":
			if err := func() error {
				s.LastUpdatedAt.Reset()
				if err := s.LastUpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated_at\"")
			}
		case "last_updated_by":
			if err := func() error {
				s.LastUpdatedBy.Reset()
				if err := s.LastUpdatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated_by\"")
			}
		case "version_count":
			if err := func() error {
				s.VersionCount.Reset()
				if err := s.VersionCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version_count\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PromptPublic")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000010,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPromptPublic) {
					name = jsonFieldsNameOfPromptPublic[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PromptPublic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptPublic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PromptPublicTemplateStructure as json.
func (s PromptPublicTemplateStructure) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PromptPublicTemplateStructure from json.
func (s *PromptPublicTemplateStructure) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptPublicTemplateStructure to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PromptPublicTemplateStructure(v) {
	case PromptPublicTemplateStructureText:
		*s = PromptPublicTemplateStructureText
	case PromptPublicTemplateStructureChat:
		*s = PromptPublicTemplateStructureChat
	default:
		*s = PromptPublicTemplateStructure(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PromptPublicTemplateStructure) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptPublicTemplateStructure) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PromptTokensDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PromptTokensDetails) encodeFields(e *jx.Encoder) {
	{
		if s.CachedTokens.Set {
			e.FieldStart("cached_tokens")
			s.CachedTokens.Encode(e)
		}
	}
}

var jsonFieldsNameOfPromptTokensDetails = [1]string{
	0: "cached_tokens",
}

// Decode decodes PromptTokensDetails from json.
func (s *PromptTokensDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptTokensDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cached_tokens":
			if err := func() error {
				s.CachedTokens.Reset()
				if err := s.CachedTokens.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cached_tokens\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PromptTokensDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PromptTokensDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptTokensDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PromptUpdatable) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PromptUpdatable) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Tags != nil {
			e.FieldStart("tags")
			e.ArrStart()
			for _, elem := range s.Tags {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfPromptUpdatable = [3]string{
	0: "name",
	1: "description",
	2: "tags",
}

// Decode decodes PromptUpdatable from json.
func (s *PromptUpdatable) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptUpdatable to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "tags":
			if err := func() error {
				s.Tags = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Tags = append(s.Tags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PromptUpdatable")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPromptUpdatable) {
					name = jsonFieldsNameOfPromptUpdatable[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PromptUpdatable) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptUpdatable) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PromptVersionBatchUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PromptVersionBatchUpdate) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("ids")
		e.ArrStart()
		for _, elem := range s.Ids {
			json.EncodeUUID(e, elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("update")
		s.Update.Encode(e)
	}
	{
		if s.MergeTags.Set {
			e.FieldStart("merge_tags")
			s.MergeTags.Encode(e)
		}
	}
}

var jsonFieldsNameOfPromptVersionBatchUpdate = [3]string{
	0: "ids",
	1: "update",
	2: "merge_tags",
}

// Decode decodes PromptVersionBatchUpdate from json.
func (s *PromptVersionBatchUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptVersionBatchUpdate to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ids":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Ids = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.Ids = append(s.Ids, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ids\"")
			}
		case "update":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Update.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update\"")
			}
		case "merge_tags":
			if err := func() error {
				s.MergeTags.Reset()
				if err := s.MergeTags.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"merge_tags\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PromptVersionBatchUpdate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPromptVersionBatchUpdate) {
					name = jsonFieldsNameOfPromptVersionBatchUpdate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PromptVersionBatchUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptVersionBatchUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PromptVersionDetail) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PromptVersionDetail) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.PromptID.Set {
			e.FieldStart("prompt_id")
			s.PromptID.Encode(e)
		}
	}
	{
		if s.Commit.Set {
			e.FieldStart("commit")
			s.Commit.Encode(e)
		}
	}
	{
		e.FieldStart("template")
		e.Str(s.Template)
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.ChangeDescription.Set {
			e.FieldStart("change_description")
			s.ChangeDescription.Encode(e)
		}
	}
	{
		if s.Tags != nil {
			e.FieldStart("tags")
			e.ArrStart()
			for _, elem := range s.Tags {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Variables != nil {
			e.FieldStart("variables")
			e.ArrStart()
			for _, elem := range s.Variables {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.TemplateStructure.Set {
			e.FieldStart("template_structure")
			s.TemplateStructure.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.CreatedBy.Set {
			e.FieldStart("created_by")
			s.CreatedBy.Encode(e)
		}
	}
}

var jsonFieldsNameOfPromptVersionDetail = [12]string{
	0:  "id",
	1:  "prompt_id",
	2:  "commit",
	3:  "template",
	4:  "metadata",
	5:  "type",
	6:  "change_description",
	7:  "tags",
	8:  "variables",
	9:  "template_structure",
	10: "created_at",
	11: "created_by",
}

// Decode decodes PromptVersionDetail from json.
func (s *PromptVersionDetail) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptVersionDetail to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "prompt_id":
			if err := func() error {
				s.PromptID.Reset()
				if err := s.PromptID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prompt_id\"")
			}
		case "commit":
			if err := func() error {
				s.Commit.Reset()
				if err := s.Commit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commit\"")
			}
		case "template":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Template = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"template\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "change_description":
			if err := func() error {
				s.ChangeDescription.Reset()
				if err := s.ChangeDescription.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"change_description\"")
			}
		case "tags":
			if err := func() error {
				s.Tags = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Tags = append(s.Tags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		case "variables":
			if err := func() error {
				s.Variables = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Variables = append(s.Variables, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"variables\"")
			}
		case "template_structure":
			if err := func() error {
				s.TemplateStructure.Reset()
				if err := s.TemplateStructure.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"template_structure\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "created_by":
			if err := func() error {
				s.CreatedBy.Reset()
				if err := s.CreatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_by\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PromptVersionDetail")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00001000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPromptVersionDetail) {
					name = jsonFieldsNameOfPromptVersionDetail[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PromptVersionDetail) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptVersionDetail) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PromptVersionDetailTemplateStructure as json.
func (s PromptVersionDetailTemplateStructure) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PromptVersionDetailTemplateStructure from json.
func (s *PromptVersionDetailTemplateStructure) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptVersionDetailTemplateStructure to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PromptVersionDetailTemplateStructure(v) {
	case PromptVersionDetailTemplateStructureText:
		*s = PromptVersionDetailTemplateStructureText
	case PromptVersionDetailTemplateStructureChat:
		*s = PromptVersionDetailTemplateStructureChat
	default:
		*s = PromptVersionDetailTemplateStructure(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PromptVersionDetailTemplateStructure) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptVersionDetailTemplateStructure) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PromptVersionDetailType as json.
func (s PromptVersionDetailType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PromptVersionDetailType from json.
func (s *PromptVersionDetailType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptVersionDetailType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PromptVersionDetailType(v) {
	case PromptVersionDetailTypeMustache:
		*s = PromptVersionDetailTypeMustache
	case PromptVersionDetailTypeJinja2:
		*s = PromptVersionDetailTypeJinja2
	default:
		*s = PromptVersionDetailType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PromptVersionDetailType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptVersionDetailType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PromptVersionLinkPublic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PromptVersionLinkPublic) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		json.EncodeUUID(e, s.ID)
	}
	{
		if s.Commit.Set {
			e.FieldStart("commit")
			s.Commit.Encode(e)
		}
	}
	{
		if s.PromptID.Set {
			e.FieldStart("prompt_id")
			s.PromptID.Encode(e)
		}
	}
	{
		if s.PromptName.Set {
			e.FieldStart("prompt_name")
			s.PromptName.Encode(e)
		}
	}
}

var jsonFieldsNameOfPromptVersionLinkPublic = [4]string{
	0: "id",
	1: "commit",
	2: "prompt_id",
	3: "prompt_name",
}

// Decode decodes PromptVersionLinkPublic from json.
func (s *PromptVersionLinkPublic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptVersionLinkPublic to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "commit":
			if err := func() error {
				s.Commit.Reset()
				if err := s.Commit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commit\"")
			}
		case "prompt_id":
			if err := func() error {
				s.PromptID.Reset()
				if err := s.PromptID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prompt_id\"")
			}
		case "prompt_name":
			if err := func() error {
				s.PromptName.Reset()
				if err := s.PromptName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prompt_name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PromptVersionLinkPublic")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPromptVersionLinkPublic) {
					name = jsonFieldsNameOfPromptVersionLinkPublic[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PromptVersionLinkPublic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptVersionLinkPublic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PromptVersionLinkWrite) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PromptVersionLinkWrite) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		json.EncodeUUID(e, s.ID)
	}
}

var jsonFieldsNameOfPromptVersionLinkWrite = [1]string{
	0: "id",
}

// Decode decodes PromptVersionLinkWrite from json.
func (s *PromptVersionLinkWrite) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptVersionLinkWrite to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PromptVersionLinkWrite")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPromptVersionLinkWrite) {
					name = jsonFieldsNameOfPromptVersionLinkWrite[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PromptVersionLinkWrite) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptVersionLinkWrite) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PromptVersionPagePublic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PromptVersionPagePublic) encodeFields(e *jx.Encoder) {
	{
		if s.Page.Set {
			e.FieldStart("page")
			s.Page.Encode(e)
		}
	}
	{
		if s.Size.Set {
			e.FieldStart("size")
			s.Size.Encode(e)
		}
	}
	{
		if s.Total.Set {
			e.FieldStart("total")
			s.Total.Encode(e)
		}
	}
	{
		if s.Content != nil {
			e.FieldStart("content")
			e.ArrStart()
			for _, elem := range s.Content {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.SortableBy != nil {
			e.FieldStart("sortableBy")
			e.ArrStart()
			for _, elem := range s.SortableBy {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfPromptVersionPagePublic = [5]string{
	0: "page",
	1: "size",
	2: "total",
	3: "content",
	4: "sortableBy",
}

// Decode decodes PromptVersionPagePublic from json.
func (s *PromptVersionPagePublic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptVersionPagePublic to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "page":
			if err := func() error {
				s.Page.Reset()
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "size":
			if err := func() error {
				s.Size.Reset()
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "total":
			if err := func() error {
				s.Total.Reset()
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "content":
			if err := func() error {
				s.Content = make([]PromptVersionPublic, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PromptVersionPublic
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Content = append(s.Content, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		case "sortableBy":
			if err := func() error {
				s.SortableBy = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.SortableBy = append(s.SortableBy, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sortableBy\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PromptVersionPagePublic")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PromptVersionPagePublic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptVersionPagePublic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PromptVersionPublic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PromptVersionPublic) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.PromptID.Set {
			e.FieldStart("prompt_id")
			s.PromptID.Encode(e)
		}
	}
	{
		if s.Commit.Set {
			e.FieldStart("commit")
			s.Commit.Encode(e)
		}
	}
	{
		e.FieldStart("template")
		e.Str(s.Template)
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.ChangeDescription.Set {
			e.FieldStart("change_description")
			s.ChangeDescription.Encode(e)
		}
	}
	{
		if s.Tags != nil {
			e.FieldStart("tags")
			e.ArrStart()
			for _, elem := range s.Tags {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.TemplateStructure.Set {
			e.FieldStart("template_structure")
			s.TemplateStructure.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.CreatedBy.Set {
			e.FieldStart("created_by")
			s.CreatedBy.Encode(e)
		}
	}
}

var jsonFieldsNameOfPromptVersionPublic = [11]string{
	0:  "id",
	1:  "prompt_id",
	2:  "commit",
	3:  "template",
	4:  "metadata",
	5:  "type",
	6:  "change_description",
	7:  "tags",
	8:  "template_structure",
	9:  "created_at",
	10: "created_by",
}

// Decode decodes PromptVersionPublic from json.
func (s *PromptVersionPublic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptVersionPublic to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "prompt_id":
			if err := func() error {
				s.PromptID.Reset()
				if err := s.PromptID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prompt_id\"")
			}
		case "commit":
			if err := func() error {
				s.Commit.Reset()
				if err := s.Commit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commit\"")
			}
		case "template":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Template = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"template\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "change_description":
			if err := func() error {
				s.ChangeDescription.Reset()
				if err := s.ChangeDescription.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"change_description\"")
			}
		case "tags":
			if err := func() error {
				s.Tags = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Tags = append(s.Tags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		case "template_structure":
			if err := func() error {
				s.TemplateStructure.Reset()
				if err := s.TemplateStructure.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"template_structure\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "created_by":
			if err := func() error {
				s.CreatedBy.Reset()
				if err := s.CreatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_by\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PromptVersionPublic")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00001000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPromptVersionPublic) {
					name = jsonFieldsNameOfPromptVersionPublic[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PromptVersionPublic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptVersionPublic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PromptVersionPublicTemplateStructure as json.
func (s PromptVersionPublicTemplateStructure) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PromptVersionPublicTemplateStructure from json.
func (s *PromptVersionPublicTemplateStructure) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptVersionPublicTemplateStructure to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PromptVersionPublicTemplateStructure(v) {
	case PromptVersionPublicTemplateStructureText:
		*s = PromptVersionPublicTemplateStructureText
	case PromptVersionPublicTemplateStructureChat:
		*s = PromptVersionPublicTemplateStructureChat
	default:
		*s = PromptVersionPublicTemplateStructure(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PromptVersionPublicTemplateStructure) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptVersionPublicTemplateStructure) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PromptVersionPublicType as json.
func (s PromptVersionPublicType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PromptVersionPublicType from json.
func (s *PromptVersionPublicType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptVersionPublicType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PromptVersionPublicType(v) {
	case PromptVersionPublicTypeMustache:
		*s = PromptVersionPublicTypeMustache
	case PromptVersionPublicTypeJinja2:
		*s = PromptVersionPublicTypeJinja2
	default:
		*s = PromptVersionPublicType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PromptVersionPublicType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptVersionPublicType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PromptVersionRetrieveDetail) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PromptVersionRetrieveDetail) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Commit.Set {
			e.FieldStart("commit")
			s.Commit.Encode(e)
		}
	}
}

var jsonFieldsNameOfPromptVersionRetrieveDetail = [2]string{
	0: "name",
	1: "commit",
}

// Decode decodes PromptVersionRetrieveDetail from json.
func (s *PromptVersionRetrieveDetail) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptVersionRetrieveDetail to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "commit":
			if err := func() error {
				s.Commit.Reset()
				if err := s.Commit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commit\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PromptVersionRetrieveDetail")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPromptVersionRetrieveDetail) {
					name = jsonFieldsNameOfPromptVersionRetrieveDetail[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PromptVersionRetrieveDetail) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptVersionRetrieveDetail) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PromptVersionUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PromptVersionUpdate) encodeFields(e *jx.Encoder) {
	{
		if s.Tags != nil {
			e.FieldStart("tags")
			e.ArrStart()
			for _, elem := range s.Tags {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfPromptVersionUpdate = [1]string{
	0: "tags",
}

// Decode decodes PromptVersionUpdate from json.
func (s *PromptVersionUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptVersionUpdate to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "tags":
			if err := func() error {
				s.Tags = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Tags = append(s.Tags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PromptVersionUpdate")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PromptVersionUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptVersionUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PromptWrite) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PromptWrite) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Template.Set {
			e.FieldStart("template")
			s.Template.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.ChangeDescription.Set {
			e.FieldStart("change_description")
			s.ChangeDescription.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.TemplateStructure.Set {
			e.FieldStart("template_structure")
			s.TemplateStructure.Encode(e)
		}
	}
	{
		if s.Tags != nil {
			e.FieldStart("tags")
			e.ArrStart()
			for _, elem := range s.Tags {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfPromptWrite = [9]string{
	0: "id",
	1: "name",
	2: "description",
	3: "template",
	4: "metadata",
	5: "change_description",
	6: "type",
	7: "template_structure",
	8: "tags",
}

// Decode decodes PromptWrite from json.
func (s *PromptWrite) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptWrite to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "template":
			if err := func() error {
				s.Template.Reset()
				if err := s.Template.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"template\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "change_description":
			if err := func() error {
				s.ChangeDescription.Reset()
				if err := s.ChangeDescription.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"change_description\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "template_structure":
			if err := func() error {
				s.TemplateStructure.Reset()
				if err := s.TemplateStructure.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"template_structure\"")
			}
		case "tags":
			if err := func() error {
				s.Tags = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Tags = append(s.Tags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PromptWrite")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000010,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPromptWrite) {
					name = jsonFieldsNameOfPromptWrite[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PromptWrite) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptWrite) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PromptWriteTemplateStructure as json.
func (s PromptWriteTemplateStructure) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PromptWriteTemplateStructure from json.
func (s *PromptWriteTemplateStructure) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptWriteTemplateStructure to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PromptWriteTemplateStructure(v) {
	case PromptWriteTemplateStructureText:
		*s = PromptWriteTemplateStructureText
	case PromptWriteTemplateStructureChat:
		*s = PromptWriteTemplateStructureChat
	default:
		*s = PromptWriteTemplateStructure(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PromptWriteTemplateStructure) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptWriteTemplateStructure) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PromptWriteType as json.
func (s PromptWriteType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PromptWriteType from json.
func (s *PromptWriteType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptWriteType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PromptWriteType(v) {
	case PromptWriteTypeMustache:
		*s = PromptWriteTypeMustache
	case PromptWriteTypeJinja2:
		*s = PromptWriteTypeJinja2
	default:
		*s = PromptWriteType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PromptWriteType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptWriteType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProviderApiKeyPagePublic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProviderApiKeyPagePublic) encodeFields(e *jx.Encoder) {
	{
		if s.Size.Set {
			e.FieldStart("size")
			s.Size.Encode(e)
		}
	}
	{
		if s.Total.Set {
			e.FieldStart("total")
			s.Total.Encode(e)
		}
	}
	{
		if s.Content != nil {
			e.FieldStart("content")
			e.ArrStart()
			for _, elem := range s.Content {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.SortableBy != nil {
			e.FieldStart("sortableBy")
			e.ArrStart()
			for _, elem := range s.SortableBy {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfProviderApiKeyPagePublic = [4]string{
	0: "size",
	1: "total",
	2: "content",
	3: "sortableBy",
}

// Decode decodes ProviderApiKeyPagePublic from json.
func (s *ProviderApiKeyPagePublic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProviderApiKeyPagePublic to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "size":
			if err := func() error {
				s.Size.Reset()
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "total":
			if err := func() error {
				s.Total.Reset()
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "content":
			if err := func() error {
				s.Content = make([]ProviderApiKeyPublic, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ProviderApiKeyPublic
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Content = append(s.Content, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		case "sortableBy":
			if err := func() error {
				s.SortableBy = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.SortableBy = append(s.SortableBy, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sortableBy\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProviderApiKeyPagePublic")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProviderApiKeyPagePublic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProviderApiKeyPagePublic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProviderApiKeyPublic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProviderApiKeyPublic) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		e.FieldStart("provider")
		s.Provider.Encode(e)
	}
	{
		if s.APIKey.Set {
			e.FieldStart("api_key")
			s.APIKey.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.ProviderName.Set {
			e.FieldStart("provider_name")
			s.ProviderName.Encode(e)
		}
	}
	{
		if s.Headers.Set {
			e.FieldStart("headers")
			s.Headers.Encode(e)
		}
	}
	{
		if s.Configuration.Set {
			e.FieldStart("configuration")
			s.Configuration.Encode(e)
		}
	}
	{
		if s.BaseURL.Set {
			e.FieldStart("base_url")
			s.BaseURL.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.CreatedBy.Set {
			e.FieldStart("created_by")
			s.CreatedBy.Encode(e)
		}
	}
	{
		if s.LastUpdatedAt.Set {
			e.FieldStart("last_updated_at")
			s.LastUpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.LastUpdatedBy.Set {
			e.FieldStart("last_updated_by")
			s.LastUpdatedBy.Encode(e)
		}
	}
	{
		if s.ReadOnly.Set {
			e.FieldStart("read_only")
			s.ReadOnly.Encode(e)
		}
	}
}

var jsonFieldsNameOfProviderApiKeyPublic = [13]string{
	0:  "id",
	1:  "provider",
	2:  "api_key",
	3:  "name",
	4:  "provider_name",
	5:  "headers",
	6:  "configuration",
	7:  "base_url",
	8:  "created_at",
	9:  "created_by",
	10: "last_updated_at",
	11: "last_updated_by",
	12: "read_only",
}

// Decode decodes ProviderApiKeyPublic from json.
func (s *ProviderApiKeyPublic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProviderApiKeyPublic to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "provider":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Provider.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"provider\"")
			}
		case "api_key":
			if err := func() error {
				s.APIKey.Reset()
				if err := s.APIKey.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"api_key\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "provider_name":
			if err := func() error {
				s.ProviderName.Reset()
				if err := s.ProviderName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"provider_name\"")
			}
		case "headers":
			if err := func() error {
				s.Headers.Reset()
				if err := s.Headers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"headers\"")
			}
		case "configuration":
			if err := func() error {
				s.Configuration.Reset()
				if err := s.Configuration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configuration\"")
			}
		case "base_url":
			if err := func() error {
				s.BaseURL.Reset()
				if err := s.BaseURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"base_url\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "created_by":
			if err := func() error {
				s.CreatedBy.Reset()
				if err := s.CreatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_by\"")
			}
		case "last_updated_at":
			if err := func() error {
				s.LastUpdatedAt.Reset()
				if err := s.LastUpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated_at\"")
			}
		case "last_updated_by":
			if err := func() error {
				s.LastUpdatedBy.Reset()
				if err := s.LastUpdatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated_by\"")
			}
		case "read_only":
			if err := func() error {
				s.ReadOnly.Reset()
				if err := s.ReadOnly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"read_only\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProviderApiKeyPublic")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000010,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfProviderApiKeyPublic) {
					name = jsonFieldsNameOfProviderApiKeyPublic[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProviderApiKeyPublic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProviderApiKeyPublic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ProviderApiKeyPublicConfiguration) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s ProviderApiKeyPublicConfiguration) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes ProviderApiKeyPublicConfiguration from json.
func (s *ProviderApiKeyPublicConfiguration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProviderApiKeyPublicConfiguration to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProviderApiKeyPublicConfiguration")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ProviderApiKeyPublicConfiguration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProviderApiKeyPublicConfiguration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ProviderApiKeyPublicHeaders) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s ProviderApiKeyPublicHeaders) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes ProviderApiKeyPublicHeaders from json.
func (s *ProviderApiKeyPublicHeaders) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProviderApiKeyPublicHeaders to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProviderApiKeyPublicHeaders")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ProviderApiKeyPublicHeaders) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProviderApiKeyPublicHeaders) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProviderApiKeyPublicProvider as json.
func (s ProviderApiKeyPublicProvider) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ProviderApiKeyPublicProvider from json.
func (s *ProviderApiKeyPublicProvider) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProviderApiKeyPublicProvider to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ProviderApiKeyPublicProvider(v) {
	case ProviderApiKeyPublicProviderOpenai:
		*s = ProviderApiKeyPublicProviderOpenai
	case ProviderApiKeyPublicProviderAnthropic:
		*s = ProviderApiKeyPublicProviderAnthropic
	case ProviderApiKeyPublicProviderGemini:
		*s = ProviderApiKeyPublicProviderGemini
	case ProviderApiKeyPublicProviderOpenrouter:
		*s = ProviderApiKeyPublicProviderOpenrouter
	case ProviderApiKeyPublicProviderVertexAi:
		*s = ProviderApiKeyPublicProviderVertexAi
	case ProviderApiKeyPublicProviderCustomLlm:
		*s = ProviderApiKeyPublicProviderCustomLlm
	case ProviderApiKeyPublicProviderOpikFree:
		*s = ProviderApiKeyPublicProviderOpikFree
	default:
		*s = ProviderApiKeyPublicProvider(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ProviderApiKeyPublicProvider) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProviderApiKeyPublicProvider) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProviderApiKeyUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProviderApiKeyUpdate) encodeFields(e *jx.Encoder) {
	{
		if s.APIKey.Set {
			e.FieldStart("api_key")
			s.APIKey.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.ProviderName.Set {
			e.FieldStart("provider_name")
			s.ProviderName.Encode(e)
		}
	}
	{
		if s.Headers.Set {
			e.FieldStart("headers")
			s.Headers.Encode(e)
		}
	}
	{
		if s.Configuration.Set {
			e.FieldStart("configuration")
			s.Configuration.Encode(e)
		}
	}
	{
		if s.BaseURL.Set {
			e.FieldStart("base_url")
			s.BaseURL.Encode(e)
		}
	}
}

var jsonFieldsNameOfProviderApiKeyUpdate = [6]string{
	0: "api_key",
	1: "name",
	2: "provider_name",
	3: "headers",
	4: "configuration",
	5: "base_url",
}

// Decode decodes ProviderApiKeyUpdate from json.
func (s *ProviderApiKeyUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProviderApiKeyUpdate to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "api_key":
			if err := func() error {
				s.APIKey.Reset()
				if err := s.APIKey.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"api_key\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "provider_name":
			if err := func() error {
				s.ProviderName.Reset()
				if err := s.ProviderName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"provider_name\"")
			}
		case "headers":
			if err := func() error {
				s.Headers.Reset()
				if err := s.Headers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"headers\"")
			}
		case "configuration":
			if err := func() error {
				s.Configuration.Reset()
				if err := s.Configuration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configuration\"")
			}
		case "base_url":
			if err := func() error {
				s.BaseURL.Reset()
				if err := s.BaseURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"base_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProviderApiKeyUpdate")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProviderApiKeyUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProviderApiKeyUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ProviderApiKeyUpdateConfiguration) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s ProviderApiKeyUpdateConfiguration) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes ProviderApiKeyUpdateConfiguration from json.
func (s *ProviderApiKeyUpdateConfiguration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProviderApiKeyUpdateConfiguration to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProviderApiKeyUpdateConfiguration")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ProviderApiKeyUpdateConfiguration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProviderApiKeyUpdateConfiguration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ProviderApiKeyUpdateHeaders) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s ProviderApiKeyUpdateHeaders) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes ProviderApiKeyUpdateHeaders from json.
func (s *ProviderApiKeyUpdateHeaders) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProviderApiKeyUpdateHeaders to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProviderApiKeyUpdateHeaders")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ProviderApiKeyUpdateHeaders) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProviderApiKeyUpdateHeaders) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProviderApiKeyWrite) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProviderApiKeyWrite) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("provider")
		s.Provider.Encode(e)
	}
	{
		if s.APIKey.Set {
			e.FieldStart("api_key")
			s.APIKey.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.ProviderName.Set {
			e.FieldStart("provider_name")
			s.ProviderName.Encode(e)
		}
	}
	{
		if s.Headers.Set {
			e.FieldStart("headers")
			s.Headers.Encode(e)
		}
	}
	{
		if s.Configuration.Set {
			e.FieldStart("configuration")
			s.Configuration.Encode(e)
		}
	}
	{
		if s.BaseURL.Set {
			e.FieldStart("base_url")
			s.BaseURL.Encode(e)
		}
	}
}

var jsonFieldsNameOfProviderApiKeyWrite = [7]string{
	0: "provider",
	1: "api_key",
	2: "name",
	3: "provider_name",
	4: "headers",
	5: "configuration",
	6: "base_url",
}

// Decode decodes ProviderApiKeyWrite from json.
func (s *ProviderApiKeyWrite) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProviderApiKeyWrite to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "provider":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Provider.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"provider\"")
			}
		case "api_key":
			if err := func() error {
				s.APIKey.Reset()
				if err := s.APIKey.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"api_key\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "provider_name":
			if err := func() error {
				s.ProviderName.Reset()
				if err := s.ProviderName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"provider_name\"")
			}
		case "headers":
			if err := func() error {
				s.Headers.Reset()
				if err := s.Headers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"headers\"")
			}
		case "configuration":
			if err := func() error {
				s.Configuration.Reset()
				if err := s.Configuration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configuration\"")
			}
		case "base_url":
			if err := func() error {
				s.BaseURL.Reset()
				if err := s.BaseURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"base_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProviderApiKeyWrite")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfProviderApiKeyWrite) {
					name = jsonFieldsNameOfProviderApiKeyWrite[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProviderApiKeyWrite) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProviderApiKeyWrite) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ProviderApiKeyWriteConfiguration) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s ProviderApiKeyWriteConfiguration) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes ProviderApiKeyWriteConfiguration from json.
func (s *ProviderApiKeyWriteConfiguration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProviderApiKeyWriteConfiguration to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProviderApiKeyWriteConfiguration")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ProviderApiKeyWriteConfiguration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProviderApiKeyWriteConfiguration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ProviderApiKeyWriteHeaders) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s ProviderApiKeyWriteHeaders) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes ProviderApiKeyWriteHeaders from json.
func (s *ProviderApiKeyWriteHeaders) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProviderApiKeyWriteHeaders to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProviderApiKeyWriteHeaders")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ProviderApiKeyWriteHeaders) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProviderApiKeyWriteHeaders) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProviderApiKeyWriteProvider as json.
func (s ProviderApiKeyWriteProvider) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ProviderApiKeyWriteProvider from json.
func (s *ProviderApiKeyWriteProvider) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProviderApiKeyWriteProvider to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ProviderApiKeyWriteProvider(v) {
	case ProviderApiKeyWriteProviderOpenai:
		*s = ProviderApiKeyWriteProviderOpenai
	case ProviderApiKeyWriteProviderAnthropic:
		*s = ProviderApiKeyWriteProviderAnthropic
	case ProviderApiKeyWriteProviderGemini:
		*s = ProviderApiKeyWriteProviderGemini
	case ProviderApiKeyWriteProviderOpenrouter:
		*s = ProviderApiKeyWriteProviderOpenrouter
	case ProviderApiKeyWriteProviderVertexAi:
		*s = ProviderApiKeyWriteProviderVertexAi
	case ProviderApiKeyWriteProviderCustomLlm:
		*s = ProviderApiKeyWriteProviderCustomLlm
	case ProviderApiKeyWriteProviderOpikFree:
		*s = ProviderApiKeyWriteProviderOpikFree
	default:
		*s = ProviderApiKeyWriteProvider(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ProviderApiKeyWriteProvider) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProviderApiKeyWriteProvider) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResponseFormat) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResponseFormat) encodeFields(e *jx.Encoder) {
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.JSONSchema.Set {
			e.FieldStart("json_schema")
			s.JSONSchema.Encode(e)
		}
	}
}

var jsonFieldsNameOfResponseFormat = [2]string{
	0: "type",
	1: "json_schema",
}

// Decode decodes ResponseFormat from json.
func (s *ResponseFormat) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResponseFormat to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "json_schema":
			if err := func() error {
				s.JSONSchema.Reset()
				if err := s.JSONSchema.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"json_schema\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResponseFormat")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResponseFormat) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResponseFormat) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ResponseFormatType as json.
func (s ResponseFormatType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ResponseFormatType from json.
func (s *ResponseFormatType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResponseFormatType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ResponseFormatType(v) {
	case ResponseFormatTypeText:
		*s = ResponseFormatTypeText
	case ResponseFormatTypeJSONObject:
		*s = ResponseFormatTypeJSONObject
	case ResponseFormatTypeJSONSchema:
		*s = ResponseFormatTypeJSONSchema
	default:
		*s = ResponseFormatType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ResponseFormatType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResponseFormatType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RestorePromptVersionBadRequest as json.
func (s *RestorePromptVersionBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessageDetail)(s)

	unwrapped.Encode(e)
}

// Decode decodes RestorePromptVersionBadRequest from json.
func (s *RestorePromptVersionBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RestorePromptVersionBadRequest to nil")
	}
	var unwrapped ErrorMessageDetail
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RestorePromptVersionBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RestorePromptVersionBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RestorePromptVersionBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RestorePromptVersionNotFound as json.
func (s *RestorePromptVersionNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessageDetail)(s)

	unwrapped.Encode(e)
}

// Decode decodes RestorePromptVersionNotFound from json.
func (s *RestorePromptVersionNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RestorePromptVersionNotFound to nil")
	}
	var unwrapped ErrorMessageDetail
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RestorePromptVersionNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RestorePromptVersionNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RestorePromptVersionNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Result) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Result) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Current.Set {
			e.FieldStart("current")
			s.Current.Encode(e)
		}
	}
	{
		if s.Previous.Set {
			e.FieldStart("previous")
			s.Previous.Encode(e)
		}
	}
}

var jsonFieldsNameOfResult = [3]string{
	0: "name",
	1: "current",
	2: "previous",
}

// Decode decodes Result from json.
func (s *Result) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Result to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "current":
			if err := func() error {
				s.Current.Reset()
				if err := s.Current.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current\"")
			}
		case "previous":
			if err := func() error {
				s.Previous.Reset()
				if err := s.Previous.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"previous\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Result")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Result) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Result) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResultsNumberPublic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResultsNumberPublic) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Data != nil {
			e.FieldStart("data")
			e.ArrStart()
			for _, elem := range s.Data {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfResultsNumberPublic = [2]string{
	0: "name",
	1: "data",
}

// Decode decodes ResultsNumberPublic from json.
func (s *ResultsNumberPublic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResultsNumberPublic to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "data":
			if err := func() error {
				s.Data = make([]DataPointNumberPublic, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DataPointNumberPublic
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResultsNumberPublic")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResultsNumberPublic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResultsNumberPublic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RetrieveProjectBadRequest as json.
func (s *RetrieveProjectBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessageDetailed)(s)

	unwrapped.Encode(e)
}

// Decode decodes RetrieveProjectBadRequest from json.
func (s *RetrieveProjectBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RetrieveProjectBadRequest to nil")
	}
	var unwrapped ErrorMessageDetailed
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RetrieveProjectBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RetrieveProjectBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RetrieveProjectBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RetrieveProjectNotFound as json.
func (s *RetrieveProjectNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessageDetailed)(s)

	unwrapped.Encode(e)
}

// Decode decodes RetrieveProjectNotFound from json.
func (s *RetrieveProjectNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RetrieveProjectNotFound to nil")
	}
	var unwrapped ErrorMessageDetailed
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RetrieveProjectNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RetrieveProjectNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RetrieveProjectNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RetrieveProjectUnprocessableEntity as json.
func (s *RetrieveProjectUnprocessableEntity) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessageDetailed)(s)

	unwrapped.Encode(e)
}

// Decode decodes RetrieveProjectUnprocessableEntity from json.
func (s *RetrieveProjectUnprocessableEntity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RetrieveProjectUnprocessableEntity to nil")
	}
	var unwrapped ErrorMessageDetailed
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RetrieveProjectUnprocessableEntity(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RetrieveProjectUnprocessableEntity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RetrieveProjectUnprocessableEntity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RetrievePromptVersionBadRequest as json.
func (s *RetrievePromptVersionBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessageDetail)(s)

	unwrapped.Encode(e)
}

// Decode decodes RetrievePromptVersionBadRequest from json.
func (s *RetrievePromptVersionBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RetrievePromptVersionBadRequest to nil")
	}
	var unwrapped ErrorMessageDetail
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RetrievePromptVersionBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RetrievePromptVersionBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RetrievePromptVersionBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RetrievePromptVersionNotFound as json.
func (s *RetrievePromptVersionNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessageDetail)(s)

	unwrapped.Encode(e)
}

// Decode decodes RetrievePromptVersionNotFound from json.
func (s *RetrievePromptVersionNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RetrievePromptVersionNotFound to nil")
	}
	var unwrapped ErrorMessageDetail
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RetrievePromptVersionNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RetrievePromptVersionNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RetrievePromptVersionNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RetrievePromptVersionUnprocessableEntity as json.
func (s *RetrievePromptVersionUnprocessableEntity) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessageDetail)(s)

	unwrapped.Encode(e)
}

// Decode decodes RetrievePromptVersionUnprocessableEntity from json.
func (s *RetrievePromptVersionUnprocessableEntity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RetrievePromptVersionUnprocessableEntity to nil")
	}
	var unwrapped ErrorMessageDetail
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RetrievePromptVersionUnprocessableEntity(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RetrievePromptVersionUnprocessableEntity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RetrievePromptVersionUnprocessableEntity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ScoreName) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ScoreName) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
}

var jsonFieldsNameOfScoreName = [2]string{
	0: "name",
	1: "type",
}

// Decode decodes ScoreName from json.
func (s *ScoreName) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ScoreName to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ScoreName")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ScoreName) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ScoreName) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ServiceTogglesConfig) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ServiceTogglesConfig) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("pythonEvaluatorEnabled")
		e.Bool(s.PythonEvaluatorEnabled)
	}
	{
		e.FieldStart("traceThreadPythonEvaluatorEnabled")
		e.Bool(s.TraceThreadPythonEvaluatorEnabled)
	}
	{
		e.FieldStart("spanLlmAsJudgeEnabled")
		e.Bool(s.SpanLlmAsJudgeEnabled)
	}
	{
		e.FieldStart("spanUserDefinedMetricPythonEnabled")
		e.Bool(s.SpanUserDefinedMetricPythonEnabled)
	}
	{
		e.FieldStart("guardrailsEnabled")
		e.Bool(s.GuardrailsEnabled)
	}
	{
		e.FieldStart("opikAIEnabled")
		e.Bool(s.OpikAIEnabled)
	}
	{
		e.FieldStart("alertsEnabled")
		e.Bool(s.AlertsEnabled)
	}
	{
		e.FieldStart("welcomeWizardEnabled")
		e.Bool(s.WelcomeWizardEnabled)
	}
	{
		e.FieldStart("csvUploadEnabled")
		e.Bool(s.CsvUploadEnabled)
	}
	{
		e.FieldStart("exportEnabled")
		e.Bool(s.ExportEnabled)
	}
	{
		e.FieldStart("optimizationStudioEnabled")
		e.Bool(s.OptimizationStudioEnabled)
	}
	{
		e.FieldStart("dashboardsEnabled")
		e.Bool(s.DashboardsEnabled)
	}
	{
		e.FieldStart("datasetVersioningEnabled")
		e.Bool(s.DatasetVersioningEnabled)
	}
	{
		e.FieldStart("openaiProviderEnabled")
		e.Bool(s.OpenaiProviderEnabled)
	}
	{
		e.FieldStart("anthropicProviderEnabled")
		e.Bool(s.AnthropicProviderEnabled)
	}
	{
		e.FieldStart("geminiProviderEnabled")
		e.Bool(s.GeminiProviderEnabled)
	}
	{
		e.FieldStart("openrouterProviderEnabled")
		e.Bool(s.OpenrouterProviderEnabled)
	}
	{
		e.FieldStart("vertexaiProviderEnabled")
		e.Bool(s.VertexaiProviderEnabled)
	}
	{
		e.FieldStart("customllmProviderEnabled")
		e.Bool(s.CustomllmProviderEnabled)
	}
	{
		e.FieldStart("collaboratorsTabEnabled")
		e.Bool(s.CollaboratorsTabEnabled)
	}
}

var jsonFieldsNameOfServiceTogglesConfig = [20]string{
	0:  "pythonEvaluatorEnabled",
	1:  "traceThreadPythonEvaluatorEnabled",
	2:  "spanLlmAsJudgeEnabled",
	3:  "spanUserDefinedMetricPythonEnabled",
	4:  "guardrailsEnabled",
	5:  "opikAIEnabled",
	6:  "alertsEnabled",
	7:  "welcomeWizardEnabled",
	8:  "csvUploadEnabled",
	9:  "exportEnabled",
	10: "optimizationStudioEnabled",
	11: "dashboardsEnabled",
	12: "datasetVersioningEnabled",
	13: "openaiProviderEnabled",
	14: "anthropicProviderEnabled",
	15: "geminiProviderEnabled",
	16: "openrouterProviderEnabled",
	17: "vertexaiProviderEnabled",
	18: "customllmProviderEnabled",
	19: "collaboratorsTabEnabled",
}

// Decode decodes ServiceTogglesConfig from json.
func (s *ServiceTogglesConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ServiceTogglesConfig to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "pythonEvaluatorEnabled":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.PythonEvaluatorEnabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pythonEvaluatorEnabled\"")
			}
		case "traceThreadPythonEvaluatorEnabled":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.TraceThreadPythonEvaluatorEnabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"traceThreadPythonEvaluatorEnabled\"")
			}
		case "spanLlmAsJudgeEnabled":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.SpanLlmAsJudgeEnabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spanLlmAsJudgeEnabled\"")
			}
		case "spanUserDefinedMetricPythonEnabled":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.SpanUserDefinedMetricPythonEnabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spanUserDefinedMetricPythonEnabled\"")
			}
		case "guardrailsEnabled":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.GuardrailsEnabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"guardrailsEnabled\"")
			}
		case "opikAIEnabled":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.OpikAIEnabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"opikAIEnabled\"")
			}
		case "alertsEnabled":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.AlertsEnabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alertsEnabled\"")
			}
		case "welcomeWizardEnabled":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Bool()
				s.WelcomeWizardEnabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"welcomeWizardEnabled\"")
			}
		case "csvUploadEnabled":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.CsvUploadEnabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"csvUploadEnabled\"")
			}
		case "exportEnabled":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.ExportEnabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exportEnabled\"")
			}
		case "optimizationStudioEnabled":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.OptimizationStudioEnabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"optimizationStudioEnabled\"")
			}
		case "dashboardsEnabled":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.DashboardsEnabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dashboardsEnabled\"")
			}
		case "datasetVersioningEnabled":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.DatasetVersioningEnabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"datasetVersioningEnabled\"")
			}
		case "openaiProviderEnabled":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.OpenaiProviderEnabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"openaiProviderEnabled\"")
			}
		case "anthropicProviderEnabled":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.AnthropicProviderEnabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"anthropicProviderEnabled\"")
			}
		case "geminiProviderEnabled":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Bool()
				s.GeminiProviderEnabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"geminiProviderEnabled\"")
			}
		case "openrouterProviderEnabled":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.OpenrouterProviderEnabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"openrouterProviderEnabled\"")
			}
		case "vertexaiProviderEnabled":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.VertexaiProviderEnabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vertexaiProviderEnabled\"")
			}
		case "customllmProviderEnabled":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.CustomllmProviderEnabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"customllmProviderEnabled\"")
			}
		case "collaboratorsTabEnabled":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.CollaboratorsTabEnabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"collaboratorsTabEnabled\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ServiceTogglesConfig")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b11111111,
		0b11111111,
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfServiceTogglesConfig) {
					name = jsonFieldsNameOfServiceTogglesConfig[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ServiceTogglesConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ServiceTogglesConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SpanBatchUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SpanBatchUpdate) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("ids")
		e.ArrStart()
		for _, elem := range s.Ids {
			json.EncodeUUID(e, elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("update")
		s.Update.Encode(e)
	}
	{
		if s.MergeTags.Set {
			e.FieldStart("merge_tags")
			s.MergeTags.Encode(e)
		}
	}
}

var jsonFieldsNameOfSpanBatchUpdate = [3]string{
	0: "ids",
	1: "update",
	2: "merge_tags",
}

// Decode decodes SpanBatchUpdate from json.
func (s *SpanBatchUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpanBatchUpdate to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ids":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Ids = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.Ids = append(s.Ids, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ids\"")
			}
		case "update":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Update.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update\"")
			}
		case "merge_tags":
			if err := func() error {
				s.MergeTags.Reset()
				if err := s.MergeTags.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"merge_tags\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SpanBatchUpdate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSpanBatchUpdate) {
					name = jsonFieldsNameOfSpanBatchUpdate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SpanBatchUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpanBatchUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SpanBatchWrite) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SpanBatchWrite) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("spans")
		e.ArrStart()
		for _, elem := range s.Spans {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfSpanBatchWrite = [1]string{
	0: "spans",
}

// Decode decodes SpanBatchWrite from json.
func (s *SpanBatchWrite) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpanBatchWrite to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "spans":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Spans = make([]SpanWrite, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SpanWrite
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Spans = append(s.Spans, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spans\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SpanBatchWrite")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSpanBatchWrite) {
					name = jsonFieldsNameOfSpanBatchWrite[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SpanBatchWrite) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpanBatchWrite) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SpanEnrichmentOptions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SpanEnrichmentOptions) encodeFields(e *jx.Encoder) {
	{
		if s.IncludeTags.Set {
			e.FieldStart("includeTags")
			s.IncludeTags.Encode(e)
		}
	}
	{
		if s.IncludeFeedbackScores.Set {
			e.FieldStart("includeFeedbackScores")
			s.IncludeFeedbackScores.Encode(e)
		}
	}
	{
		if s.IncludeComments.Set {
			e.FieldStart("includeComments")
			s.IncludeComments.Encode(e)
		}
	}
	{
		if s.IncludeUsage.Set {
			e.FieldStart("includeUsage")
			s.IncludeUsage.Encode(e)
		}
	}
	{
		if s.IncludeMetadata.Set {
			e.FieldStart("includeMetadata")
			s.IncludeMetadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfSpanEnrichmentOptions = [5]string{
	0: "includeTags",
	1: "includeFeedbackScores",
	2: "includeComments",
	3: "includeUsage",
	4: "includeMetadata",
}

// Decode decodes SpanEnrichmentOptions from json.
func (s *SpanEnrichmentOptions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpanEnrichmentOptions to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "includeTags":
			if err := func() error {
				s.IncludeTags.Reset()
				if err := s.IncludeTags.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"includeTags\"")
			}
		case "includeFeedbackScores":
			if err := func() error {
				s.IncludeFeedbackScores.Reset()
				if err := s.IncludeFeedbackScores.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"includeFeedbackScores\"")
			}
		case "includeComments":
			if err := func() error {
				s.IncludeComments.Reset()
				if err := s.IncludeComments.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"includeComments\"")
			}
		case "includeUsage":
			if err := func() error {
				s.IncludeUsage.Reset()
				if err := s.IncludeUsage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"includeUsage\"")
			}
		case "includeMetadata":
			if err := func() error {
				s.IncludeMetadata.Reset()
				if err := s.IncludeMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"includeMetadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SpanEnrichmentOptions")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SpanEnrichmentOptions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpanEnrichmentOptions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SpanExperimentItemBulkWriteView) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SpanExperimentItemBulkWriteView) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.ParentSpanID.Set {
			e.FieldStart("parent_span_id")
			s.ParentSpanID.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		e.FieldStart("start_time")
		json.EncodeDateTime(e, s.StartTime)
	}
	{
		if s.EndTime.Set {
			e.FieldStart("end_time")
			s.EndTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("input")
		s.Input.Encode(e)
	}
	{
		e.FieldStart("output")
		s.Output.Encode(e)
	}
	{
		e.FieldStart("metadata")
		s.Metadata.Encode(e)
	}
	{
		if s.Model.Set {
			e.FieldStart("model")
			s.Model.Encode(e)
		}
	}
	{
		if s.Provider.Set {
			e.FieldStart("provider")
			s.Provider.Encode(e)
		}
	}
	{
		if s.Tags != nil {
			e.FieldStart("tags")
			e.ArrStart()
			for _, elem := range s.Tags {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Usage.Set {
			e.FieldStart("usage")
			s.Usage.Encode(e)
		}
	}
	{
		if s.ErrorInfo.Set {
			e.FieldStart("error_info")
			s.ErrorInfo.Encode(e)
		}
	}
	{
		if s.LastUpdatedAt.Set {
			e.FieldStart("last_updated_at")
			s.LastUpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.TotalEstimatedCost.Set {
			e.FieldStart("total_estimated_cost")
			s.TotalEstimatedCost.Encode(e)
		}
	}
	{
		if s.TotalEstimatedCostVersion.Set {
			e.FieldStart("total_estimated_cost_version")
			s.TotalEstimatedCostVersion.Encode(e)
		}
	}
}

var jsonFieldsNameOfSpanExperimentItemBulkWriteView = [17]string{
	0:  "id",
	1:  "parent_span_id",
	2:  "name",
	3:  "type",
	4:  "start_time",
	5:  "end_time",
	6:  "input",
	7:  "output",
	8:  "metadata",
	9:  "model",
	10: "provider",
	11: "tags",
	12: "usage",
	13: "error_info",
	14: "last_updated_at",
	15: "total_estimated_cost",
	16: "total_estimated_cost_version",
}

// Decode decodes SpanExperimentItemBulkWriteView from json.
func (s *SpanExperimentItemBulkWriteView) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpanExperimentItemBulkWriteView to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "parent_span_id":
			if err := func() error {
				s.ParentSpanID.Reset()
				if err := s.ParentSpanID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parent_span_id\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "start_time":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.StartTime = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start_time\"")
			}
		case "end_time":
			if err := func() error {
				s.EndTime.Reset()
				if err := s.EndTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end_time\"")
			}
		case "input":
			if err := func() error {
				if err := s.Input.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"input\"")
			}
		case "output":
			if err := func() error {
				if err := s.Output.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"output\"")
			}
		case "metadata":
			if err := func() error {
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "model":
			if err := func() error {
				s.Model.Reset()
				if err := s.Model.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"model\"")
			}
		case "provider":
			if err := func() error {
				s.Provider.Reset()
				if err := s.Provider.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"provider\"")
			}
		case "tags":
			if err := func() error {
				s.Tags = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Tags = append(s.Tags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		case "usage":
			if err := func() error {
				s.Usage.Reset()
				if err := s.Usage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usage\"")
			}
		case "error_info":
			if err := func() error {
				s.ErrorInfo.Reset()
				if err := s.ErrorInfo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error_info\"")
			}
		case "last_updated_at":
			if err := func() error {
				s.LastUpdatedAt.Reset()
				if err := s.LastUpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated_at\"")
			}
		case "total_estimated_cost":
			if err := func() error {
				s.TotalEstimatedCost.Reset()
				if err := s.TotalEstimatedCost.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_estimated_cost\"")
			}
		case "total_estimated_cost_version":
			if err := func() error {
				s.TotalEstimatedCostVersion.Reset()
				if err := s.TotalEstimatedCostVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_estimated_cost_version\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SpanExperimentItemBulkWriteView")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b00010000,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSpanExperimentItemBulkWriteView) {
					name = jsonFieldsNameOfSpanExperimentItemBulkWriteView[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SpanExperimentItemBulkWriteView) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpanExperimentItemBulkWriteView) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SpanExperimentItemBulkWriteViewType as json.
func (s SpanExperimentItemBulkWriteViewType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SpanExperimentItemBulkWriteViewType from json.
func (s *SpanExperimentItemBulkWriteViewType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpanExperimentItemBulkWriteViewType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SpanExperimentItemBulkWriteViewType(v) {
	case SpanExperimentItemBulkWriteViewTypeGeneral:
		*s = SpanExperimentItemBulkWriteViewTypeGeneral
	case SpanExperimentItemBulkWriteViewTypeTool:
		*s = SpanExperimentItemBulkWriteViewTypeTool
	case SpanExperimentItemBulkWriteViewTypeLlm:
		*s = SpanExperimentItemBulkWriteViewTypeLlm
	case SpanExperimentItemBulkWriteViewTypeGuardrail:
		*s = SpanExperimentItemBulkWriteViewTypeGuardrail
	default:
		*s = SpanExperimentItemBulkWriteViewType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SpanExperimentItemBulkWriteViewType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpanExperimentItemBulkWriteViewType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SpanExperimentItemBulkWriteViewUsage) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SpanExperimentItemBulkWriteViewUsage) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Int32(elem)
	}
}

// Decode decodes SpanExperimentItemBulkWriteViewUsage from json.
func (s *SpanExperimentItemBulkWriteViewUsage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpanExperimentItemBulkWriteViewUsage to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem int32
		if err := func() error {
			v, err := d.Int32()
			elem = int32(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SpanExperimentItemBulkWriteViewUsage")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SpanExperimentItemBulkWriteViewUsage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpanExperimentItemBulkWriteViewUsage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SpanPagePublic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SpanPagePublic) encodeFields(e *jx.Encoder) {
	{
		if s.Page.Set {
			e.FieldStart("page")
			s.Page.Encode(e)
		}
	}
	{
		if s.Size.Set {
			e.FieldStart("size")
			s.Size.Encode(e)
		}
	}
	{
		if s.Total.Set {
			e.FieldStart("total")
			s.Total.Encode(e)
		}
	}
	{
		if s.Content != nil {
			e.FieldStart("content")
			e.ArrStart()
			for _, elem := range s.Content {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.SortableBy != nil {
			e.FieldStart("sortableBy")
			e.ArrStart()
			for _, elem := range s.SortableBy {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfSpanPagePublic = [5]string{
	0: "page",
	1: "size",
	2: "total",
	3: "content",
	4: "sortableBy",
}

// Decode decodes SpanPagePublic from json.
func (s *SpanPagePublic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpanPagePublic to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "page":
			if err := func() error {
				s.Page.Reset()
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "size":
			if err := func() error {
				s.Size.Reset()
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "total":
			if err := func() error {
				s.Total.Reset()
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "content":
			if err := func() error {
				s.Content = make([]SpanPublic, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SpanPublic
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Content = append(s.Content, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		case "sortableBy":
			if err := func() error {
				s.SortableBy = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.SortableBy = append(s.SortableBy, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sortableBy\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SpanPagePublic")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SpanPagePublic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpanPagePublic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SpanPublic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SpanPublic) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.ProjectName.Set {
			e.FieldStart("project_name")
			s.ProjectName.Encode(e)
		}
	}
	{
		if s.ProjectID.Set {
			e.FieldStart("project_id")
			s.ProjectID.Encode(e)
		}
	}
	{
		if s.TraceID.Set {
			e.FieldStart("trace_id")
			s.TraceID.Encode(e)
		}
	}
	{
		if s.ParentSpanID.Set {
			e.FieldStart("parent_span_id")
			s.ParentSpanID.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		e.FieldStart("start_time")
		json.EncodeDateTime(e, s.StartTime)
	}
	{
		if s.EndTime.Set {
			e.FieldStart("end_time")
			s.EndTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("input")
		s.Input.Encode(e)
	}
	{
		e.FieldStart("output")
		s.Output.Encode(e)
	}
	{
		e.FieldStart("metadata")
		s.Metadata.Encode(e)
	}
	{
		if s.Model.Set {
			e.FieldStart("model")
			s.Model.Encode(e)
		}
	}
	{
		if s.Provider.Set {
			e.FieldStart("provider")
			s.Provider.Encode(e)
		}
	}
	{
		if s.Tags != nil {
			e.FieldStart("tags")
			e.ArrStart()
			for _, elem := range s.Tags {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Usage.Set {
			e.FieldStart("usage")
			s.Usage.Encode(e)
		}
	}
	{
		if s.ErrorInfo.Set {
			e.FieldStart("error_info")
			s.ErrorInfo.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.LastUpdatedAt.Set {
			e.FieldStart("last_updated_at")
			s.LastUpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.CreatedBy.Set {
			e.FieldStart("created_by")
			s.CreatedBy.Encode(e)
		}
	}
	{
		if s.LastUpdatedBy.Set {
			e.FieldStart("last_updated_by")
			s.LastUpdatedBy.Encode(e)
		}
	}
	{
		if s.FeedbackScores != nil {
			e.FieldStart("feedback_scores")
			e.ArrStart()
			for _, elem := range s.FeedbackScores {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Comments != nil {
			e.FieldStart("comments")
			e.ArrStart()
			for _, elem := range s.Comments {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.TotalEstimatedCost.Set {
			e.FieldStart("total_estimated_cost")
			s.TotalEstimatedCost.Encode(e)
		}
	}
	{
		if s.TotalEstimatedCostVersion.Set {
			e.FieldStart("total_estimated_cost_version")
			s.TotalEstimatedCostVersion.Encode(e)
		}
	}
	{
		if s.Duration.Set {
			e.FieldStart("duration")
			s.Duration.Encode(e)
		}
	}
}

var jsonFieldsNameOfSpanPublic = [26]string{
	0:  "id",
	1:  "project_name",
	2:  "project_id",
	3:  "trace_id",
	4:  "parent_span_id",
	5:  "name",
	6:  "type",
	7:  "start_time",
	8:  "end_time",
	9:  "input",
	10: "output",
	11: "metadata",
	12: "model",
	13: "provider",
	14: "tags",
	15: "usage",
	16: "error_info",
	17: "created_at",
	18: "last_updated_at",
	19: "created_by",
	20: "last_updated_by",
	21: "feedback_scores",
	22: "comments",
	23: "total_estimated_cost",
	24: "total_estimated_cost_version",
	25: "duration",
}

// Decode decodes SpanPublic from json.
func (s *SpanPublic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpanPublic to nil")
	}
	var requiredBitSet [4]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "project_name":
			if err := func() error {
				s.ProjectName.Reset()
				if err := s.ProjectName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"project_name\"")
			}
		case "project_id":
			if err := func() error {
				s.ProjectID.Reset()
				if err := s.ProjectID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"project_id\"")
			}
		case "trace_id":
			if err := func() error {
				s.TraceID.Reset()
				if err := s.TraceID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trace_id\"")
			}
		case "parent_span_id":
			if err := func() error {
				s.ParentSpanID.Reset()
				if err := s.ParentSpanID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parent_span_id\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "start_time":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.StartTime = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start_time\"")
			}
		case "end_time":
			if err := func() error {
				s.EndTime.Reset()
				if err := s.EndTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end_time\"")
			}
		case "input":
			if err := func() error {
				if err := s.Input.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"input\"")
			}
		case "output":
			if err := func() error {
				if err := s.Output.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"output\"")
			}
		case "metadata":
			if err := func() error {
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "model":
			if err := func() error {
				s.Model.Reset()
				if err := s.Model.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"model\"")
			}
		case "provider":
			if err := func() error {
				s.Provider.Reset()
				if err := s.Provider.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"provider\"")
			}
		case "tags":
			if err := func() error {
				s.Tags = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Tags = append(s.Tags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		case "usage":
			if err := func() error {
				s.Usage.Reset()
				if err := s.Usage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usage\"")
			}
		case "error_info":
			if err := func() error {
				s.ErrorInfo.Reset()
				if err := s.ErrorInfo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error_info\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "last_updated_at":
			if err := func() error {
				s.LastUpdatedAt.Reset()
				if err := s.LastUpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated_at\"")
			}
		case "created_by":
			if err := func() error {
				s.CreatedBy.Reset()
				if err := s.CreatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_by\"")
			}
		case "last_updated_by":
			if err := func() error {
				s.LastUpdatedBy.Reset()
				if err := s.LastUpdatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated_by\"")
			}
		case "feedback_scores":
			if err := func() error {
				s.FeedbackScores = make([]FeedbackScorePublic, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem FeedbackScorePublic
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.FeedbackScores = append(s.FeedbackScores, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"feedback_scores\"")
			}
		case "comments":
			if err := func() error {
				s.Comments = make([]CommentPublic, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CommentPublic
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Comments = append(s.Comments, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comments\"")
			}
		case "total_estimated_cost":
			if err := func() error {
				s.TotalEstimatedCost.Reset()
				if err := s.TotalEstimatedCost.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_estimated_cost\"")
			}
		case "total_estimated_cost_version":
			if err := func() error {
				s.TotalEstimatedCostVersion.Reset()
				if err := s.TotalEstimatedCostVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_estimated_cost_version\"")
			}
		case "duration":
			if err := func() error {
				s.Duration.Reset()
				if err := s.Duration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SpanPublic")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b10000000,
		0b00000000,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSpanPublic) {
					name = jsonFieldsNameOfSpanPublic[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SpanPublic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpanPublic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SpanPublicType as json.
func (s SpanPublicType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SpanPublicType from json.
func (s *SpanPublicType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpanPublicType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SpanPublicType(v) {
	case SpanPublicTypeGeneral:
		*s = SpanPublicTypeGeneral
	case SpanPublicTypeTool:
		*s = SpanPublicTypeTool
	case SpanPublicTypeLlm:
		*s = SpanPublicTypeLlm
	case SpanPublicTypeGuardrail:
		*s = SpanPublicTypeGuardrail
	default:
		*s = SpanPublicType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SpanPublicType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpanPublicType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SpanPublicUsage) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SpanPublicUsage) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Int32(elem)
	}
}

// Decode decodes SpanPublicUsage from json.
func (s *SpanPublicUsage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpanPublicUsage to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem int32
		if err := func() error {
			v, err := d.Int32()
			elem = int32(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SpanPublicUsage")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SpanPublicUsage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpanPublicUsage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SpanUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SpanUpdate) encodeFields(e *jx.Encoder) {
	{
		if s.ProjectName.Set {
			e.FieldStart("project_name")
			s.ProjectName.Encode(e)
		}
	}
	{
		if s.ProjectID.Set {
			e.FieldStart("project_id")
			s.ProjectID.Encode(e)
		}
	}
	{
		e.FieldStart("trace_id")
		json.EncodeUUID(e, s.TraceID)
	}
	{
		if s.ParentSpanID.Set {
			e.FieldStart("parent_span_id")
			s.ParentSpanID.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.EndTime.Set {
			e.FieldStart("end_time")
			s.EndTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("input")
		s.Input.Encode(e)
	}
	{
		e.FieldStart("output")
		s.Output.Encode(e)
	}
	{
		e.FieldStart("metadata")
		s.Metadata.Encode(e)
	}
	{
		if s.Model.Set {
			e.FieldStart("model")
			s.Model.Encode(e)
		}
	}
	{
		if s.Provider.Set {
			e.FieldStart("provider")
			s.Provider.Encode(e)
		}
	}
	{
		if s.Tags != nil {
			e.FieldStart("tags")
			e.ArrStart()
			for _, elem := range s.Tags {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Usage.Set {
			e.FieldStart("usage")
			s.Usage.Encode(e)
		}
	}
	{
		if s.TotalEstimatedCost.Set {
			e.FieldStart("total_estimated_cost")
			s.TotalEstimatedCost.Encode(e)
		}
	}
	{
		if s.ErrorInfo.Set {
			e.FieldStart("error_info")
			s.ErrorInfo.Encode(e)
		}
	}
}

var jsonFieldsNameOfSpanUpdate = [16]string{
	0:  "project_name",
	1:  "project_id",
	2:  "trace_id",
	3:  "parent_span_id",
	4:  "name",
	5:  "type",
	6:  "end_time",
	7:  "input",
	8:  "output",
	9:  "metadata",
	10: "model",
	11: "provider",
	12: "tags",
	13: "usage",
	14: "total_estimated_cost",
	15: "error_info",
}

// Decode decodes SpanUpdate from json.
func (s *SpanUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpanUpdate to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "project_name":
			if err := func() error {
				s.ProjectName.Reset()
				if err := s.ProjectName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"project_name\"")
			}
		case "project_id":
			if err := func() error {
				s.ProjectID.Reset()
				if err := s.ProjectID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"project_id\"")
			}
		case "trace_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.TraceID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trace_id\"")
			}
		case "parent_span_id":
			if err := func() error {
				s.ParentSpanID.Reset()
				if err := s.ParentSpanID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parent_span_id\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "end_time":
			if err := func() error {
				s.EndTime.Reset()
				if err := s.EndTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end_time\"")
			}
		case "input":
			if err := func() error {
				if err := s.Input.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"input\"")
			}
		case "output":
			if err := func() error {
				if err := s.Output.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"output\"")
			}
		case "metadata":
			if err := func() error {
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "model":
			if err := func() error {
				s.Model.Reset()
				if err := s.Model.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"model\"")
			}
		case "provider":
			if err := func() error {
				s.Provider.Reset()
				if err := s.Provider.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"provider\"")
			}
		case "tags":
			if err := func() error {
				s.Tags = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Tags = append(s.Tags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		case "usage":
			if err := func() error {
				s.Usage.Reset()
				if err := s.Usage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usage\"")
			}
		case "total_estimated_cost":
			if err := func() error {
				s.TotalEstimatedCost.Reset()
				if err := s.TotalEstimatedCost.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_estimated_cost\"")
			}
		case "error_info":
			if err := func() error {
				s.ErrorInfo.Reset()
				if err := s.ErrorInfo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error_info\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SpanUpdate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000100,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSpanUpdate) {
					name = jsonFieldsNameOfSpanUpdate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SpanUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpanUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SpanUpdateType as json.
func (s SpanUpdateType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SpanUpdateType from json.
func (s *SpanUpdateType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpanUpdateType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SpanUpdateType(v) {
	case SpanUpdateTypeGeneral:
		*s = SpanUpdateTypeGeneral
	case SpanUpdateTypeTool:
		*s = SpanUpdateTypeTool
	case SpanUpdateTypeLlm:
		*s = SpanUpdateTypeLlm
	case SpanUpdateTypeGuardrail:
		*s = SpanUpdateTypeGuardrail
	default:
		*s = SpanUpdateType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SpanUpdateType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpanUpdateType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SpanUpdateUsage) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SpanUpdateUsage) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Int32(elem)
	}
}

// Decode decodes SpanUpdateUsage from json.
func (s *SpanUpdateUsage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpanUpdateUsage to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem int32
		if err := func() error {
			v, err := d.Int32()
			elem = int32(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SpanUpdateUsage")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SpanUpdateUsage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpanUpdateUsage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SpanWrite) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SpanWrite) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.ProjectName.Set {
			e.FieldStart("project_name")
			s.ProjectName.Encode(e)
		}
	}
	{
		if s.TraceID.Set {
			e.FieldStart("trace_id")
			s.TraceID.Encode(e)
		}
	}
	{
		if s.ParentSpanID.Set {
			e.FieldStart("parent_span_id")
			s.ParentSpanID.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		e.FieldStart("start_time")
		json.EncodeDateTime(e, s.StartTime)
	}
	{
		if s.EndTime.Set {
			e.FieldStart("end_time")
			s.EndTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("input")
		s.Input.Encode(e)
	}
	{
		e.FieldStart("output")
		s.Output.Encode(e)
	}
	{
		e.FieldStart("metadata")
		s.Metadata.Encode(e)
	}
	{
		if s.Model.Set {
			e.FieldStart("model")
			s.Model.Encode(e)
		}
	}
	{
		if s.Provider.Set {
			e.FieldStart("provider")
			s.Provider.Encode(e)
		}
	}
	{
		if s.Tags != nil {
			e.FieldStart("tags")
			e.ArrStart()
			for _, elem := range s.Tags {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Usage.Set {
			e.FieldStart("usage")
			s.Usage.Encode(e)
		}
	}
	{
		if s.ErrorInfo.Set {
			e.FieldStart("error_info")
			s.ErrorInfo.Encode(e)
		}
	}
	{
		if s.LastUpdatedAt.Set {
			e.FieldStart("last_updated_at")
			s.LastUpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.TotalEstimatedCost.Set {
			e.FieldStart("total_estimated_cost")
			s.TotalEstimatedCost.Encode(e)
		}
	}
	{
		if s.TotalEstimatedCostVersion.Set {
			e.FieldStart("total_estimated_cost_version")
			s.TotalEstimatedCostVersion.Encode(e)
		}
	}
}

var jsonFieldsNameOfSpanWrite = [19]string{
	0:  "id",
	1:  "project_name",
	2:  "trace_id",
	3:  "parent_span_id",
	4:  "name",
	5:  "type",
	6:  "start_time",
	7:  "end_time",
	8:  "input",
	9:  "output",
	10: "metadata",
	11: "model",
	12: "provider",
	13: "tags",
	14: "usage",
	15: "error_info",
	16: "last_updated_at",
	17: "total_estimated_cost",
	18: "total_estimated_cost_version",
}

// Decode decodes SpanWrite from json.
func (s *SpanWrite) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpanWrite to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "project_name":
			if err := func() error {
				s.ProjectName.Reset()
				if err := s.ProjectName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"project_name\"")
			}
		case "trace_id":
			if err := func() error {
				s.TraceID.Reset()
				if err := s.TraceID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trace_id\"")
			}
		case "parent_span_id":
			if err := func() error {
				s.ParentSpanID.Reset()
				if err := s.ParentSpanID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parent_span_id\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "start_time":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.StartTime = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start_time\"")
			}
		case "end_time":
			if err := func() error {
				s.EndTime.Reset()
				if err := s.EndTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end_time\"")
			}
		case "input":
			if err := func() error {
				if err := s.Input.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"input\"")
			}
		case "output":
			if err := func() error {
				if err := s.Output.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"output\"")
			}
		case "metadata":
			if err := func() error {
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "model":
			if err := func() error {
				s.Model.Reset()
				if err := s.Model.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"model\"")
			}
		case "provider":
			if err := func() error {
				s.Provider.Reset()
				if err := s.Provider.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"provider\"")
			}
		case "tags":
			if err := func() error {
				s.Tags = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Tags = append(s.Tags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		case "usage":
			if err := func() error {
				s.Usage.Reset()
				if err := s.Usage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usage\"")
			}
		case "error_info":
			if err := func() error {
				s.ErrorInfo.Reset()
				if err := s.ErrorInfo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error_info\"")
			}
		case "last_updated_at":
			if err := func() error {
				s.LastUpdatedAt.Reset()
				if err := s.LastUpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated_at\"")
			}
		case "total_estimated_cost":
			if err := func() error {
				s.TotalEstimatedCost.Reset()
				if err := s.TotalEstimatedCost.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_estimated_cost\"")
			}
		case "total_estimated_cost_version":
			if err := func() error {
				s.TotalEstimatedCostVersion.Reset()
				if err := s.TotalEstimatedCostVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_estimated_cost_version\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SpanWrite")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b01000000,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSpanWrite) {
					name = jsonFieldsNameOfSpanWrite[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SpanWrite) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpanWrite) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SpanWriteType as json.
func (s SpanWriteType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SpanWriteType from json.
func (s *SpanWriteType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpanWriteType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SpanWriteType(v) {
	case SpanWriteTypeGeneral:
		*s = SpanWriteTypeGeneral
	case SpanWriteTypeTool:
		*s = SpanWriteTypeTool
	case SpanWriteTypeLlm:
		*s = SpanWriteTypeLlm
	case SpanWriteTypeGuardrail:
		*s = SpanWriteTypeGuardrail
	default:
		*s = SpanWriteType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SpanWriteType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpanWriteType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SpanWriteUsage) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SpanWriteUsage) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Int32(elem)
	}
}

// Decode decodes SpanWriteUsage from json.
func (s *SpanWriteUsage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpanWriteUsage to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem int32
		if err := func() error {
			v, err := d.Int32()
			elem = int32(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SpanWriteUsage")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SpanWriteUsage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpanWriteUsage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SpansCountResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SpansCountResponse) encodeFields(e *jx.Encoder) {
	{
		if s.WorkspacesSpansCount != nil {
			e.FieldStart("workspaces_spans_count")
			e.ArrStart()
			for _, elem := range s.WorkspacesSpansCount {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfSpansCountResponse = [1]string{
	0: "workspaces_spans_count",
}

// Decode decodes SpansCountResponse from json.
func (s *SpansCountResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpansCountResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "workspaces_spans_count":
			if err := func() error {
				s.WorkspacesSpansCount = make([]WorkspaceSpansCount, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem WorkspaceSpansCount
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.WorkspacesSpansCount = append(s.WorkspacesSpansCount, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"workspaces_spans_count\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SpansCountResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SpansCountResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpansCountResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StartMultiPartUploadForbidden as json.
func (s *StartMultiPartUploadForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessage)(s)

	unwrapped.Encode(e)
}

// Decode decodes StartMultiPartUploadForbidden from json.
func (s *StartMultiPartUploadForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StartMultiPartUploadForbidden to nil")
	}
	var unwrapped ErrorMessage
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = StartMultiPartUploadForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StartMultiPartUploadForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StartMultiPartUploadForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StartMultiPartUploadUnauthorized as json.
func (s *StartMultiPartUploadUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessage)(s)

	unwrapped.Encode(e)
}

// Decode decodes StartMultiPartUploadUnauthorized from json.
func (s *StartMultiPartUploadUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StartMultiPartUploadUnauthorized to nil")
	}
	var unwrapped ErrorMessage
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = StartMultiPartUploadUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StartMultiPartUploadUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StartMultiPartUploadUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *StartMultipartUploadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *StartMultipartUploadRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("file_name")
		e.Str(s.FileName)
	}
	{
		e.FieldStart("num_of_file_parts")
		e.Int32(s.NumOfFileParts)
	}
	{
		if s.MimeType.Set {
			e.FieldStart("mime_type")
			s.MimeType.Encode(e)
		}
	}
	{
		if s.ProjectName.Set {
			e.FieldStart("project_name")
			s.ProjectName.Encode(e)
		}
	}
	{
		e.FieldStart("entity_type")
		s.EntityType.Encode(e)
	}
	{
		e.FieldStart("entity_id")
		json.EncodeUUID(e, s.EntityID)
	}
	{
		if s.ContainerID.Set {
			e.FieldStart("container_id")
			s.ContainerID.Encode(e)
		}
	}
	{
		e.FieldStart("path")
		e.Str(s.Path)
	}
}

var jsonFieldsNameOfStartMultipartUploadRequest = [8]string{
	0: "file_name",
	1: "num_of_file_parts",
	2: "mime_type",
	3: "project_name",
	4: "entity_type",
	5: "entity_id",
	6: "container_id",
	7: "path",
}

// Decode decodes StartMultipartUploadRequest from json.
func (s *StartMultipartUploadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StartMultipartUploadRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "file_name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.FileName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_name\"")
			}
		case "num_of_file_parts":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.NumOfFileParts = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"num_of_file_parts\"")
			}
		case "mime_type":
			if err := func() error {
				s.MimeType.Reset()
				if err := s.MimeType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mime_type\"")
			}
		case "project_name":
			if err := func() error {
				s.ProjectName.Reset()
				if err := s.ProjectName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"project_name\"")
			}
		case "entity_type":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.EntityType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"entity_type\"")
			}
		case "entity_id":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.EntityID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"entity_id\"")
			}
		case "container_id":
			if err := func() error {
				s.ContainerID.Reset()
				if err := s.ContainerID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"container_id\"")
			}
		case "path":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Path = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode StartMultipartUploadRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b10110011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfStartMultipartUploadRequest) {
					name = jsonFieldsNameOfStartMultipartUploadRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StartMultipartUploadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StartMultipartUploadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StartMultipartUploadRequestEntityType as json.
func (s StartMultipartUploadRequestEntityType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes StartMultipartUploadRequestEntityType from json.
func (s *StartMultipartUploadRequestEntityType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StartMultipartUploadRequestEntityType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch StartMultipartUploadRequestEntityType(v) {
	case StartMultipartUploadRequestEntityTypeTrace:
		*s = StartMultipartUploadRequestEntityTypeTrace
	case StartMultipartUploadRequestEntityTypeSpan:
		*s = StartMultipartUploadRequestEntityTypeSpan
	default:
		*s = StartMultipartUploadRequestEntityType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s StartMultipartUploadRequestEntityType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StartMultipartUploadRequestEntityType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *StartMultipartUploadResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *StartMultipartUploadResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("upload_id")
		e.Str(s.UploadID)
	}
	{
		e.FieldStart("pre_sign_urls")
		e.ArrStart()
		for _, elem := range s.PreSignUrls {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfStartMultipartUploadResponse = [2]string{
	0: "upload_id",
	1: "pre_sign_urls",
}

// Decode decodes StartMultipartUploadResponse from json.
func (s *StartMultipartUploadResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StartMultipartUploadResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "upload_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.UploadID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"upload_id\"")
			}
		case "pre_sign_urls":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.PreSignUrls = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.PreSignUrls = append(s.PreSignUrls, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pre_sign_urls\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode StartMultipartUploadResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfStartMultipartUploadResponse) {
					name = jsonFieldsNameOfStartMultipartUploadResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StartMultipartUploadResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StartMultipartUploadResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StoreLlmProviderApiKeyForbidden as json.
func (s *StoreLlmProviderApiKeyForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessage)(s)

	unwrapped.Encode(e)
}

// Decode decodes StoreLlmProviderApiKeyForbidden from json.
func (s *StoreLlmProviderApiKeyForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StoreLlmProviderApiKeyForbidden to nil")
	}
	var unwrapped ErrorMessage
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = StoreLlmProviderApiKeyForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StoreLlmProviderApiKeyForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StoreLlmProviderApiKeyForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StoreLlmProviderApiKeyUnauthorized as json.
func (s *StoreLlmProviderApiKeyUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessage)(s)

	unwrapped.Encode(e)
}

// Decode decodes StoreLlmProviderApiKeyUnauthorized from json.
func (s *StoreLlmProviderApiKeyUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StoreLlmProviderApiKeyUnauthorized to nil")
	}
	var unwrapped ErrorMessage
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = StoreLlmProviderApiKeyUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StoreLlmProviderApiKeyUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StoreLlmProviderApiKeyUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *StreamOptions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *StreamOptions) encodeFields(e *jx.Encoder) {
	{
		if s.IncludeUsage.Set {
			e.FieldStart("include_usage")
			s.IncludeUsage.Encode(e)
		}
	}
}

var jsonFieldsNameOfStreamOptions = [1]string{
	0: "include_usage",
}

// Decode decodes StreamOptions from json.
func (s *StreamOptions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StreamOptions to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "include_usage":
			if err := func() error {
				s.IncludeUsage.Reset()
				if err := s.IncludeUsage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"include_usage\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode StreamOptions")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StreamOptions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StreamOptions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *StudioEvaluationPublic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *StudioEvaluationPublic) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("metrics")
		e.ArrStart()
		for _, elem := range s.Metrics {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfStudioEvaluationPublic = [1]string{
	0: "metrics",
}

// Decode decodes StudioEvaluationPublic from json.
func (s *StudioEvaluationPublic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StudioEvaluationPublic to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "metrics":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Metrics = make([]StudioMetricPublic, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem StudioMetricPublic
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Metrics = append(s.Metrics, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metrics\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode StudioEvaluationPublic")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfStudioEvaluationPublic) {
					name = jsonFieldsNameOfStudioEvaluationPublic[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StudioEvaluationPublic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StudioEvaluationPublic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *StudioEvaluationWrite) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *StudioEvaluationWrite) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("metrics")
		e.ArrStart()
		for _, elem := range s.Metrics {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfStudioEvaluationWrite = [1]string{
	0: "metrics",
}

// Decode decodes StudioEvaluationWrite from json.
func (s *StudioEvaluationWrite) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StudioEvaluationWrite to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "metrics":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Metrics = make([]StudioMetricWrite, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem StudioMetricWrite
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Metrics = append(s.Metrics, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metrics\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode StudioEvaluationWrite")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfStudioEvaluationWrite) {
					name = jsonFieldsNameOfStudioEvaluationWrite[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StudioEvaluationWrite) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StudioEvaluationWrite) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *StudioLlmModelPublic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *StudioLlmModelPublic) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("model")
		e.Str(s.Model)
	}
	{
		if s.Parameters.Set {
			e.FieldStart("parameters")
			s.Parameters.Encode(e)
		}
	}
}

var jsonFieldsNameOfStudioLlmModelPublic = [2]string{
	0: "model",
	1: "parameters",
}

// Decode decodes StudioLlmModelPublic from json.
func (s *StudioLlmModelPublic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StudioLlmModelPublic to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "model":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Model = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"model\"")
			}
		case "parameters":
			if err := func() error {
				s.Parameters.Reset()
				if err := s.Parameters.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parameters\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode StudioLlmModelPublic")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfStudioLlmModelPublic) {
					name = jsonFieldsNameOfStudioLlmModelPublic[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StudioLlmModelPublic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StudioLlmModelPublic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *StudioLlmModelWrite) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *StudioLlmModelWrite) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("model")
		e.Str(s.Model)
	}
	{
		if s.Parameters.Set {
			e.FieldStart("parameters")
			s.Parameters.Encode(e)
		}
	}
}

var jsonFieldsNameOfStudioLlmModelWrite = [2]string{
	0: "model",
	1: "parameters",
}

// Decode decodes StudioLlmModelWrite from json.
func (s *StudioLlmModelWrite) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StudioLlmModelWrite to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "model":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Model = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"model\"")
			}
		case "parameters":
			if err := func() error {
				s.Parameters.Reset()
				if err := s.Parameters.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parameters\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode StudioLlmModelWrite")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfStudioLlmModelWrite) {
					name = jsonFieldsNameOfStudioLlmModelWrite[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StudioLlmModelWrite) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StudioLlmModelWrite) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *StudioMessagePublic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *StudioMessagePublic) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("role")
		e.Str(s.Role)
	}
	{
		e.FieldStart("content")
		e.Str(s.Content)
	}
}

var jsonFieldsNameOfStudioMessagePublic = [2]string{
	0: "role",
	1: "content",
}

// Decode decodes StudioMessagePublic from json.
func (s *StudioMessagePublic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StudioMessagePublic to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "role":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Role = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"role\"")
			}
		case "content":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Content = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode StudioMessagePublic")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfStudioMessagePublic) {
					name = jsonFieldsNameOfStudioMessagePublic[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StudioMessagePublic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StudioMessagePublic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *StudioMessageWrite) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *StudioMessageWrite) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("role")
		e.Str(s.Role)
	}
	{
		e.FieldStart("content")
		e.Str(s.Content)
	}
}

var jsonFieldsNameOfStudioMessageWrite = [2]string{
	0: "role",
	1: "content",
}

// Decode decodes StudioMessageWrite from json.
func (s *StudioMessageWrite) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StudioMessageWrite to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "role":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Role = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"role\"")
			}
		case "content":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Content = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode StudioMessageWrite")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfStudioMessageWrite) {
					name = jsonFieldsNameOfStudioMessageWrite[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StudioMessageWrite) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StudioMessageWrite) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *StudioMetricPublic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *StudioMetricPublic) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		if s.Parameters.Set {
			e.FieldStart("parameters")
			s.Parameters.Encode(e)
		}
	}
}

var jsonFieldsNameOfStudioMetricPublic = [2]string{
	0: "type",
	1: "parameters",
}

// Decode decodes StudioMetricPublic from json.
func (s *StudioMetricPublic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StudioMetricPublic to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "parameters":
			if err := func() error {
				s.Parameters.Reset()
				if err := s.Parameters.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parameters\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode StudioMetricPublic")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfStudioMetricPublic) {
					name = jsonFieldsNameOfStudioMetricPublic[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StudioMetricPublic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StudioMetricPublic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *StudioMetricWrite) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *StudioMetricWrite) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		if s.Parameters.Set {
			e.FieldStart("parameters")
			s.Parameters.Encode(e)
		}
	}
}

var jsonFieldsNameOfStudioMetricWrite = [2]string{
	0: "type",
	1: "parameters",
}

// Decode decodes StudioMetricWrite from json.
func (s *StudioMetricWrite) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StudioMetricWrite to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "parameters":
			if err := func() error {
				s.Parameters.Reset()
				if err := s.Parameters.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parameters\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode StudioMetricWrite")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfStudioMetricWrite) {
					name = jsonFieldsNameOfStudioMetricWrite[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StudioMetricWrite) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StudioMetricWrite) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *StudioOptimizerPublic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *StudioOptimizerPublic) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		if s.Parameters.Set {
			e.FieldStart("parameters")
			s.Parameters.Encode(e)
		}
	}
}

var jsonFieldsNameOfStudioOptimizerPublic = [2]string{
	0: "type",
	1: "parameters",
}

// Decode decodes StudioOptimizerPublic from json.
func (s *StudioOptimizerPublic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StudioOptimizerPublic to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "parameters":
			if err := func() error {
				s.Parameters.Reset()
				if err := s.Parameters.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parameters\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode StudioOptimizerPublic")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfStudioOptimizerPublic) {
					name = jsonFieldsNameOfStudioOptimizerPublic[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StudioOptimizerPublic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StudioOptimizerPublic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *StudioOptimizerWrite) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *StudioOptimizerWrite) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		if s.Parameters.Set {
			e.FieldStart("parameters")
			s.Parameters.Encode(e)
		}
	}
}

var jsonFieldsNameOfStudioOptimizerWrite = [2]string{
	0: "type",
	1: "parameters",
}

// Decode decodes StudioOptimizerWrite from json.
func (s *StudioOptimizerWrite) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StudioOptimizerWrite to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "parameters":
			if err := func() error {
				s.Parameters.Reset()
				if err := s.Parameters.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parameters\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode StudioOptimizerWrite")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfStudioOptimizerWrite) {
					name = jsonFieldsNameOfStudioOptimizerWrite[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StudioOptimizerWrite) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StudioOptimizerWrite) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *StudioPromptPublic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *StudioPromptPublic) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("messages")
		e.ArrStart()
		for _, elem := range s.Messages {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfStudioPromptPublic = [1]string{
	0: "messages",
}

// Decode decodes StudioPromptPublic from json.
func (s *StudioPromptPublic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StudioPromptPublic to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "messages":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Messages = make([]StudioMessagePublic, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem StudioMessagePublic
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Messages = append(s.Messages, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"messages\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode StudioPromptPublic")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfStudioPromptPublic) {
					name = jsonFieldsNameOfStudioPromptPublic[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StudioPromptPublic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StudioPromptPublic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *StudioPromptWrite) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *StudioPromptWrite) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("messages")
		e.ArrStart()
		for _, elem := range s.Messages {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfStudioPromptWrite = [1]string{
	0: "messages",
}

// Decode decodes StudioPromptWrite from json.
func (s *StudioPromptWrite) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StudioPromptWrite to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "messages":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Messages = make([]StudioMessageWrite, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem StudioMessageWrite
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Messages = append(s.Messages, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"messages\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode StudioPromptWrite")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfStudioPromptWrite) {
					name = jsonFieldsNameOfStudioPromptWrite[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StudioPromptWrite) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StudioPromptWrite) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Tool) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Tool) encodeFields(e *jx.Encoder) {
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.Function.Set {
			e.FieldStart("function")
			s.Function.Encode(e)
		}
	}
}

var jsonFieldsNameOfTool = [2]string{
	0: "type",
	1: "function",
}

// Decode decodes Tool from json.
func (s *Tool) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Tool to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "function":
			if err := func() error {
				s.Function.Reset()
				if err := s.Function.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"function\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Tool")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Tool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Tool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ToolCall) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ToolCall) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Index.Set {
			e.FieldStart("index")
			s.Index.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.Function.Set {
			e.FieldStart("function")
			s.Function.Encode(e)
		}
	}
}

var jsonFieldsNameOfToolCall = [4]string{
	0: "id",
	1: "index",
	2: "type",
	3: "function",
}

// Decode decodes ToolCall from json.
func (s *ToolCall) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ToolCall to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "index":
			if err := func() error {
				s.Index.Reset()
				if err := s.Index.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"index\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "function":
			if err := func() error {
				s.Function.Reset()
				if err := s.Function.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"function\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ToolCall")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ToolCall) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ToolCall) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ToolCallType as json.
func (s ToolCallType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ToolCallType from json.
func (s *ToolCallType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ToolCallType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ToolCallType(v) {
	case ToolCallTypeFunction:
		*s = ToolCallTypeFunction
	default:
		*s = ToolCallType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ToolCallType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ToolCallType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ToolType as json.
func (s ToolType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ToolType from json.
func (s *ToolType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ToolType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ToolType(v) {
	case ToolTypeFunction:
		*s = ToolTypeFunction
	default:
		*s = ToolType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ToolType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ToolType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TraceBatchUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TraceBatchUpdate) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("ids")
		e.ArrStart()
		for _, elem := range s.Ids {
			json.EncodeUUID(e, elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("update")
		s.Update.Encode(e)
	}
	{
		if s.MergeTags.Set {
			e.FieldStart("merge_tags")
			s.MergeTags.Encode(e)
		}
	}
}

var jsonFieldsNameOfTraceBatchUpdate = [3]string{
	0: "ids",
	1: "update",
	2: "merge_tags",
}

// Decode decodes TraceBatchUpdate from json.
func (s *TraceBatchUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TraceBatchUpdate to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ids":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Ids = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.Ids = append(s.Ids, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ids\"")
			}
		case "update":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Update.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update\"")
			}
		case "merge_tags":
			if err := func() error {
				s.MergeTags.Reset()
				if err := s.MergeTags.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"merge_tags\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TraceBatchUpdate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTraceBatchUpdate) {
					name = jsonFieldsNameOfTraceBatchUpdate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TraceBatchUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TraceBatchUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TraceBatchWrite) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TraceBatchWrite) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("traces")
		e.ArrStart()
		for _, elem := range s.Traces {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfTraceBatchWrite = [1]string{
	0: "traces",
}

// Decode decodes TraceBatchWrite from json.
func (s *TraceBatchWrite) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TraceBatchWrite to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "traces":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Traces = make([]TraceWrite, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem TraceWrite
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Traces = append(s.Traces, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"traces\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TraceBatchWrite")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTraceBatchWrite) {
					name = jsonFieldsNameOfTraceBatchWrite[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TraceBatchWrite) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TraceBatchWrite) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TraceCountResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TraceCountResponse) encodeFields(e *jx.Encoder) {
	{
		if s.WorkspacesTracesCount != nil {
			e.FieldStart("workspaces_traces_count")
			e.ArrStart()
			for _, elem := range s.WorkspacesTracesCount {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfTraceCountResponse = [1]string{
	0: "workspaces_traces_count",
}

// Decode decodes TraceCountResponse from json.
func (s *TraceCountResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TraceCountResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "workspaces_traces_count":
			if err := func() error {
				s.WorkspacesTracesCount = make([]WorkspaceTraceCount, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem WorkspaceTraceCount
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.WorkspacesTracesCount = append(s.WorkspacesTracesCount, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"workspaces_traces_count\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TraceCountResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TraceCountResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TraceCountResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TraceEnrichmentOptions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TraceEnrichmentOptions) encodeFields(e *jx.Encoder) {
	{
		if s.IncludeSpans.Set {
			e.FieldStart("includeSpans")
			s.IncludeSpans.Encode(e)
		}
	}
	{
		if s.IncludeTags.Set {
			e.FieldStart("includeTags")
			s.IncludeTags.Encode(e)
		}
	}
	{
		if s.IncludeFeedbackScores.Set {
			e.FieldStart("includeFeedbackScores")
			s.IncludeFeedbackScores.Encode(e)
		}
	}
	{
		if s.IncludeComments.Set {
			e.FieldStart("includeComments")
			s.IncludeComments.Encode(e)
		}
	}
	{
		if s.IncludeUsage.Set {
			e.FieldStart("includeUsage")
			s.IncludeUsage.Encode(e)
		}
	}
	{
		if s.IncludeMetadata.Set {
			e.FieldStart("includeMetadata")
			s.IncludeMetadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfTraceEnrichmentOptions = [6]string{
	0: "includeSpans",
	1: "includeTags",
	2: "includeFeedbackScores",
	3: "includeComments",
	4: "includeUsage",
	5: "includeMetadata",
}

// Decode decodes TraceEnrichmentOptions from json.
func (s *TraceEnrichmentOptions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TraceEnrichmentOptions to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "includeSpans":
			if err := func() error {
				s.IncludeSpans.Reset()
				if err := s.IncludeSpans.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"includeSpans\"")
			}
		case "includeTags":
			if err := func() error {
				s.IncludeTags.Reset()
				if err := s.IncludeTags.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"includeTags\"")
			}
		case "includeFeedbackScores":
			if err := func() error {
				s.IncludeFeedbackScores.Reset()
				if err := s.IncludeFeedbackScores.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"includeFeedbackScores\"")
			}
		case "includeComments":
			if err := func() error {
				s.IncludeComments.Reset()
				if err := s.IncludeComments.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"includeComments\"")
			}
		case "includeUsage":
			if err := func() error {
				s.IncludeUsage.Reset()
				if err := s.IncludeUsage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"includeUsage\"")
			}
		case "includeMetadata":
			if err := func() error {
				s.IncludeMetadata.Reset()
				if err := s.IncludeMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"includeMetadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TraceEnrichmentOptions")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TraceEnrichmentOptions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TraceEnrichmentOptions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TraceExperimentItemBulkWriteView) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TraceExperimentItemBulkWriteView) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.ProjectName.Set {
			e.FieldStart("project_name")
			s.ProjectName.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		e.FieldStart("start_time")
		json.EncodeDateTime(e, s.StartTime)
	}
	{
		if s.EndTime.Set {
			e.FieldStart("end_time")
			s.EndTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("input")
		s.Input.Encode(e)
	}
	{
		e.FieldStart("output")
		s.Output.Encode(e)
	}
	{
		e.FieldStart("metadata")
		s.Metadata.Encode(e)
	}
	{
		if s.Tags != nil {
			e.FieldStart("tags")
			e.ArrStart()
			for _, elem := range s.Tags {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ErrorInfo.Set {
			e.FieldStart("error_info")
			s.ErrorInfo.Encode(e)
		}
	}
	{
		if s.LastUpdatedAt.Set {
			e.FieldStart("last_updated_at")
			s.LastUpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.ThreadID.Set {
			e.FieldStart("thread_id")
			s.ThreadID.Encode(e)
		}
	}
}

var jsonFieldsNameOfTraceExperimentItemBulkWriteView = [12]string{
	0:  "id",
	1:  "project_name",
	2:  "name",
	3:  "start_time",
	4:  "end_time",
	5:  "input",
	6:  "output",
	7:  "metadata",
	8:  "tags",
	9:  "error_info",
	10: "last_updated_at",
	11: "thread_id",
}

// Decode decodes TraceExperimentItemBulkWriteView from json.
func (s *TraceExperimentItemBulkWriteView) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TraceExperimentItemBulkWriteView to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "project_name":
			if err := func() error {
				s.ProjectName.Reset()
				if err := s.ProjectName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"project_name\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "start_time":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.StartTime = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start_time\"")
			}
		case "end_time":
			if err := func() error {
				s.EndTime.Reset()
				if err := s.EndTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end_time\"")
			}
		case "input":
			if err := func() error {
				if err := s.Input.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"input\"")
			}
		case "output":
			if err := func() error {
				if err := s.Output.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"output\"")
			}
		case "metadata":
			if err := func() error {
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "tags":
			if err := func() error {
				s.Tags = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Tags = append(s.Tags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		case "error_info":
			if err := func() error {
				s.ErrorInfo.Reset()
				if err := s.ErrorInfo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error_info\"")
			}
		case "last_updated_at":
			if err := func() error {
				s.LastUpdatedAt.Reset()
				if err := s.LastUpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated_at\"")
			}
		case "thread_id":
			if err := func() error {
				s.ThreadID.Reset()
				if err := s.ThreadID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thread_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TraceExperimentItemBulkWriteView")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00001000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTraceExperimentItemBulkWriteView) {
					name = jsonFieldsNameOfTraceExperimentItemBulkWriteView[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TraceExperimentItemBulkWriteView) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TraceExperimentItemBulkWriteView) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TraceFilterPublic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TraceFilterPublic) encodeFields(e *jx.Encoder) {
	{
		if s.Field.Set {
			e.FieldStart("field")
			s.Field.Encode(e)
		}
	}
	{
		if s.Operator.Set {
			e.FieldStart("operator")
			s.Operator.Encode(e)
		}
	}
	{
		if s.Key.Set {
			e.FieldStart("key")
			s.Key.Encode(e)
		}
	}
	{
		if s.Value.Set {
			e.FieldStart("value")
			s.Value.Encode(e)
		}
	}
}

var jsonFieldsNameOfTraceFilterPublic = [4]string{
	0: "field",
	1: "operator",
	2: "key",
	3: "value",
}

// Decode decodes TraceFilterPublic from json.
func (s *TraceFilterPublic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TraceFilterPublic to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "field":
			if err := func() error {
				s.Field.Reset()
				if err := s.Field.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"field\"")
			}
		case "operator":
			if err := func() error {
				s.Operator.Reset()
				if err := s.Operator.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operator\"")
			}
		case "key":
			if err := func() error {
				s.Key.Reset()
				if err := s.Key.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TraceFilterPublic")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TraceFilterPublic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TraceFilterPublic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TraceFilterPublicOperator as json.
func (s TraceFilterPublicOperator) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TraceFilterPublicOperator from json.
func (s *TraceFilterPublicOperator) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TraceFilterPublicOperator to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TraceFilterPublicOperator(v) {
	case TraceFilterPublicOperator_0:
		*s = TraceFilterPublicOperator_0
	case TraceFilterPublicOperator_1:
		*s = TraceFilterPublicOperator_1
	case TraceFilterPublicOperator_2:
		*s = TraceFilterPublicOperator_2
	case TraceFilterPublicOperator_3:
		*s = TraceFilterPublicOperator_3
	case TraceFilterPublicOperator_4:
		*s = TraceFilterPublicOperator_4
	case TraceFilterPublicOperator_5:
		*s = TraceFilterPublicOperator_5
	case TraceFilterPublicOperator_6:
		*s = TraceFilterPublicOperator_6
	case TraceFilterPublicOperator_7:
		*s = TraceFilterPublicOperator_7
	case TraceFilterPublicOperator_8:
		*s = TraceFilterPublicOperator_8
	case TraceFilterPublicOperator_9:
		*s = TraceFilterPublicOperator_9
	case TraceFilterPublicOperator_10:
		*s = TraceFilterPublicOperator_10
	case TraceFilterPublicOperator_11:
		*s = TraceFilterPublicOperator_11
	default:
		*s = TraceFilterPublicOperator(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TraceFilterPublicOperator) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TraceFilterPublicOperator) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TracePagePublic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TracePagePublic) encodeFields(e *jx.Encoder) {
	{
		if s.Page.Set {
			e.FieldStart("page")
			s.Page.Encode(e)
		}
	}
	{
		if s.Size.Set {
			e.FieldStart("size")
			s.Size.Encode(e)
		}
	}
	{
		if s.Total.Set {
			e.FieldStart("total")
			s.Total.Encode(e)
		}
	}
	{
		if s.Content != nil {
			e.FieldStart("content")
			e.ArrStart()
			for _, elem := range s.Content {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.SortableBy != nil {
			e.FieldStart("sortableBy")
			e.ArrStart()
			for _, elem := range s.SortableBy {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfTracePagePublic = [5]string{
	0: "page",
	1: "size",
	2: "total",
	3: "content",
	4: "sortableBy",
}

// Decode decodes TracePagePublic from json.
func (s *TracePagePublic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TracePagePublic to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "page":
			if err := func() error {
				s.Page.Reset()
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "size":
			if err := func() error {
				s.Size.Reset()
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "total":
			if err := func() error {
				s.Total.Reset()
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "content":
			if err := func() error {
				s.Content = make([]TracePublic, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem TracePublic
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Content = append(s.Content, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		case "sortableBy":
			if err := func() error {
				s.SortableBy = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.SortableBy = append(s.SortableBy, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sortableBy\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TracePagePublic")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TracePagePublic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TracePagePublic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TracePublic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TracePublic) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.ProjectID.Set {
			e.FieldStart("project_id")
			s.ProjectID.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		e.FieldStart("start_time")
		json.EncodeDateTime(e, s.StartTime)
	}
	{
		if s.EndTime.Set {
			e.FieldStart("end_time")
			s.EndTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("input")
		s.Input.Encode(e)
	}
	{
		e.FieldStart("output")
		s.Output.Encode(e)
	}
	{
		e.FieldStart("metadata")
		s.Metadata.Encode(e)
	}
	{
		if s.Tags != nil {
			e.FieldStart("tags")
			e.ArrStart()
			for _, elem := range s.Tags {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ErrorInfo.Set {
			e.FieldStart("error_info")
			s.ErrorInfo.Encode(e)
		}
	}
	{
		if s.Usage.Set {
			e.FieldStart("usage")
			s.Usage.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.LastUpdatedAt.Set {
			e.FieldStart("last_updated_at")
			s.LastUpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.CreatedBy.Set {
			e.FieldStart("created_by")
			s.CreatedBy.Encode(e)
		}
	}
	{
		if s.LastUpdatedBy.Set {
			e.FieldStart("last_updated_by")
			s.LastUpdatedBy.Encode(e)
		}
	}
	{
		if s.FeedbackScores != nil {
			e.FieldStart("feedback_scores")
			e.ArrStart()
			for _, elem := range s.FeedbackScores {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.SpanFeedbackScores != nil {
			e.FieldStart("span_feedback_scores")
			e.ArrStart()
			for _, elem := range s.SpanFeedbackScores {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Comments != nil {
			e.FieldStart("comments")
			e.ArrStart()
			for _, elem := range s.Comments {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.GuardrailsValidations != nil {
			e.FieldStart("guardrails_validations")
			e.ArrStart()
			for _, elem := range s.GuardrailsValidations {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.TotalEstimatedCost.Set {
			e.FieldStart("total_estimated_cost")
			s.TotalEstimatedCost.Encode(e)
		}
	}
	{
		if s.SpanCount.Set {
			e.FieldStart("span_count")
			s.SpanCount.Encode(e)
		}
	}
	{
		if s.Duration.Set {
			e.FieldStart("duration")
			s.Duration.Encode(e)
		}
	}
	{
		if s.ThreadID.Set {
			e.FieldStart("thread_id")
			s.ThreadID.Encode(e)
		}
	}
	{
		if s.VisibilityMode.Set {
			e.FieldStart("visibility_mode")
			s.VisibilityMode.Encode(e)
		}
	}
	{
		if s.LlmSpanCount.Set {
			e.FieldStart("llm_span_count")
			s.LlmSpanCount.Encode(e)
		}
	}
	{
		if s.HasToolSpans.Set {
			e.FieldStart("has_tool_spans")
			s.HasToolSpans.Encode(e)
		}
	}
	{
		if s.Providers != nil {
			e.FieldStart("providers")
			e.ArrStart()
			for _, elem := range s.Providers {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfTracePublic = [27]string{
	0:  "id",
	1:  "project_id",
	2:  "name",
	3:  "start_time",
	4:  "end_time",
	5:  "input",
	6:  "output",
	7:  "metadata",
	8:  "tags",
	9:  "error_info",
	10: "usage",
	11: "created_at",
	12: "last_updated_at",
	13: "created_by",
	14: "last_updated_by",
	15: "feedback_scores",
	16: "span_feedback_scores",
	17: "comments",
	18: "guardrails_validations",
	19: "total_estimated_cost",
	20: "span_count",
	21: "duration",
	22: "thread_id",
	23: "visibility_mode",
	24: "llm_span_count",
	25: "has_tool_spans",
	26: "providers",
}

// Decode decodes TracePublic from json.
func (s *TracePublic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TracePublic to nil")
	}
	var requiredBitSet [4]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "project_id":
			if err := func() error {
				s.ProjectID.Reset()
				if err := s.ProjectID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"project_id\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "start_time":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.StartTime = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start_time\"")
			}
		case "end_time":
			if err := func() error {
				s.EndTime.Reset()
				if err := s.EndTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end_time\"")
			}
		case "input":
			if err := func() error {
				if err := s.Input.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"input\"")
			}
		case "output":
			if err := func() error {
				if err := s.Output.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"output\"")
			}
		case "metadata":
			if err := func() error {
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "tags":
			if err := func() error {
				s.Tags = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Tags = append(s.Tags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		case "error_info":
			if err := func() error {
				s.ErrorInfo.Reset()
				if err := s.ErrorInfo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error_info\"")
			}
		case "usage":
			if err := func() error {
				s.Usage.Reset()
				if err := s.Usage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usage\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "last_updated_at":
			if err := func() error {
				s.LastUpdatedAt.Reset()
				if err := s.LastUpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated_at\"")
			}
		case "created_by":
			if err := func() error {
				s.CreatedBy.Reset()
				if err := s.CreatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_by\"")
			}
		case "last_updated_by":
			if err := func() error {
				s.LastUpdatedBy.Reset()
				if err := s.LastUpdatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated_by\"")
			}
		case "feedback_scores":
			if err := func() error {
				s.FeedbackScores = make([]FeedbackScorePublic, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem FeedbackScorePublic
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.FeedbackScores = append(s.FeedbackScores, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"feedback_scores\"")
			}
		case "span_feedback_scores":
			if err := func() error {
				s.SpanFeedbackScores = make([]FeedbackScorePublic, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem FeedbackScorePublic
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.SpanFeedbackScores = append(s.SpanFeedbackScores, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"span_feedback_scores\"")
			}
		case "comments":
			if err := func() error {
				s.Comments = make([]CommentPublic, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CommentPublic
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Comments = append(s.Comments, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comments\"")
			}
		case "guardrails_validations":
			if err := func() error {
				s.GuardrailsValidations = make([]GuardrailsValidationPublic, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GuardrailsValidationPublic
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.GuardrailsValidations = append(s.GuardrailsValidations, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"guardrails_validations\"")
			}
		case "total_estimated_cost":
			if err := func() error {
				s.TotalEstimatedCost.Reset()
				if err := s.TotalEstimatedCost.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_estimated_cost\"")
			}
		case "span_count":
			if err := func() error {
				s.SpanCount.Reset()
				if err := s.SpanCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"span_count\"")
			}
		case "duration":
			if err := func() error {
				s.Duration.Reset()
				if err := s.Duration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration\"")
			}
		case "thread_id":
			if err := func() error {
				s.ThreadID.Reset()
				if err := s.ThreadID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thread_id\"")
			}
		case "visibility_mode":
			if err := func() error {
				s.VisibilityMode.Reset()
				if err := s.VisibilityMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"visibility_mode\"")
			}
		case "llm_span_count":
			if err := func() error {
				s.LlmSpanCount.Reset()
				if err := s.LlmSpanCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"llm_span_count\"")
			}
		case "has_tool_spans":
			if err := func() error {
				s.HasToolSpans.Reset()
				if err := s.HasToolSpans.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_tool_spans\"")
			}
		case "providers":
			if err := func() error {
				s.Providers = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Providers = append(s.Providers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"providers\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TracePublic")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b00001000,
		0b00000000,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTracePublic) {
					name = jsonFieldsNameOfTracePublic[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TracePublic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TracePublic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s TracePublicUsage) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s TracePublicUsage) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Int64(elem)
	}
}

// Decode decodes TracePublicUsage from json.
func (s *TracePublicUsage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TracePublicUsage to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem int64
		if err := func() error {
			v, err := d.Int64()
			elem = int64(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TracePublicUsage")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TracePublicUsage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TracePublicUsage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TracePublicVisibilityMode as json.
func (s TracePublicVisibilityMode) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TracePublicVisibilityMode from json.
func (s *TracePublicVisibilityMode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TracePublicVisibilityMode to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TracePublicVisibilityMode(v) {
	case TracePublicVisibilityModeDefault:
		*s = TracePublicVisibilityModeDefault
	case TracePublicVisibilityModeHidden:
		*s = TracePublicVisibilityModeHidden
	default:
		*s = TracePublicVisibilityMode(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TracePublicVisibilityMode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TracePublicVisibilityMode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TraceThread) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TraceThread) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.ProjectID.Set {
			e.FieldStart("project_id")
			s.ProjectID.Encode(e)
		}
	}
	{
		if s.ThreadModelID.Set {
			e.FieldStart("thread_model_id")
			s.ThreadModelID.Encode(e)
		}
	}
	{
		if s.StartTime.Set {
			e.FieldStart("start_time")
			s.StartTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.EndTime.Set {
			e.FieldStart("end_time")
			s.EndTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Duration.Set {
			e.FieldStart("duration")
			s.Duration.Encode(e)
		}
	}
	{
		e.FieldStart("first_message")
		s.FirstMessage.Encode(e)
	}
	{
		e.FieldStart("last_message")
		s.LastMessage.Encode(e)
	}
	{
		if s.FeedbackScores != nil {
			e.FieldStart("feedback_scores")
			e.ArrStart()
			for _, elem := range s.FeedbackScores {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.NumberOfMessages.Set {
			e.FieldStart("number_of_messages")
			s.NumberOfMessages.Encode(e)
		}
	}
	{
		if s.TotalEstimatedCost.Set {
			e.FieldStart("total_estimated_cost")
			s.TotalEstimatedCost.Encode(e)
		}
	}
	{
		if s.Usage.Set {
			e.FieldStart("usage")
			s.Usage.Encode(e)
		}
	}
	{
		if s.Comments != nil {
			e.FieldStart("comments")
			e.ArrStart()
			for _, elem := range s.Comments {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Tags != nil {
			e.FieldStart("tags")
			e.ArrStart()
			for _, elem := range s.Tags {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.LastUpdatedAt.Set {
			e.FieldStart("last_updated_at")
			s.LastUpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.LastUpdatedBy.Set {
			e.FieldStart("last_updated_by")
			s.LastUpdatedBy.Encode(e)
		}
	}
	{
		if s.CreatedBy.Set {
			e.FieldStart("created_by")
			s.CreatedBy.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfTraceThread = [19]string{
	0:  "id",
	1:  "project_id",
	2:  "thread_model_id",
	3:  "start_time",
	4:  "end_time",
	5:  "duration",
	6:  "first_message",
	7:  "last_message",
	8:  "feedback_scores",
	9:  "status",
	10: "number_of_messages",
	11: "total_estimated_cost",
	12: "usage",
	13: "comments",
	14: "tags",
	15: "last_updated_at",
	16: "last_updated_by",
	17: "created_by",
	18: "created_at",
}

// Decode decodes TraceThread from json.
func (s *TraceThread) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TraceThread to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "project_id":
			if err := func() error {
				s.ProjectID.Reset()
				if err := s.ProjectID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"project_id\"")
			}
		case "thread_model_id":
			if err := func() error {
				s.ThreadModelID.Reset()
				if err := s.ThreadModelID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thread_model_id\"")
			}
		case "start_time":
			if err := func() error {
				s.StartTime.Reset()
				if err := s.StartTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start_time\"")
			}
		case "end_time":
			if err := func() error {
				s.EndTime.Reset()
				if err := s.EndTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end_time\"")
			}
		case "duration":
			if err := func() error {
				s.Duration.Reset()
				if err := s.Duration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration\"")
			}
		case "first_message":
			if err := func() error {
				if err := s.FirstMessage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"first_message\"")
			}
		case "last_message":
			if err := func() error {
				if err := s.LastMessage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_message\"")
			}
		case "feedback_scores":
			if err := func() error {
				s.FeedbackScores = make([]FeedbackScore, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem FeedbackScore
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.FeedbackScores = append(s.FeedbackScores, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"feedback_scores\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "number_of_messages":
			if err := func() error {
				s.NumberOfMessages.Reset()
				if err := s.NumberOfMessages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"number_of_messages\"")
			}
		case "total_estimated_cost":
			if err := func() error {
				s.TotalEstimatedCost.Reset()
				if err := s.TotalEstimatedCost.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_estimated_cost\"")
			}
		case "usage":
			if err := func() error {
				s.Usage.Reset()
				if err := s.Usage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usage\"")
			}
		case "comments":
			if err := func() error {
				s.Comments = make([]Comment, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Comment
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Comments = append(s.Comments, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comments\"")
			}
		case "tags":
			if err := func() error {
				s.Tags = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Tags = append(s.Tags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		case "last_updated_at":
			if err := func() error {
				s.LastUpdatedAt.Reset()
				if err := s.LastUpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated_at\"")
			}
		case "last_updated_by":
			if err := func() error {
				s.LastUpdatedBy.Reset()
				if err := s.LastUpdatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated_by\"")
			}
		case "created_by":
			if err := func() error {
				s.CreatedBy.Reset()
				if err := s.CreatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_by\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TraceThread")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TraceThread) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TraceThread) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TraceThreadBatchIdentifier) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TraceThreadBatchIdentifier) encodeFields(e *jx.Encoder) {
	{
		if s.ProjectName.Set {
			e.FieldStart("project_name")
			s.ProjectName.Encode(e)
		}
	}
	{
		if s.ProjectID.Set {
			e.FieldStart("project_id")
			s.ProjectID.Encode(e)
		}
	}
	{
		if s.ThreadID.Set {
			e.FieldStart("thread_id")
			s.ThreadID.Encode(e)
		}
	}
	{
		if s.ThreadIds != nil {
			e.FieldStart("thread_ids")
			e.ArrStart()
			for _, elem := range s.ThreadIds {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfTraceThreadBatchIdentifier = [4]string{
	0: "project_name",
	1: "project_id",
	2: "thread_id",
	3: "thread_ids",
}

// Decode decodes TraceThreadBatchIdentifier from json.
func (s *TraceThreadBatchIdentifier) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TraceThreadBatchIdentifier to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "project_name":
			if err := func() error {
				s.ProjectName.Reset()
				if err := s.ProjectName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"project_name\"")
			}
		case "project_id":
			if err := func() error {
				s.ProjectID.Reset()
				if err := s.ProjectID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"project_id\"")
			}
		case "thread_id":
			if err := func() error {
				s.ThreadID.Reset()
				if err := s.ThreadID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thread_id\"")
			}
		case "thread_ids":
			if err := func() error {
				s.ThreadIds = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.ThreadIds = append(s.ThreadIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thread_ids\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TraceThreadBatchIdentifier")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TraceThreadBatchIdentifier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TraceThreadBatchIdentifier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TraceThreadBatchUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TraceThreadBatchUpdate) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("ids")
		e.ArrStart()
		for _, elem := range s.Ids {
			json.EncodeUUID(e, elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("update")
		s.Update.Encode(e)
	}
	{
		if s.MergeTags.Set {
			e.FieldStart("merge_tags")
			s.MergeTags.Encode(e)
		}
	}
}

var jsonFieldsNameOfTraceThreadBatchUpdate = [3]string{
	0: "ids",
	1: "update",
	2: "merge_tags",
}

// Decode decodes TraceThreadBatchUpdate from json.
func (s *TraceThreadBatchUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TraceThreadBatchUpdate to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ids":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Ids = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.Ids = append(s.Ids, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ids\"")
			}
		case "update":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Update.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update\"")
			}
		case "merge_tags":
			if err := func() error {
				s.MergeTags.Reset()
				if err := s.MergeTags.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"merge_tags\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TraceThreadBatchUpdate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTraceThreadBatchUpdate) {
					name = jsonFieldsNameOfTraceThreadBatchUpdate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TraceThreadBatchUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TraceThreadBatchUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TraceThreadFilterPublic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TraceThreadFilterPublic) encodeFields(e *jx.Encoder) {
	{
		if s.Field.Set {
			e.FieldStart("field")
			s.Field.Encode(e)
		}
	}
	{
		if s.Operator.Set {
			e.FieldStart("operator")
			s.Operator.Encode(e)
		}
	}
	{
		if s.Key.Set {
			e.FieldStart("key")
			s.Key.Encode(e)
		}
	}
	{
		if s.Value.Set {
			e.FieldStart("value")
			s.Value.Encode(e)
		}
	}
}

var jsonFieldsNameOfTraceThreadFilterPublic = [4]string{
	0: "field",
	1: "operator",
	2: "key",
	3: "value",
}

// Decode decodes TraceThreadFilterPublic from json.
func (s *TraceThreadFilterPublic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TraceThreadFilterPublic to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "field":
			if err := func() error {
				s.Field.Reset()
				if err := s.Field.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"field\"")
			}
		case "operator":
			if err := func() error {
				s.Operator.Reset()
				if err := s.Operator.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operator\"")
			}
		case "key":
			if err := func() error {
				s.Key.Reset()
				if err := s.Key.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TraceThreadFilterPublic")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TraceThreadFilterPublic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TraceThreadFilterPublic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TraceThreadFilterPublicOperator as json.
func (s TraceThreadFilterPublicOperator) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TraceThreadFilterPublicOperator from json.
func (s *TraceThreadFilterPublicOperator) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TraceThreadFilterPublicOperator to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TraceThreadFilterPublicOperator(v) {
	case TraceThreadFilterPublicOperator_0:
		*s = TraceThreadFilterPublicOperator_0
	case TraceThreadFilterPublicOperator_1:
		*s = TraceThreadFilterPublicOperator_1
	case TraceThreadFilterPublicOperator_2:
		*s = TraceThreadFilterPublicOperator_2
	case TraceThreadFilterPublicOperator_3:
		*s = TraceThreadFilterPublicOperator_3
	case TraceThreadFilterPublicOperator_4:
		*s = TraceThreadFilterPublicOperator_4
	case TraceThreadFilterPublicOperator_5:
		*s = TraceThreadFilterPublicOperator_5
	case TraceThreadFilterPublicOperator_6:
		*s = TraceThreadFilterPublicOperator_6
	case TraceThreadFilterPublicOperator_7:
		*s = TraceThreadFilterPublicOperator_7
	case TraceThreadFilterPublicOperator_8:
		*s = TraceThreadFilterPublicOperator_8
	case TraceThreadFilterPublicOperator_9:
		*s = TraceThreadFilterPublicOperator_9
	case TraceThreadFilterPublicOperator_10:
		*s = TraceThreadFilterPublicOperator_10
	case TraceThreadFilterPublicOperator_11:
		*s = TraceThreadFilterPublicOperator_11
	default:
		*s = TraceThreadFilterPublicOperator(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TraceThreadFilterPublicOperator) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TraceThreadFilterPublicOperator) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TraceThreadIdentifier) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TraceThreadIdentifier) encodeFields(e *jx.Encoder) {
	{
		if s.ProjectName.Set {
			e.FieldStart("project_name")
			s.ProjectName.Encode(e)
		}
	}
	{
		if s.ProjectID.Set {
			e.FieldStart("project_id")
			s.ProjectID.Encode(e)
		}
	}
	{
		e.FieldStart("thread_id")
		e.Str(s.ThreadID)
	}
	{
		if s.Truncate.Set {
			e.FieldStart("truncate")
			s.Truncate.Encode(e)
		}
	}
}

var jsonFieldsNameOfTraceThreadIdentifier = [4]string{
	0: "project_name",
	1: "project_id",
	2: "thread_id",
	3: "truncate",
}

// Decode decodes TraceThreadIdentifier from json.
func (s *TraceThreadIdentifier) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TraceThreadIdentifier to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "project_name":
			if err := func() error {
				s.ProjectName.Reset()
				if err := s.ProjectName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"project_name\"")
			}
		case "project_id":
			if err := func() error {
				s.ProjectID.Reset()
				if err := s.ProjectID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"project_id\"")
			}
		case "thread_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ThreadID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thread_id\"")
			}
		case "truncate":
			if err := func() error {
				s.Truncate.Reset()
				if err := s.Truncate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"truncate\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TraceThreadIdentifier")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTraceThreadIdentifier) {
					name = jsonFieldsNameOfTraceThreadIdentifier[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TraceThreadIdentifier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TraceThreadIdentifier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TraceThreadPage) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TraceThreadPage) encodeFields(e *jx.Encoder) {
	{
		if s.Page.Set {
			e.FieldStart("page")
			s.Page.Encode(e)
		}
	}
	{
		if s.Size.Set {
			e.FieldStart("size")
			s.Size.Encode(e)
		}
	}
	{
		if s.Total.Set {
			e.FieldStart("total")
			s.Total.Encode(e)
		}
	}
	{
		if s.Content != nil {
			e.FieldStart("content")
			e.ArrStart()
			for _, elem := range s.Content {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.SortableBy != nil {
			e.FieldStart("sortableBy")
			e.ArrStart()
			for _, elem := range s.SortableBy {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfTraceThreadPage = [5]string{
	0: "page",
	1: "size",
	2: "total",
	3: "content",
	4: "sortableBy",
}

// Decode decodes TraceThreadPage from json.
func (s *TraceThreadPage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TraceThreadPage to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "page":
			if err := func() error {
				s.Page.Reset()
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "size":
			if err := func() error {
				s.Size.Reset()
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "total":
			if err := func() error {
				s.Total.Reset()
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "content":
			if err := func() error {
				s.Content = make([]TraceThread, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem TraceThread
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Content = append(s.Content, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		case "sortableBy":
			if err := func() error {
				s.SortableBy = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.SortableBy = append(s.SortableBy, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sortableBy\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TraceThreadPage")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TraceThreadPage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TraceThreadPage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TraceThreadStatus as json.
func (s TraceThreadStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TraceThreadStatus from json.
func (s *TraceThreadStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TraceThreadStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TraceThreadStatus(v) {
	case TraceThreadStatusActive:
		*s = TraceThreadStatusActive
	case TraceThreadStatusInactive:
		*s = TraceThreadStatusInactive
	default:
		*s = TraceThreadStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TraceThreadStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TraceThreadStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TraceThreadUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TraceThreadUpdate) encodeFields(e *jx.Encoder) {
	{
		if s.Tags != nil {
			e.FieldStart("tags")
			e.ArrStart()
			for _, elem := range s.Tags {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfTraceThreadUpdate = [1]string{
	0: "tags",
}

// Decode decodes TraceThreadUpdate from json.
func (s *TraceThreadUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TraceThreadUpdate to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "tags":
			if err := func() error {
				s.Tags = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Tags = append(s.Tags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TraceThreadUpdate")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TraceThreadUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TraceThreadUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s TraceThreadUsage) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s TraceThreadUsage) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Int64(elem)
	}
}

// Decode decodes TraceThreadUsage from json.
func (s *TraceThreadUsage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TraceThreadUsage to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem int64
		if err := func() error {
			v, err := d.Int64()
			elem = int64(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TraceThreadUsage")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TraceThreadUsage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TraceThreadUsage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TraceUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TraceUpdate) encodeFields(e *jx.Encoder) {
	{
		if s.ProjectName.Set {
			e.FieldStart("project_name")
			s.ProjectName.Encode(e)
		}
	}
	{
		if s.ProjectID.Set {
			e.FieldStart("project_id")
			s.ProjectID.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.EndTime.Set {
			e.FieldStart("end_time")
			s.EndTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("input")
		s.Input.Encode(e)
	}
	{
		e.FieldStart("output")
		s.Output.Encode(e)
	}
	{
		e.FieldStart("metadata")
		s.Metadata.Encode(e)
	}
	{
		if s.Tags != nil {
			e.FieldStart("tags")
			e.ArrStart()
			for _, elem := range s.Tags {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ErrorInfo.Set {
			e.FieldStart("error_info")
			s.ErrorInfo.Encode(e)
		}
	}
	{
		if s.ThreadID.Set {
			e.FieldStart("thread_id")
			s.ThreadID.Encode(e)
		}
	}
}

var jsonFieldsNameOfTraceUpdate = [10]string{
	0: "project_name",
	1: "project_id",
	2: "name",
	3: "end_time",
	4: "input",
	5: "output",
	6: "metadata",
	7: "tags",
	8: "error_info",
	9: "thread_id",
}

// Decode decodes TraceUpdate from json.
func (s *TraceUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TraceUpdate to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "project_name":
			if err := func() error {
				s.ProjectName.Reset()
				if err := s.ProjectName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"project_name\"")
			}
		case "project_id":
			if err := func() error {
				s.ProjectID.Reset()
				if err := s.ProjectID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"project_id\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "end_time":
			if err := func() error {
				s.EndTime.Reset()
				if err := s.EndTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end_time\"")
			}
		case "input":
			if err := func() error {
				if err := s.Input.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"input\"")
			}
		case "output":
			if err := func() error {
				if err := s.Output.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"output\"")
			}
		case "metadata":
			if err := func() error {
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "tags":
			if err := func() error {
				s.Tags = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Tags = append(s.Tags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		case "error_info":
			if err := func() error {
				s.ErrorInfo.Reset()
				if err := s.ErrorInfo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error_info\"")
			}
		case "thread_id":
			if err := func() error {
				s.ThreadID.Reset()
				if err := s.ThreadID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thread_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TraceUpdate")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TraceUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TraceUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TraceWrite) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TraceWrite) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.ProjectName.Set {
			e.FieldStart("project_name")
			s.ProjectName.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		e.FieldStart("start_time")
		json.EncodeDateTime(e, s.StartTime)
	}
	{
		if s.EndTime.Set {
			e.FieldStart("end_time")
			s.EndTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("input")
		s.Input.Encode(e)
	}
	{
		e.FieldStart("output")
		s.Output.Encode(e)
	}
	{
		e.FieldStart("metadata")
		s.Metadata.Encode(e)
	}
	{
		if s.Tags != nil {
			e.FieldStart("tags")
			e.ArrStart()
			for _, elem := range s.Tags {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ErrorInfo.Set {
			e.FieldStart("error_info")
			s.ErrorInfo.Encode(e)
		}
	}
	{
		if s.LastUpdatedAt.Set {
			e.FieldStart("last_updated_at")
			s.LastUpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.ThreadID.Set {
			e.FieldStart("thread_id")
			s.ThreadID.Encode(e)
		}
	}
}

var jsonFieldsNameOfTraceWrite = [12]string{
	0:  "id",
	1:  "project_name",
	2:  "name",
	3:  "start_time",
	4:  "end_time",
	5:  "input",
	6:  "output",
	7:  "metadata",
	8:  "tags",
	9:  "error_info",
	10: "last_updated_at",
	11: "thread_id",
}

// Decode decodes TraceWrite from json.
func (s *TraceWrite) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TraceWrite to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "project_name":
			if err := func() error {
				s.ProjectName.Reset()
				if err := s.ProjectName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"project_name\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "start_time":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.StartTime = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start_time\"")
			}
		case "end_time":
			if err := func() error {
				s.EndTime.Reset()
				if err := s.EndTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end_time\"")
			}
		case "input":
			if err := func() error {
				if err := s.Input.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"input\"")
			}
		case "output":
			if err := func() error {
				if err := s.Output.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"output\"")
			}
		case "metadata":
			if err := func() error {
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "tags":
			if err := func() error {
				s.Tags = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Tags = append(s.Tags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		case "error_info":
			if err := func() error {
				s.ErrorInfo.Reset()
				if err := s.ErrorInfo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error_info\"")
			}
		case "last_updated_at":
			if err := func() error {
				s.LastUpdatedAt.Reset()
				if err := s.LastUpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated_at\"")
			}
		case "thread_id":
			if err := func() error {
				s.ThreadID.Reset()
				if err := s.ThreadID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thread_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TraceWrite")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00001000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTraceWrite) {
					name = jsonFieldsNameOfTraceWrite[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TraceWrite) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TraceWrite) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateAlertBadRequest as json.
func (s *UpdateAlertBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessage)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateAlertBadRequest from json.
func (s *UpdateAlertBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateAlertBadRequest to nil")
	}
	var unwrapped ErrorMessage
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateAlertBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateAlertBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateAlertBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateAlertConflict as json.
func (s *UpdateAlertConflict) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessage)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateAlertConflict from json.
func (s *UpdateAlertConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateAlertConflict to nil")
	}
	var unwrapped ErrorMessage
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateAlertConflict(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateAlertConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateAlertConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateAlertUnprocessableEntity as json.
func (s *UpdateAlertUnprocessableEntity) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessage)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateAlertUnprocessableEntity from json.
func (s *UpdateAlertUnprocessableEntity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateAlertUnprocessableEntity to nil")
	}
	var unwrapped ErrorMessage
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateAlertUnprocessableEntity(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateAlertUnprocessableEntity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateAlertUnprocessableEntity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateDatasetVersionBadRequest as json.
func (s *UpdateDatasetVersionBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessagePublic)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateDatasetVersionBadRequest from json.
func (s *UpdateDatasetVersionBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateDatasetVersionBadRequest to nil")
	}
	var unwrapped ErrorMessagePublic
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateDatasetVersionBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateDatasetVersionBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateDatasetVersionBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateDatasetVersionConflict as json.
func (s *UpdateDatasetVersionConflict) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessagePublic)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateDatasetVersionConflict from json.
func (s *UpdateDatasetVersionConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateDatasetVersionConflict to nil")
	}
	var unwrapped ErrorMessagePublic
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateDatasetVersionConflict(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateDatasetVersionConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateDatasetVersionConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateDatasetVersionNotFound as json.
func (s *UpdateDatasetVersionNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessagePublic)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateDatasetVersionNotFound from json.
func (s *UpdateDatasetVersionNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateDatasetVersionNotFound to nil")
	}
	var unwrapped ErrorMessagePublic
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateDatasetVersionNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateDatasetVersionNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateDatasetVersionNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateExperimentBadRequest as json.
func (s *UpdateExperimentBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessage)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateExperimentBadRequest from json.
func (s *UpdateExperimentBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateExperimentBadRequest to nil")
	}
	var unwrapped ErrorMessage
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateExperimentBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateExperimentBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateExperimentBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateExperimentNotFound as json.
func (s *UpdateExperimentNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessage)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateExperimentNotFound from json.
func (s *UpdateExperimentNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateExperimentNotFound to nil")
	}
	var unwrapped ErrorMessage
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateExperimentNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateExperimentNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateExperimentNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateLlmProviderApiKeyForbidden as json.
func (s *UpdateLlmProviderApiKeyForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessage)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateLlmProviderApiKeyForbidden from json.
func (s *UpdateLlmProviderApiKeyForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateLlmProviderApiKeyForbidden to nil")
	}
	var unwrapped ErrorMessage
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateLlmProviderApiKeyForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateLlmProviderApiKeyForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateLlmProviderApiKeyForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateLlmProviderApiKeyNotFound as json.
func (s *UpdateLlmProviderApiKeyNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessage)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateLlmProviderApiKeyNotFound from json.
func (s *UpdateLlmProviderApiKeyNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateLlmProviderApiKeyNotFound to nil")
	}
	var unwrapped ErrorMessage
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateLlmProviderApiKeyNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateLlmProviderApiKeyNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateLlmProviderApiKeyNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateLlmProviderApiKeyUnauthorized as json.
func (s *UpdateLlmProviderApiKeyUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessage)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateLlmProviderApiKeyUnauthorized from json.
func (s *UpdateLlmProviderApiKeyUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateLlmProviderApiKeyUnauthorized to nil")
	}
	var unwrapped ErrorMessage
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateLlmProviderApiKeyUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateLlmProviderApiKeyUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateLlmProviderApiKeyUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateProjectBadRequest as json.
func (s *UpdateProjectBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessage)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateProjectBadRequest from json.
func (s *UpdateProjectBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateProjectBadRequest to nil")
	}
	var unwrapped ErrorMessage
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateProjectBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateProjectBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateProjectBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateProjectUnprocessableEntity as json.
func (s *UpdateProjectUnprocessableEntity) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessage)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateProjectUnprocessableEntity from json.
func (s *UpdateProjectUnprocessableEntity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateProjectUnprocessableEntity to nil")
	}
	var unwrapped ErrorMessage
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateProjectUnprocessableEntity(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateProjectUnprocessableEntity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateProjectUnprocessableEntity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdatePromptBadRequest as json.
func (s *UpdatePromptBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessage)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdatePromptBadRequest from json.
func (s *UpdatePromptBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdatePromptBadRequest to nil")
	}
	var unwrapped ErrorMessage
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdatePromptBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdatePromptBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdatePromptBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdatePromptConflict as json.
func (s *UpdatePromptConflict) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessage)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdatePromptConflict from json.
func (s *UpdatePromptConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdatePromptConflict to nil")
	}
	var unwrapped ErrorMessage
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdatePromptConflict(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdatePromptConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdatePromptConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdatePromptNotFound as json.
func (s *UpdatePromptNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessage)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdatePromptNotFound from json.
func (s *UpdatePromptNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdatePromptNotFound to nil")
	}
	var unwrapped ErrorMessage
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdatePromptNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdatePromptNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdatePromptNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdatePromptUnprocessableEntity as json.
func (s *UpdatePromptUnprocessableEntity) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessage)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdatePromptUnprocessableEntity from json.
func (s *UpdatePromptUnprocessableEntity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdatePromptUnprocessableEntity to nil")
	}
	var unwrapped ErrorMessage
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdatePromptUnprocessableEntity(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdatePromptUnprocessableEntity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdatePromptUnprocessableEntity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpsertWorkspaceConfigurationBadRequest as json.
func (s *UpsertWorkspaceConfigurationBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessage)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpsertWorkspaceConfigurationBadRequest from json.
func (s *UpsertWorkspaceConfigurationBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpsertWorkspaceConfigurationBadRequest to nil")
	}
	var unwrapped ErrorMessage
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpsertWorkspaceConfigurationBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpsertWorkspaceConfigurationBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpsertWorkspaceConfigurationBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpsertWorkspaceConfigurationUnprocessableEntity as json.
func (s *UpsertWorkspaceConfigurationUnprocessableEntity) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorMessage)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpsertWorkspaceConfigurationUnprocessableEntity from json.
func (s *UpsertWorkspaceConfigurationUnprocessableEntity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpsertWorkspaceConfigurationUnprocessableEntity to nil")
	}
	var unwrapped ErrorMessage
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpsertWorkspaceConfigurationUnprocessableEntity(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpsertWorkspaceConfigurationUnprocessableEntity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpsertWorkspaceConfigurationUnprocessableEntity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Usage) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Usage) encodeFields(e *jx.Encoder) {
	{
		if s.TotalTokens.Set {
			e.FieldStart("total_tokens")
			s.TotalTokens.Encode(e)
		}
	}
	{
		if s.PromptTokens.Set {
			e.FieldStart("prompt_tokens")
			s.PromptTokens.Encode(e)
		}
	}
	{
		if s.PromptTokensDetails.Set {
			e.FieldStart("prompt_tokens_details")
			s.PromptTokensDetails.Encode(e)
		}
	}
	{
		if s.CompletionTokens.Set {
			e.FieldStart("completion_tokens")
			s.CompletionTokens.Encode(e)
		}
	}
	{
		if s.CompletionTokensDetails.Set {
			e.FieldStart("completion_tokens_details")
			s.CompletionTokensDetails.Encode(e)
		}
	}
}

var jsonFieldsNameOfUsage = [5]string{
	0: "total_tokens",
	1: "prompt_tokens",
	2: "prompt_tokens_details",
	3: "completion_tokens",
	4: "completion_tokens_details",
}

// Decode decodes Usage from json.
func (s *Usage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Usage to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_tokens":
			if err := func() error {
				s.TotalTokens.Reset()
				if err := s.TotalTokens.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_tokens\"")
			}
		case "prompt_tokens":
			if err := func() error {
				s.PromptTokens.Reset()
				if err := s.PromptTokens.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prompt_tokens\"")
			}
		case "prompt_tokens_details":
			if err := func() error {
				s.PromptTokensDetails.Reset()
				if err := s.PromptTokensDetails.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prompt_tokens_details\"")
			}
		case "completion_tokens":
			if err := func() error {
				s.CompletionTokens.Reset()
				if err := s.CompletionTokens.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completion_tokens\"")
			}
		case "completion_tokens_details":
			if err := func() error {
				s.CompletionTokensDetails.Reset()
				if err := s.CompletionTokensDetails.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completion_tokens_details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Usage")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Usage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Usage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValueEntry) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValueEntry) encodeFields(e *jx.Encoder) {
	{
		if s.Value.Set {
			e.FieldStart("value")
			s.Value.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			e.FieldStart("reason")
			s.Reason.Encode(e)
		}
	}
	{
		if s.CategoryName.Set {
			e.FieldStart("category_name")
			s.CategoryName.Encode(e)
		}
	}
	{
		if s.Source.Set {
			e.FieldStart("source")
			s.Source.Encode(e)
		}
	}
	{
		if s.LastUpdatedAt.Set {
			e.FieldStart("last_updated_at")
			s.LastUpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.SpanType.Set {
			e.FieldStart("span_type")
			s.SpanType.Encode(e)
		}
	}
	{
		if s.SpanID.Set {
			e.FieldStart("span_id")
			s.SpanID.Encode(e)
		}
	}
}

var jsonFieldsNameOfValueEntry = [7]string{
	0: "value",
	1: "reason",
	2: "category_name",
	3: "source",
	4: "last_updated_at",
	5: "span_type",
	6: "span_id",
}

// Decode decodes ValueEntry from json.
func (s *ValueEntry) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValueEntry to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "category_name":
			if err := func() error {
				s.CategoryName.Reset()
				if err := s.CategoryName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"category_name\"")
			}
		case "source":
			if err := func() error {
				s.Source.Reset()
				if err := s.Source.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		case "last_updated_at":
			if err := func() error {
				s.LastUpdatedAt.Reset()
				if err := s.LastUpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated_at\"")
			}
		case "span_type":
			if err := func() error {
				s.SpanType.Reset()
				if err := s.SpanType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"span_type\"")
			}
		case "span_id":
			if err := func() error {
				s.SpanID.Reset()
				if err := s.SpanID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"span_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValueEntry")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValueEntry) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValueEntry) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValueEntryCompare) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValueEntryCompare) encodeFields(e *jx.Encoder) {
	{
		if s.Value.Set {
			e.FieldStart("value")
			s.Value.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			e.FieldStart("reason")
			s.Reason.Encode(e)
		}
	}
	{
		if s.CategoryName.Set {
			e.FieldStart("category_name")
			s.CategoryName.Encode(e)
		}
	}
	{
		if s.Source.Set {
			e.FieldStart("source")
			s.Source.Encode(e)
		}
	}
	{
		if s.LastUpdatedAt.Set {
			e.FieldStart("last_updated_at")
			s.LastUpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.SpanType.Set {
			e.FieldStart("span_type")
			s.SpanType.Encode(e)
		}
	}
	{
		if s.SpanID.Set {
			e.FieldStart("span_id")
			s.SpanID.Encode(e)
		}
	}
}

var jsonFieldsNameOfValueEntryCompare = [7]string{
	0: "value",
	1: "reason",
	2: "category_name",
	3: "source",
	4: "last_updated_at",
	5: "span_type",
	6: "span_id",
}

// Decode decodes ValueEntryCompare from json.
func (s *ValueEntryCompare) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValueEntryCompare to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "category_name":
			if err := func() error {
				s.CategoryName.Reset()
				if err := s.CategoryName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"category_name\"")
			}
		case "source":
			if err := func() error {
				s.Source.Reset()
				if err := s.Source.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		case "last_updated_at":
			if err := func() error {
				s.LastUpdatedAt.Reset()
				if err := s.LastUpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated_at\"")
			}
		case "span_type":
			if err := func() error {
				s.SpanType.Reset()
				if err := s.SpanType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"span_type\"")
			}
		case "span_id":
			if err := func() error {
				s.SpanID.Reset()
				if err := s.SpanID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"span_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValueEntryCompare")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValueEntryCompare) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValueEntryCompare) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ValueEntryCompareSource as json.
func (s ValueEntryCompareSource) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ValueEntryCompareSource from json.
func (s *ValueEntryCompareSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValueEntryCompareSource to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ValueEntryCompareSource(v) {
	case ValueEntryCompareSourceUI:
		*s = ValueEntryCompareSourceUI
	case ValueEntryCompareSourceSdk:
		*s = ValueEntryCompareSourceSdk
	case ValueEntryCompareSourceOnlineScoring:
		*s = ValueEntryCompareSourceOnlineScoring
	default:
		*s = ValueEntryCompareSource(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ValueEntryCompareSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValueEntryCompareSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValueEntryExperimentItemBulkWriteView) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValueEntryExperimentItemBulkWriteView) encodeFields(e *jx.Encoder) {
	{
		if s.Value.Set {
			e.FieldStart("value")
			s.Value.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			e.FieldStart("reason")
			s.Reason.Encode(e)
		}
	}
	{
		if s.CategoryName.Set {
			e.FieldStart("category_name")
			s.CategoryName.Encode(e)
		}
	}
	{
		if s.Source.Set {
			e.FieldStart("source")
			s.Source.Encode(e)
		}
	}
	{
		if s.LastUpdatedAt.Set {
			e.FieldStart("last_updated_at")
			s.LastUpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.SpanType.Set {
			e.FieldStart("span_type")
			s.SpanType.Encode(e)
		}
	}
	{
		if s.SpanID.Set {
			e.FieldStart("span_id")
			s.SpanID.Encode(e)
		}
	}
}

var jsonFieldsNameOfValueEntryExperimentItemBulkWriteView = [7]string{
	0: "value",
	1: "reason",
	2: "category_name",
	3: "source",
	4: "last_updated_at",
	5: "span_type",
	6: "span_id",
}

// Decode decodes ValueEntryExperimentItemBulkWriteView from json.
func (s *ValueEntryExperimentItemBulkWriteView) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValueEntryExperimentItemBulkWriteView to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "category_name":
			if err := func() error {
				s.CategoryName.Reset()
				if err := s.CategoryName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"category_name\"")
			}
		case "source":
			if err := func() error {
				s.Source.Reset()
				if err := s.Source.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		case "last_updated_at":
			if err := func() error {
				s.LastUpdatedAt.Reset()
				if err := s.LastUpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated_at\"")
			}
		case "span_type":
			if err := func() error {
				s.SpanType.Reset()
				if err := s.SpanType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"span_type\"")
			}
		case "span_id":
			if err := func() error {
				s.SpanID.Reset()
				if err := s.SpanID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"span_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValueEntryExperimentItemBulkWriteView")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValueEntryExperimentItemBulkWriteView) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValueEntryExperimentItemBulkWriteView) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ValueEntryExperimentItemBulkWriteViewSource as json.
func (s ValueEntryExperimentItemBulkWriteViewSource) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ValueEntryExperimentItemBulkWriteViewSource from json.
func (s *ValueEntryExperimentItemBulkWriteViewSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValueEntryExperimentItemBulkWriteViewSource to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ValueEntryExperimentItemBulkWriteViewSource(v) {
	case ValueEntryExperimentItemBulkWriteViewSourceUI:
		*s = ValueEntryExperimentItemBulkWriteViewSourceUI
	case ValueEntryExperimentItemBulkWriteViewSourceSdk:
		*s = ValueEntryExperimentItemBulkWriteViewSourceSdk
	case ValueEntryExperimentItemBulkWriteViewSourceOnlineScoring:
		*s = ValueEntryExperimentItemBulkWriteViewSourceOnlineScoring
	default:
		*s = ValueEntryExperimentItemBulkWriteViewSource(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ValueEntryExperimentItemBulkWriteViewSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValueEntryExperimentItemBulkWriteViewSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValueEntryPublic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValueEntryPublic) encodeFields(e *jx.Encoder) {
	{
		if s.Value.Set {
			e.FieldStart("value")
			s.Value.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			e.FieldStart("reason")
			s.Reason.Encode(e)
		}
	}
	{
		if s.CategoryName.Set {
			e.FieldStart("category_name")
			s.CategoryName.Encode(e)
		}
	}
	{
		if s.Source.Set {
			e.FieldStart("source")
			s.Source.Encode(e)
		}
	}
	{
		if s.LastUpdatedAt.Set {
			e.FieldStart("last_updated_at")
			s.LastUpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.SpanType.Set {
			e.FieldStart("span_type")
			s.SpanType.Encode(e)
		}
	}
	{
		if s.SpanID.Set {
			e.FieldStart("span_id")
			s.SpanID.Encode(e)
		}
	}
}

var jsonFieldsNameOfValueEntryPublic = [7]string{
	0: "value",
	1: "reason",
	2: "category_name",
	3: "source",
	4: "last_updated_at",
	5: "span_type",
	6: "span_id",
}

// Decode decodes ValueEntryPublic from json.
func (s *ValueEntryPublic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValueEntryPublic to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "category_name":
			if err := func() error {
				s.CategoryName.Reset()
				if err := s.CategoryName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"category_name\"")
			}
		case "source":
			if err := func() error {
				s.Source.Reset()
				if err := s.Source.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		case "last_updated_at":
			if err := func() error {
				s.LastUpdatedAt.Reset()
				if err := s.LastUpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated_at\"")
			}
		case "span_type":
			if err := func() error {
				s.SpanType.Reset()
				if err := s.SpanType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"span_type\"")
			}
		case "span_id":
			if err := func() error {
				s.SpanID.Reset()
				if err := s.SpanID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"span_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValueEntryPublic")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValueEntryPublic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValueEntryPublic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ValueEntryPublicSource as json.
func (s ValueEntryPublicSource) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ValueEntryPublicSource from json.
func (s *ValueEntryPublicSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValueEntryPublicSource to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ValueEntryPublicSource(v) {
	case ValueEntryPublicSourceUI:
		*s = ValueEntryPublicSourceUI
	case ValueEntryPublicSourceSdk:
		*s = ValueEntryPublicSourceSdk
	case ValueEntryPublicSourceOnlineScoring:
		*s = ValueEntryPublicSourceOnlineScoring
	default:
		*s = ValueEntryPublicSource(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ValueEntryPublicSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValueEntryPublicSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ValueEntrySource as json.
func (s ValueEntrySource) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ValueEntrySource from json.
func (s *ValueEntrySource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValueEntrySource to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ValueEntrySource(v) {
	case ValueEntrySourceUI:
		*s = ValueEntrySourceUI
	case ValueEntrySourceSdk:
		*s = ValueEntrySourceSdk
	case ValueEntrySourceOnlineScoring:
		*s = ValueEntrySourceOnlineScoring
	default:
		*s = ValueEntrySource(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ValueEntrySource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValueEntrySource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WebhookExamples) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WebhookExamples) encodeFields(e *jx.Encoder) {
	{
		if s.ResponseExamples.Set {
			e.FieldStart("response_examples")
			s.ResponseExamples.Encode(e)
		}
	}
}

var jsonFieldsNameOfWebhookExamples = [1]string{
	0: "response_examples",
}

// Decode decodes WebhookExamples from json.
func (s *WebhookExamples) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WebhookExamples to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response_examples":
			if err := func() error {
				s.ResponseExamples.Reset()
				if err := s.ResponseExamples.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response_examples\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WebhookExamples")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WebhookExamples) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WebhookExamples) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s WebhookExamplesResponseExamples) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s WebhookExamplesResponseExamples) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes WebhookExamplesResponseExamples from json.
func (s *WebhookExamplesResponseExamples) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WebhookExamplesResponseExamples to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem WebhookExamplesResponseExamplesItem
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WebhookExamplesResponseExamples")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s WebhookExamplesResponseExamples) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WebhookExamplesResponseExamples) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WebhookExamplesResponseExamplesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WebhookExamplesResponseExamplesItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfWebhookExamplesResponseExamplesItem = [0]string{}

// Decode decodes WebhookExamplesResponseExamplesItem from json.
func (s *WebhookExamplesResponseExamplesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WebhookExamplesResponseExamplesItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode WebhookExamplesResponseExamplesItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WebhookExamplesResponseExamplesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WebhookExamplesResponseExamplesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WebhookPublic) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WebhookPublic) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		e.FieldStart("url")
		e.Str(s.URL)
	}
	{
		if s.SecretToken.Set {
			e.FieldStart("secret_token")
			s.SecretToken.Encode(e)
		}
	}
	{
		if s.Headers.Set {
			e.FieldStart("headers")
			s.Headers.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.CreatedBy.Set {
			e.FieldStart("created_by")
			s.CreatedBy.Encode(e)
		}
	}
	{
		if s.LastUpdatedAt.Set {
			e.FieldStart("last_updated_at")
			s.LastUpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.LastUpdatedBy.Set {
			e.FieldStart("last_updated_by")
			s.LastUpdatedBy.Encode(e)
		}
	}
}

var jsonFieldsNameOfWebhookPublic = [9]string{
	0: "id",
	1: "name",
	2: "url",
	3: "secret_token",
	4: "headers",
	5: "created_at",
	6: "created_by",
	7: "last_updated_at",
	8: "last_updated_by",
}

// Decode decodes WebhookPublic from json.
func (s *WebhookPublic) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WebhookPublic to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "secret_token":
			if err := func() error {
				s.SecretToken.Reset()
				if err := s.SecretToken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secret_token\"")
			}
		case "headers":
			if err := func() error {
				s.Headers.Reset()
				if err := s.Headers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"headers\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "created_by":
			if err := func() error {
				s.CreatedBy.Reset()
				if err := s.CreatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_by\"")
			}
		case "last_updated_at":
			if err := func() error {
				s.LastUpdatedAt.Reset()
				if err := s.LastUpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated_at\"")
			}
		case "last_updated_by":
			if err := func() error {
				s.LastUpdatedBy.Reset()
				if err := s.LastUpdatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated_by\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WebhookPublic")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000100,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWebhookPublic) {
					name = jsonFieldsNameOfWebhookPublic[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WebhookPublic) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WebhookPublic) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s WebhookPublicHeaders) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s WebhookPublicHeaders) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes WebhookPublicHeaders from json.
func (s *WebhookPublicHeaders) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WebhookPublicHeaders to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WebhookPublicHeaders")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s WebhookPublicHeaders) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WebhookPublicHeaders) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WebhookTestResult) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WebhookTestResult) encodeFields(e *jx.Encoder) {
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("status_code")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.RequestBody.Set {
			e.FieldStart("request_body")
			s.RequestBody.Encode(e)
		}
	}
	{
		if s.ErrorMessage.Set {
			e.FieldStart("error_message")
			s.ErrorMessage.Encode(e)
		}
	}
}

var jsonFieldsNameOfWebhookTestResult = [4]string{
	0: "status",
	1: "status_code",
	2: "request_body",
	3: "error_message",
}

// Decode decodes WebhookTestResult from json.
func (s *WebhookTestResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WebhookTestResult to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "status_code":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status_code\"")
			}
		case "request_body":
			if err := func() error {
				s.RequestBody.Reset()
				if err := s.RequestBody.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"request_body\"")
			}
		case "error_message":
			if err := func() error {
				s.ErrorMessage.Reset()
				if err := s.ErrorMessage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error_message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WebhookTestResult")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WebhookTestResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WebhookTestResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WebhookTestResultStatus as json.
func (s WebhookTestResultStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes WebhookTestResultStatus from json.
func (s *WebhookTestResultStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WebhookTestResultStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch WebhookTestResultStatus(v) {
	case WebhookTestResultStatusSuccess:
		*s = WebhookTestResultStatusSuccess
	case WebhookTestResultStatusFailure:
		*s = WebhookTestResultStatusFailure
	default:
		*s = WebhookTestResultStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s WebhookTestResultStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WebhookTestResultStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WebhookWrite) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WebhookWrite) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		e.FieldStart("url")
		e.Str(s.URL)
	}
	{
		if s.SecretToken.Set {
			e.FieldStart("secret_token")
			s.SecretToken.Encode(e)
		}
	}
	{
		if s.Headers.Set {
			e.FieldStart("headers")
			s.Headers.Encode(e)
		}
	}
}

var jsonFieldsNameOfWebhookWrite = [5]string{
	0: "id",
	1: "name",
	2: "url",
	3: "secret_token",
	4: "headers",
}

// Decode decodes WebhookWrite from json.
func (s *WebhookWrite) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WebhookWrite to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "secret_token":
			if err := func() error {
				s.SecretToken.Reset()
				if err := s.SecretToken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secret_token\"")
			}
		case "headers":
			if err := func() error {
				s.Headers.Reset()
				if err := s.Headers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"headers\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WebhookWrite")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWebhookWrite) {
					name = jsonFieldsNameOfWebhookWrite[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WebhookWrite) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WebhookWrite) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s WebhookWriteHeaders) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s WebhookWriteHeaders) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes WebhookWriteHeaders from json.
func (s *WebhookWriteHeaders) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WebhookWriteHeaders to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WebhookWriteHeaders")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s WebhookWriteHeaders) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WebhookWriteHeaders) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WelcomeWizardSubmission) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WelcomeWizardSubmission) encodeFields(e *jx.Encoder) {
	{
		if s.Role.Set {
			e.FieldStart("role")
			s.Role.Encode(e)
		}
	}
	{
		if s.Integrations != nil {
			e.FieldStart("integrations")
			e.ArrStart()
			for _, elem := range s.Integrations {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Email.Set {
			e.FieldStart("email")
			s.Email.Encode(e)
		}
	}
	{
		if s.JoinBetaProgram.Set {
			e.FieldStart("join_beta_program")
			s.JoinBetaProgram.Encode(e)
		}
	}
}

var jsonFieldsNameOfWelcomeWizardSubmission = [4]string{
	0: "role",
	1: "integrations",
	2: "email",
	3: "join_beta_program",
}

// Decode decodes WelcomeWizardSubmission from json.
func (s *WelcomeWizardSubmission) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WelcomeWizardSubmission to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "role":
			if err := func() error {
				s.Role.Reset()
				if err := s.Role.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"role\"")
			}
		case "integrations":
			if err := func() error {
				s.Integrations = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Integrations = append(s.Integrations, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"integrations\"")
			}
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "join_beta_program":
			if err := func() error {
				s.JoinBetaProgram.Reset()
				if err := s.JoinBetaProgram.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"join_beta_program\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WelcomeWizardSubmission")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WelcomeWizardSubmission) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WelcomeWizardSubmission) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WelcomeWizardTracking) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WelcomeWizardTracking) encodeFields(e *jx.Encoder) {
	{
		if s.Completed.Set {
			e.FieldStart("completed")
			s.Completed.Encode(e)
		}
	}
}

var jsonFieldsNameOfWelcomeWizardTracking = [1]string{
	0: "completed",
}

// Decode decodes WelcomeWizardTracking from json.
func (s *WelcomeWizardTracking) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WelcomeWizardTracking to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "completed":
			if err := func() error {
				s.Completed.Reset()
				if err := s.Completed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completed\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WelcomeWizardTracking")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WelcomeWizardTracking) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WelcomeWizardTracking) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WorkspaceConfiguration) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WorkspaceConfiguration) encodeFields(e *jx.Encoder) {
	{
		if s.TimeoutToMarkThreadAsInactive.Set {
			e.FieldStart("timeout_to_mark_thread_as_inactive")
			s.TimeoutToMarkThreadAsInactive.Encode(e)
		}
	}
	{
		if s.TruncationOnTables.Set {
			e.FieldStart("truncation_on_tables")
			s.TruncationOnTables.Encode(e)
		}
	}
}

var jsonFieldsNameOfWorkspaceConfiguration = [2]string{
	0: "timeout_to_mark_thread_as_inactive",
	1: "truncation_on_tables",
}

// Decode decodes WorkspaceConfiguration from json.
func (s *WorkspaceConfiguration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorkspaceConfiguration to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timeout_to_mark_thread_as_inactive":
			if err := func() error {
				s.TimeoutToMarkThreadAsInactive.Reset()
				if err := s.TimeoutToMarkThreadAsInactive.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timeout_to_mark_thread_as_inactive\"")
			}
		case "truncation_on_tables":
			if err := func() error {
				s.TruncationOnTables.Reset()
				if err := s.TruncationOnTables.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"truncation_on_tables\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WorkspaceConfiguration")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WorkspaceConfiguration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorkspaceConfiguration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WorkspaceMetricResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WorkspaceMetricResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Results != nil {
			e.FieldStart("results")
			e.ArrStart()
			for _, elem := range s.Results {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfWorkspaceMetricResponse = [1]string{
	0: "results",
}

// Decode decodes WorkspaceMetricResponse from json.
func (s *WorkspaceMetricResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorkspaceMetricResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "results":
			if err := func() error {
				s.Results = make([]Result, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Result
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Results = append(s.Results, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"results\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WorkspaceMetricResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WorkspaceMetricResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorkspaceMetricResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WorkspaceMetricsSummaryRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WorkspaceMetricsSummaryRequest) encodeFields(e *jx.Encoder) {
	{
		if s.ProjectIds != nil {
			e.FieldStart("project_ids")
			e.ArrStart()
			for _, elem := range s.ProjectIds {
				json.EncodeUUID(e, elem)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("interval_start")
		json.EncodeDateTime(e, s.IntervalStart)
	}
	{
		e.FieldStart("interval_end")
		json.EncodeDateTime(e, s.IntervalEnd)
	}
	{
		if s.StartBeforeEnd.Set {
			e.FieldStart("start_before_end")
			s.StartBeforeEnd.Encode(e)
		}
	}
}

var jsonFieldsNameOfWorkspaceMetricsSummaryRequest = [4]string{
	0: "project_ids",
	1: "interval_start",
	2: "interval_end",
	3: "start_before_end",
}

// Decode decodes WorkspaceMetricsSummaryRequest from json.
func (s *WorkspaceMetricsSummaryRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorkspaceMetricsSummaryRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "project_ids":
			if err := func() error {
				s.ProjectIds = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.ProjectIds = append(s.ProjectIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"project_ids\"")
			}
		case "interval_start":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.IntervalStart = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"interval_start\"")
			}
		case "interval_end":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.IntervalEnd = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"interval_end\"")
			}
		case "start_before_end":
			if err := func() error {
				s.StartBeforeEnd.Reset()
				if err := s.StartBeforeEnd.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start_before_end\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WorkspaceMetricsSummaryRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWorkspaceMetricsSummaryRequest) {
					name = jsonFieldsNameOfWorkspaceMetricsSummaryRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WorkspaceMetricsSummaryRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorkspaceMetricsSummaryRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WorkspaceMetricsSummaryResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WorkspaceMetricsSummaryResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Results != nil {
			e.FieldStart("results")
			e.ArrStart()
			for _, elem := range s.Results {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfWorkspaceMetricsSummaryResponse = [1]string{
	0: "results",
}

// Decode decodes WorkspaceMetricsSummaryResponse from json.
func (s *WorkspaceMetricsSummaryResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorkspaceMetricsSummaryResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "results":
			if err := func() error {
				s.Results = make([]Result, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Result
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Results = append(s.Results, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"results\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WorkspaceMetricsSummaryResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WorkspaceMetricsSummaryResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorkspaceMetricsSummaryResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WorkspaceNameHolder) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WorkspaceNameHolder) encodeFields(e *jx.Encoder) {
	{
		if s.WorkspaceName.Set {
			e.FieldStart("workspace_name")
			s.WorkspaceName.Encode(e)
		}
	}
}

var jsonFieldsNameOfWorkspaceNameHolder = [1]string{
	0: "workspace_name",
}

// Decode decodes WorkspaceNameHolder from json.
func (s *WorkspaceNameHolder) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorkspaceNameHolder to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "workspace_name":
			if err := func() error {
				s.WorkspaceName.Reset()
				if err := s.WorkspaceName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"workspace_name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WorkspaceNameHolder")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WorkspaceNameHolder) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorkspaceNameHolder) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WorkspaceSpansCount) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WorkspaceSpansCount) encodeFields(e *jx.Encoder) {
	{
		if s.Workspace.Set {
			e.FieldStart("workspace")
			s.Workspace.Encode(e)
		}
	}
	{
		if s.SpanCount.Set {
			e.FieldStart("span_count")
			s.SpanCount.Encode(e)
		}
	}
}

var jsonFieldsNameOfWorkspaceSpansCount = [2]string{
	0: "workspace",
	1: "span_count",
}

// Decode decodes WorkspaceSpansCount from json.
func (s *WorkspaceSpansCount) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorkspaceSpansCount to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "workspace":
			if err := func() error {
				s.Workspace.Reset()
				if err := s.Workspace.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"workspace\"")
			}
		case "span_count":
			if err := func() error {
				s.SpanCount.Reset()
				if err := s.SpanCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"span_count\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WorkspaceSpansCount")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WorkspaceSpansCount) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorkspaceSpansCount) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WorkspaceTraceCount) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WorkspaceTraceCount) encodeFields(e *jx.Encoder) {
	{
		if s.Workspace.Set {
			e.FieldStart("workspace")
			s.Workspace.Encode(e)
		}
	}
	{
		if s.TraceCount.Set {
			e.FieldStart("trace_count")
			s.TraceCount.Encode(e)
		}
	}
}

var jsonFieldsNameOfWorkspaceTraceCount = [2]string{
	0: "workspace",
	1: "trace_count",
}

// Decode decodes WorkspaceTraceCount from json.
func (s *WorkspaceTraceCount) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorkspaceTraceCount to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "workspace":
			if err := func() error {
				s.Workspace.Reset()
				if err := s.Workspace.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"workspace\"")
			}
		case "trace_count":
			if err := func() error {
				s.TraceCount.Reset()
				if err := s.TraceCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trace_count\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WorkspaceTraceCount")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WorkspaceTraceCount) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorkspaceTraceCount) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
