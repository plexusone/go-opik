// Code generated by ogen, DO NOT EDIT.

package api

import (
	"net/http"
	"net/url"
	"strings"

	"github.com/ogen-go/ogen/uri"
)

func (s *Server) cutPrefix(path string) (string, bool) {
	prefix := s.cfg.Prefix
	if prefix == "" {
		return path, true
	}
	if !strings.HasPrefix(path, prefix) {
		// Prefix doesn't match.
		return "", false
	}
	// Cut prefix from the path.
	return strings.TrimPrefix(path, prefix), true
}

// ServeHTTP serves http request as defined by OpenAPI v3 specification,
// calling handler that matches the path or returning not found error.
func (s *Server) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	elem := r.URL.Path
	elemIsEscaped := false
	if rawPath := r.URL.RawPath; rawPath != "" {
		if normalized, ok := uri.NormalizeEscapedPath(rawPath); ok {
			elem = normalized
			elemIsEscaped = strings.ContainsRune(elem, '%')
		}
	}

	elem, ok := s.cutPrefix(elem)
	if !ok || len(elem) == 0 {
		s.notFound(w, r)
		return
	}
	args := [3]string{}

	// Static code generated router with unwrapped path search.
	switch {
	default:
		if len(elem) == 0 {
			break
		}
		switch elem[0] {
		case '/': // Prefix: "/"

			if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
				elem = elem[l:]
			} else {
				break
			}

			if len(elem) == 0 {
				break
			}
			switch elem[0] {
			case 'i': // Prefix: "is-alive/"

				if l := len("is-alive/"); len(elem) >= l && elem[0:l] == "is-alive/" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'p': // Prefix: "ping"

					if l := len("ping"); len(elem) >= l && elem[0:l] == "ping" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf node.
						switch r.Method {
						case "GET":
							s.handleIsAliveRequest([0]string{}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "GET")
						}

						return
					}

				case 'v': // Prefix: "ver"

					if l := len("ver"); len(elem) >= l && elem[0:l] == "ver" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf node.
						switch r.Method {
						case "GET":
							s.handleVersionRequest([0]string{}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "GET")
						}

						return
					}

				}

			case 'v': // Prefix: "v1/"

				if l := len("v1/"); len(elem) >= l && elem[0:l] == "v1/" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'i': // Prefix: "internal/usage/"

					if l := len("internal/usage/"); len(elem) >= l && elem[0:l] == "internal/usage/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'b': // Prefix: "bi-"

						if l := len("bi-"); len(elem) >= l && elem[0:l] == "bi-" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'd': // Prefix: "datasets"

							if l := len("datasets"); len(elem) >= l && elem[0:l] == "datasets" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleGetDatasetBiInfoRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}

						case 'e': // Prefix: "experiments"

							if l := len("experiments"); len(elem) >= l && elem[0:l] == "experiments" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleGetExperimentBiInfoRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}

						case 's': // Prefix: "spans"

							if l := len("spans"); len(elem) >= l && elem[0:l] == "spans" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleGetSpansBiInfoRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}

						case 't': // Prefix: "traces"

							if l := len("traces"); len(elem) >= l && elem[0:l] == "traces" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleGetTracesBiInfoRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}

						}

					case 'w': // Prefix: "workspace-"

						if l := len("workspace-"); len(elem) >= l && elem[0:l] == "workspace-" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 's': // Prefix: "span-counts"

							if l := len("span-counts"); len(elem) >= l && elem[0:l] == "span-counts" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleGetSpansCountForWorkspacesRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}

						case 't': // Prefix: "trace-counts"

							if l := len("trace-counts"); len(elem) >= l && elem[0:l] == "trace-counts" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleGetTracesCountForWorkspacesRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}

						}

					}

				case 'p': // Prefix: "private/"

					if l := len("private/"); len(elem) >= l && elem[0:l] == "private/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'a': // Prefix: "a"

						if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'l': // Prefix: "lerts"

							if l := len("lerts"); len(elem) >= l && elem[0:l] == "lerts" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch r.Method {
								case "GET":
									s.handleFindAlertsRequest([0]string{}, elemIsEscaped, w, r)
								case "POST":
									s.handleCreateAlertRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET,POST")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'd': // Prefix: "delete"
									origElem := elem
									if l := len("delete"); len(elem) >= l && elem[0:l] == "delete" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "POST":
											s.handleDeleteAlertBatchRequest([0]string{}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "POST")
										}

										return
									}

									elem = origElem
								case 'w': // Prefix: "webhooks/"
									origElem := elem
									if l := len("webhooks/"); len(elem) >= l && elem[0:l] == "webhooks/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'e': // Prefix: "examples"

										if l := len("examples"); len(elem) >= l && elem[0:l] == "examples" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "GET":
												s.handleGetWebhookExamplesRequest([0]string{}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "GET")
											}

											return
										}

									case 't': // Prefix: "tests"

										if l := len("tests"); len(elem) >= l && elem[0:l] == "tests" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "POST":
												s.handleTestWebhookRequest([0]string{}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "POST")
											}

											return
										}

									}

									elem = origElem
								}
								// Param: "id"
								// Leaf parameter, slashes are prohibited
								idx := strings.IndexByte(elem, '/')
								if idx >= 0 {
									break
								}
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleGetAlertByIdRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									case "PUT":
										s.handleUpdateAlertRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET,PUT")
									}

									return
								}

							}

						case 'n': // Prefix: "nnotation-queues"

							if l := len("nnotation-queues"); len(elem) >= l && elem[0:l] == "nnotation-queues" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch r.Method {
								case "GET":
									s.handleFindAnnotationQueuesRequest([0]string{}, elemIsEscaped, w, r)
								case "POST":
									s.handleCreateAnnotationQueueRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET,POST")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'b': // Prefix: "batch"
									origElem := elem
									if l := len("batch"); len(elem) >= l && elem[0:l] == "batch" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "POST":
											s.handleCreateAnnotationQueueBatchRequest([0]string{}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "POST")
										}

										return
									}

									elem = origElem
								case 'd': // Prefix: "delete"
									origElem := elem
									if l := len("delete"); len(elem) >= l && elem[0:l] == "delete" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "POST":
											s.handleDeleteAnnotationQueueBatchRequest([0]string{}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "POST")
										}

										return
									}

									elem = origElem
								}
								// Param: "id"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[0] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									switch r.Method {
									case "GET":
										s.handleGetAnnotationQueueByIdRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									case "PATCH":
										s.handleUpdateAnnotationQueueRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET,PATCH")
									}

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/items/"

									if l := len("/items/"); len(elem) >= l && elem[0:l] == "/items/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'a': // Prefix: "add"

										if l := len("add"); len(elem) >= l && elem[0:l] == "add" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "POST":
												s.handleAddItemsToAnnotationQueueRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "POST")
											}

											return
										}

									case 'd': // Prefix: "delete"

										if l := len("delete"); len(elem) >= l && elem[0:l] == "delete" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "POST":
												s.handleRemoveItemsFromAnnotationQueueRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "POST")
											}

											return
										}

									}

								}

							}

						case 't': // Prefix: "ttachment/"

							if l := len("ttachment/"); len(elem) >= l && elem[0:l] == "ttachment/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'd': // Prefix: "delete"

								if l := len("delete"); len(elem) >= l && elem[0:l] == "delete" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "POST":
										s.handleDeleteAttachmentsRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "POST")
									}

									return
								}

							case 'l': // Prefix: "list"

								if l := len("list"); len(elem) >= l && elem[0:l] == "list" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleAttachmentListRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}

							case 'u': // Prefix: "upload-"

								if l := len("upload-"); len(elem) >= l && elem[0:l] == "upload-" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'c': // Prefix: "complete"

									if l := len("complete"); len(elem) >= l && elem[0:l] == "complete" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "POST":
											s.handleCompleteMultiPartUploadRequest([0]string{}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "POST")
										}

										return
									}

								case 's': // Prefix: "start"

									if l := len("start"); len(elem) >= l && elem[0:l] == "start" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "POST":
											s.handleStartMultiPartUploadRequest([0]string{}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "POST")
										}

										return
									}

								}

							}

						case 'u': // Prefix: "ut"

							if l := len("ut"); len(elem) >= l && elem[0:l] == "ut" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'h': // Prefix: "h"

								if l := len("h"); len(elem) >= l && elem[0:l] == "h" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch r.Method {
									case "POST":
										s.handleCheckAccessRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "POST")
									}

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/workspace"

									if l := len("/workspace"); len(elem) >= l && elem[0:l] == "/workspace" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleGetWorkspaceNameRequest([0]string{}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}

								}

							case 'o': // Prefix: "omations/evaluators"

								if l := len("omations/evaluators"); len(elem) >= l && elem[0:l] == "omations/evaluators" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch r.Method {
									case "GET":
										s.handleFindEvaluatorsRequest([0]string{}, elemIsEscaped, w, r)
									case "POST":
										s.handleCreateAutomationRuleEvaluatorRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET,POST")
									}

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/"

									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'd': // Prefix: "delete"
										origElem := elem
										if l := len("delete"); len(elem) >= l && elem[0:l] == "delete" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "POST":
												s.handleDeleteAutomationRuleEvaluatorBatchRequest([0]string{}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "POST")
											}

											return
										}

										elem = origElem
									}
									// Param: "id"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[0] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										switch r.Method {
										case "GET":
											s.handleGetEvaluatorByIdRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										case "PATCH":
											s.handleUpdateAutomationRuleEvaluatorRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET,PATCH")
										}

										return
									}
									switch elem[0] {
									case '/': // Prefix: "/logs"

										if l := len("/logs"); len(elem) >= l && elem[0:l] == "/logs" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "GET":
												s.handleGetEvaluatorLogsByIdRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "GET")
											}

											return
										}

									}

								}

							}

						}

					case 'c': // Prefix: "chat/completions"

						if l := len("chat/completions"); len(elem) >= l && elem[0:l] == "chat/completions" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "POST":
								s.handleCreateChatCompletionsRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "POST")
							}

							return
						}

					case 'd': // Prefix: "da"

						if l := len("da"); len(elem) >= l && elem[0:l] == "da" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 's': // Prefix: "shboards"

							if l := len("shboards"); len(elem) >= l && elem[0:l] == "shboards" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch r.Method {
								case "GET":
									s.handleFindDashboardsRequest([0]string{}, elemIsEscaped, w, r)
								case "POST":
									s.handleCreateDashboardRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET,POST")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'd': // Prefix: "delete-batch"
									origElem := elem
									if l := len("delete-batch"); len(elem) >= l && elem[0:l] == "delete-batch" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "POST":
											s.handleDeleteDashboardsBatchRequest([0]string{}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "POST")
										}

										return
									}

									elem = origElem
								}
								// Param: "dashboardId"
								// Leaf parameter, slashes are prohibited
								idx := strings.IndexByte(elem, '/')
								if idx >= 0 {
									break
								}
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "DELETE":
										s.handleDeleteDashboardRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									case "GET":
										s.handleGetDashboardByIdRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									case "PATCH":
										s.handleUpdateDashboardRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "DELETE,GET,PATCH")
									}

									return
								}

							}

						case 't': // Prefix: "tasets"

							if l := len("tasets"); len(elem) >= l && elem[0:l] == "tasets" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch r.Method {
								case "GET":
									s.handleFindDatasetsRequest([0]string{}, elemIsEscaped, w, r)
								case "POST":
									s.handleCreateDatasetRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET,POST")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'd': // Prefix: "delete"
									origElem := elem
									if l := len("delete"); len(elem) >= l && elem[0:l] == "delete" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch r.Method {
										case "POST":
											s.handleDeleteDatasetByNameRequest([0]string{}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "POST")
										}

										return
									}
									switch elem[0] {
									case '-': // Prefix: "-batch"

										if l := len("-batch"); len(elem) >= l && elem[0:l] == "-batch" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "POST":
												s.handleDeleteDatasetsBatchRequest([0]string{}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "POST")
											}

											return
										}

									}

									elem = origElem
								case 'i': // Prefix: "items"
									origElem := elem
									if l := len("items"); len(elem) >= l && elem[0:l] == "items" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch r.Method {
										case "PUT":
											s.handleCreateOrUpdateDatasetItemsRequest([0]string{}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "PUT")
										}

										return
									}
									switch elem[0] {
									case '/': // Prefix: "/"

										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'b': // Prefix: "batch"
											origElem := elem
											if l := len("batch"); len(elem) >= l && elem[0:l] == "batch" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "PATCH":
													s.handleBatchUpdateDatasetItemsRequest([0]string{}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "PATCH")
												}

												return
											}

											elem = origElem
										case 'd': // Prefix: "delete"
											origElem := elem
											if l := len("delete"); len(elem) >= l && elem[0:l] == "delete" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "POST":
													s.handleDeleteDatasetItemsRequest([0]string{}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "POST")
												}

												return
											}

											elem = origElem
										case 'f': // Prefix: "from-csv"
											origElem := elem
											if l := len("from-csv"); len(elem) >= l && elem[0:l] == "from-csv" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "POST":
													s.handleCreateDatasetItemsFromCsvRequest([0]string{}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "POST")
												}

												return
											}

											elem = origElem
										}
										// Param: "itemId"
										// Leaf parameter, slashes are prohibited
										idx := strings.IndexByte(elem, '/')
										if idx >= 0 {
											break
										}
										args[0] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "GET":
												s.handleGetDatasetItemByIdRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											case "PATCH":
												s.handlePatchDatasetItemRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "GET,PATCH")
											}

											return
										}

									}

									elem = origElem
								case 'r': // Prefix: "retrieve"
									origElem := elem
									if l := len("retrieve"); len(elem) >= l && elem[0:l] == "retrieve" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "POST":
											s.handleGetDatasetByIdentifierRequest([0]string{}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "POST")
										}

										return
									}

									elem = origElem
								}
								// Param: "id"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[0] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									switch r.Method {
									case "DELETE":
										s.handleDeleteDatasetRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									case "GET":
										s.handleGetDatasetByIdRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									case "PUT":
										s.handleUpdateDatasetRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "DELETE,GET,PUT")
									}

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/"

									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'e': // Prefix: "expansions"

										if l := len("expansions"); len(elem) >= l && elem[0:l] == "expansions" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "POST":
												s.handleExpandDatasetRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "POST")
											}

											return
										}

									case 'i': // Prefix: "items"

										if l := len("items"); len(elem) >= l && elem[0:l] == "items" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch r.Method {
											case "GET":
												s.handleGetDatasetItemsRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "GET")
											}

											return
										}
										switch elem[0] {
										case '/': // Prefix: "/"

											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 'e': // Prefix: "experiments/items"

												if l := len("experiments/items"); len(elem) >= l && elem[0:l] == "experiments/items" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch r.Method {
													case "GET":
														s.handleFindDatasetItemsWithExperimentItemsRequest([1]string{
															args[0],
														}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "GET")
													}

													return
												}
												switch elem[0] {
												case '/': // Prefix: "/"

													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														break
													}
													switch elem[0] {
													case 'o': // Prefix: "output/columns"

														if l := len("output/columns"); len(elem) >= l && elem[0:l] == "output/columns" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf node.
															switch r.Method {
															case "GET":
																s.handleGetDatasetItemsOutputColumnsRequest([1]string{
																	args[0],
																}, elemIsEscaped, w, r)
															default:
																s.notAllowed(w, r, "GET")
															}

															return
														}

													case 's': // Prefix: "stats"

														if l := len("stats"); len(elem) >= l && elem[0:l] == "stats" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf node.
															switch r.Method {
															case "GET":
																s.handleGetDatasetExperimentItemsStatsRequest([1]string{
																	args[0],
																}, elemIsEscaped, w, r)
															default:
																s.notAllowed(w, r, "GET")
															}

															return
														}

													}

												}

											case 'f': // Prefix: "from-"

												if l := len("from-"); len(elem) >= l && elem[0:l] == "from-" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 's': // Prefix: "spans"

													if l := len("spans"); len(elem) >= l && elem[0:l] == "spans" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf node.
														switch r.Method {
														case "POST":
															s.handleCreateDatasetItemsFromSpansRequest([1]string{
																args[0],
															}, elemIsEscaped, w, r)
														default:
															s.notAllowed(w, r, "POST")
														}

														return
													}

												case 't': // Prefix: "traces"

													if l := len("traces"); len(elem) >= l && elem[0:l] == "traces" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf node.
														switch r.Method {
														case "POST":
															s.handleCreateDatasetItemsFromTracesRequest([1]string{
																args[0],
															}, elemIsEscaped, w, r)
														default:
															s.notAllowed(w, r, "POST")
														}

														return
													}

												}

											}

										}

									case 'v': // Prefix: "versions"

										if l := len("versions"); len(elem) >= l && elem[0:l] == "versions" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch r.Method {
											case "GET":
												s.handleListDatasetVersionsRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											case "POST":
												s.handleCreateDatasetVersionRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "GET,POST")
											}

											return
										}
										switch elem[0] {
										case '/': // Prefix: "/"

											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 'd': // Prefix: "diff"
												origElem := elem
												if l := len("diff"); len(elem) >= l && elem[0:l] == "diff" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch r.Method {
													case "GET":
														s.handleCompareDatasetVersionsRequest([1]string{
															args[0],
														}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "GET")
													}

													return
												}

												elem = origElem
											case 'h': // Prefix: "hash/"
												origElem := elem
												if l := len("hash/"); len(elem) >= l && elem[0:l] == "hash/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "versionHash"
												// Match until "/"
												idx := strings.IndexByte(elem, '/')
												if idx < 0 {
													idx = len(elem)
												}
												args[1] = elem[:idx]
												elem = elem[idx:]

												if len(elem) == 0 {
													switch r.Method {
													case "PATCH":
														s.handleUpdateDatasetVersionRequest([2]string{
															args[0],
															args[1],
														}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "PATCH")
													}

													return
												}
												switch elem[0] {
												case '/': // Prefix: "/tags"

													if l := len("/tags"); len(elem) >= l && elem[0:l] == "/tags" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf node.
														switch r.Method {
														case "POST":
															s.handleCreateVersionTagRequest([2]string{
																args[0],
																args[1],
															}, elemIsEscaped, w, r)
														default:
															s.notAllowed(w, r, "POST")
														}

														return
													}

												}

												elem = origElem
											case 'r': // Prefix: "restore"
												origElem := elem
												if l := len("restore"); len(elem) >= l && elem[0:l] == "restore" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch r.Method {
													case "POST":
														s.handleRestoreDatasetVersionRequest([1]string{
															args[0],
														}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "POST")
													}

													return
												}

												elem = origElem
											}
											// Param: "versionHash"
											// Match until "/"
											idx := strings.IndexByte(elem, '/')
											if idx < 0 {
												idx = len(elem)
											}
											args[1] = elem[:idx]
											elem = elem[idx:]

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case '/': // Prefix: "/tags/"

												if l := len("/tags/"); len(elem) >= l && elem[0:l] == "/tags/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "tag"
												// Leaf parameter, slashes are prohibited
												idx := strings.IndexByte(elem, '/')
												if idx >= 0 {
													break
												}
												args[2] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf node.
													switch r.Method {
													case "DELETE":
														s.handleDeleteVersionTagRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "DELETE")
													}

													return
												}

											}

										}

									}

								}

							}

						}

					case 'e': // Prefix: "experiments"

						if l := len("experiments"); len(elem) >= l && elem[0:l] == "experiments" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch r.Method {
							case "GET":
								s.handleFindExperimentsRequest([0]string{}, elemIsEscaped, w, r)
							case "POST":
								s.handleCreateExperimentRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET,POST")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"

							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'd': // Prefix: "delete"
								origElem := elem
								if l := len("delete"); len(elem) >= l && elem[0:l] == "delete" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "POST":
										s.handleDeleteExperimentsByIdRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "POST")
									}

									return
								}

								elem = origElem
							case 'f': // Prefix: "f"
								origElem := elem
								if l := len("f"); len(elem) >= l && elem[0:l] == "f" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'e': // Prefix: "eedback-scores/names"

									if l := len("eedback-scores/names"); len(elem) >= l && elem[0:l] == "eedback-scores/names" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleFindFeedbackScoreNamesRequest([0]string{}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}

								case 'i': // Prefix: "inish"

									if l := len("inish"); len(elem) >= l && elem[0:l] == "inish" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "POST":
											s.handleFinishExperimentsRequest([0]string{}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "POST")
										}

										return
									}

								}

								elem = origElem
							case 'g': // Prefix: "groups"
								origElem := elem
								if l := len("groups"); len(elem) >= l && elem[0:l] == "groups" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch r.Method {
									case "GET":
										s.handleFindExperimentGroupsRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/aggregations"

									if l := len("/aggregations"); len(elem) >= l && elem[0:l] == "/aggregations" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleFindExperimentGroupsAggregationsRequest([0]string{}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}

								}

								elem = origElem
							case 'i': // Prefix: "items"
								origElem := elem
								if l := len("items"); len(elem) >= l && elem[0:l] == "items" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch r.Method {
									case "POST":
										s.handleCreateExperimentItemsRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "POST")
									}

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/"

									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'b': // Prefix: "bulk"
										origElem := elem
										if l := len("bulk"); len(elem) >= l && elem[0:l] == "bulk" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "PUT":
												s.handleExperimentItemsBulkRequest([0]string{}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "PUT")
											}

											return
										}

										elem = origElem
									case 'd': // Prefix: "delete"
										origElem := elem
										if l := len("delete"); len(elem) >= l && elem[0:l] == "delete" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "POST":
												s.handleDeleteExperimentItemsRequest([0]string{}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "POST")
											}

											return
										}

										elem = origElem
									}
									// Param: "id"
									// Leaf parameter, slashes are prohibited
									idx := strings.IndexByte(elem, '/')
									if idx >= 0 {
										break
									}
									args[0] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleGetExperimentItemByIdRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}

								}

								elem = origElem
							}
							// Param: "id"
							// Leaf parameter, slashes are prohibited
							idx := strings.IndexByte(elem, '/')
							if idx >= 0 {
								break
							}
							args[0] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleGetExperimentByIdRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								case "PATCH":
									s.handleUpdateExperimentRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET,PATCH")
								}

								return
							}

						}

					case 'f': // Prefix: "feedback-definitions"

						if l := len("feedback-definitions"); len(elem) >= l && elem[0:l] == "feedback-definitions" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch r.Method {
							case "GET":
								s.handleFindFeedbackDefinitionsRequest([0]string{}, elemIsEscaped, w, r)
							case "POST":
								s.handleCreateFeedbackDefinitionRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET,POST")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"

							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'd': // Prefix: "delete"
								origElem := elem
								if l := len("delete"); len(elem) >= l && elem[0:l] == "delete" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "POST":
										s.handleDeleteFeedbackDefinitionsBatchRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "POST")
									}

									return
								}

								elem = origElem
							}
							// Param: "id"
							// Leaf parameter, slashes are prohibited
							idx := strings.IndexByte(elem, '/')
							if idx >= 0 {
								break
							}
							args[0] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "DELETE":
									s.handleDeleteFeedbackDefinitionByIdRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								case "GET":
									s.handleGetFeedbackDefinitionByIdRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								case "PUT":
									s.handleUpdateFeedbackDefinitionRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "DELETE,GET,PUT")
								}

								return
							}

						}

					case 'g': // Prefix: "guardrails"

						if l := len("guardrails"); len(elem) >= l && elem[0:l] == "guardrails" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "POST":
								s.handleCreateGuardrailsRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "POST")
							}

							return
						}

					case 'l': // Prefix: "llm-provider-key"

						if l := len("llm-provider-key"); len(elem) >= l && elem[0:l] == "llm-provider-key" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch r.Method {
							case "GET":
								s.handleFindLlmProviderKeysRequest([0]string{}, elemIsEscaped, w, r)
							case "POST":
								s.handleStoreLlmProviderApiKeyRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET,POST")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"

							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'd': // Prefix: "delete"
								origElem := elem
								if l := len("delete"); len(elem) >= l && elem[0:l] == "delete" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "POST":
										s.handleDeleteLlmProviderApiKeysBatchRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "POST")
									}

									return
								}

								elem = origElem
							}
							// Param: "id"
							// Leaf parameter, slashes are prohibited
							idx := strings.IndexByte(elem, '/')
							if idx >= 0 {
								break
							}
							args[0] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleGetLlmProviderApiKeyByIdRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								case "PATCH":
									s.handleUpdateLlmProviderApiKeyRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET,PATCH")
								}

								return
							}

						}

					case 'm': // Prefix: "manual-evaluation/"

						if l := len("manual-evaluation/"); len(elem) >= l && elem[0:l] == "manual-evaluation/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 's': // Prefix: "spans"

							if l := len("spans"); len(elem) >= l && elem[0:l] == "spans" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "POST":
									s.handleEvaluateSpansRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "POST")
								}

								return
							}

						case 't': // Prefix: "t"

							if l := len("t"); len(elem) >= l && elem[0:l] == "t" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'h': // Prefix: "hreads"

								if l := len("hreads"); len(elem) >= l && elem[0:l] == "hreads" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "POST":
										s.handleEvaluateThreadsRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "POST")
									}

									return
								}

							case 'r': // Prefix: "races"

								if l := len("races"); len(elem) >= l && elem[0:l] == "races" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "POST":
										s.handleEvaluateTracesRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "POST")
									}

									return
								}

							}

						}

					case 'o': // Prefix: "optimizations"

						if l := len("optimizations"); len(elem) >= l && elem[0:l] == "optimizations" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch r.Method {
							case "GET":
								s.handleFindOptimizationsRequest([0]string{}, elemIsEscaped, w, r)
							case "POST":
								s.handleCreateOptimizationRequest([0]string{}, elemIsEscaped, w, r)
							case "PUT":
								s.handleUpsertOptimizationRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET,POST,PUT")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"

							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'd': // Prefix: "delete"
								origElem := elem
								if l := len("delete"); len(elem) >= l && elem[0:l] == "delete" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "POST":
										s.handleDeleteOptimizationsByIdRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "POST")
									}

									return
								}

								elem = origElem
							case 's': // Prefix: "studio"
								origElem := elem
								if l := len("studio"); len(elem) >= l && elem[0:l] == "studio" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch r.Method {
									case "GET":
										s.handleFindStudioOptimizationsRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/"

									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "id"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[0] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										switch r.Method {
										case "GET":
											s.handleGetStudioOptimizationByIdRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}
									switch elem[0] {
									case '/': // Prefix: "/"

										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'c': // Prefix: "cancel"

											if l := len("cancel"); len(elem) >= l && elem[0:l] == "cancel" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "GET":
													s.handleCancelStudioOptimizationsRequest([1]string{
														args[0],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "GET")
												}

												return
											}

										case 'l': // Prefix: "logs"

											if l := len("logs"); len(elem) >= l && elem[0:l] == "logs" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "GET":
													s.handleGetStudioOptimizationLogsRequest([1]string{
														args[0],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "GET")
												}

												return
											}

										}

									}

								}

								elem = origElem
							}
							// Param: "id"
							// Leaf parameter, slashes are prohibited
							idx := strings.IndexByte(elem, '/')
							if idx >= 0 {
								break
							}
							args[0] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleGetOptimizationByIdRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								case "PUT":
									s.handleUpdateOptimizationsByIdRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET,PUT")
								}

								return
							}

						}

					case 'p': // Prefix: "pro"

						if l := len("pro"); len(elem) >= l && elem[0:l] == "pro" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'j': // Prefix: "jects"

							if l := len("jects"); len(elem) >= l && elem[0:l] == "jects" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch r.Method {
								case "GET":
									s.handleFindProjectsRequest([0]string{}, elemIsEscaped, w, r)
								case "POST":
									s.handleCreateProjectRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET,POST")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'd': // Prefix: "delete"
									origElem := elem
									if l := len("delete"); len(elem) >= l && elem[0:l] == "delete" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "POST":
											s.handleDeleteProjectsBatchRequest([0]string{}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "POST")
										}

										return
									}

									elem = origElem
								case 'f': // Prefix: "feedback-scores/names"
									origElem := elem
									if l := len("feedback-scores/names"); len(elem) >= l && elem[0:l] == "feedback-scores/names" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleFindFeedbackScoreNamesByProjectIdsRequest([0]string{}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}

									elem = origElem
								case 'r': // Prefix: "retrieve"
									origElem := elem
									if l := len("retrieve"); len(elem) >= l && elem[0:l] == "retrieve" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "POST":
											s.handleRetrieveProjectRequest([0]string{}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "POST")
										}

										return
									}

									elem = origElem
								case 's': // Prefix: "stats"
									origElem := elem
									if l := len("stats"); len(elem) >= l && elem[0:l] == "stats" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleGetProjectStatsRequest([0]string{}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}

									elem = origElem
								}
								// Param: "id"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[0] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									switch r.Method {
									case "DELETE":
										s.handleDeleteProjectByIdRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									case "GET":
										s.handleGetProjectByIdRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									case "PATCH":
										s.handleUpdateProjectRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "DELETE,GET,PATCH")
									}

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/metrics"

									if l := len("/metrics"); len(elem) >= l && elem[0:l] == "/metrics" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "POST":
											s.handleGetProjectMetricsRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "POST")
										}

										return
									}

								}

							}

						case 'm': // Prefix: "mpts"

							if l := len("mpts"); len(elem) >= l && elem[0:l] == "mpts" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch r.Method {
								case "GET":
									s.handleGetPromptsRequest([0]string{}, elemIsEscaped, w, r)
								case "POST":
									s.handleCreatePromptRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET,POST")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'd': // Prefix: "delete"
									origElem := elem
									if l := len("delete"); len(elem) >= l && elem[0:l] == "delete" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "POST":
											s.handleDeletePromptsBatchRequest([0]string{}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "POST")
										}

										return
									}

									elem = origElem
								case 'v': // Prefix: "versions"
									origElem := elem
									if l := len("versions"); len(elem) >= l && elem[0:l] == "versions" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch r.Method {
										case "PATCH":
											s.handleUpdatePromptVersionsRequest([0]string{}, elemIsEscaped, w, r)
										case "POST":
											s.handleCreatePromptVersionRequest([0]string{}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "PATCH,POST")
										}

										return
									}
									switch elem[0] {
									case '/': // Prefix: "/"

										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'r': // Prefix: "retrieve"
											origElem := elem
											if l := len("retrieve"); len(elem) >= l && elem[0:l] == "retrieve" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "POST":
													s.handleRetrievePromptVersionRequest([0]string{}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "POST")
												}

												return
											}

											elem = origElem
										}
										// Param: "versionId"
										// Leaf parameter, slashes are prohibited
										idx := strings.IndexByte(elem, '/')
										if idx >= 0 {
											break
										}
										args[0] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "GET":
												s.handleGetPromptVersionByIdRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "GET")
											}

											return
										}

									}

									elem = origElem
								}
								// Param: "id"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[0] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									switch r.Method {
									case "DELETE":
										s.handleDeletePromptRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									case "GET":
										s.handleGetPromptByIdRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									case "PUT":
										s.handleUpdatePromptRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "DELETE,GET,PUT")
									}

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/versions"

									if l := len("/versions"); len(elem) >= l && elem[0:l] == "/versions" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch r.Method {
										case "GET":
											s.handleGetPromptVersionsRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}
									switch elem[0] {
									case '/': // Prefix: "/"

										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "versionId"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx < 0 {
											idx = len(elem)
										}
										args[1] = elem[:idx]
										elem = elem[idx:]

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case '/': // Prefix: "/restore"

											if l := len("/restore"); len(elem) >= l && elem[0:l] == "/restore" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "POST":
													s.handleRestorePromptVersionRequest([2]string{
														args[0],
														args[1],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "POST")
												}

												return
											}

										}

									}

								}

							}

						}

					case 's': // Prefix: "spans"

						if l := len("spans"); len(elem) >= l && elem[0:l] == "spans" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch r.Method {
							case "GET":
								s.handleGetSpansByProjectRequest([0]string{}, elemIsEscaped, w, r)
							case "POST":
								s.handleCreateSpanRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET,POST")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"

							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'b': // Prefix: "batch"
								origElem := elem
								if l := len("batch"); len(elem) >= l && elem[0:l] == "batch" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "PATCH":
										s.handleBatchUpdateSpansRequest([0]string{}, elemIsEscaped, w, r)
									case "POST":
										s.handleCreateSpansRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "PATCH,POST")
									}

									return
								}

								elem = origElem
							case 'c': // Prefix: "comments/"
								origElem := elem
								if l := len("comments/"); len(elem) >= l && elem[0:l] == "comments/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'd': // Prefix: "delete"
									origElem := elem
									if l := len("delete"); len(elem) >= l && elem[0:l] == "delete" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "POST":
											s.handleDeleteSpanCommentsRequest([0]string{}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "POST")
										}

										return
									}

									elem = origElem
								}
								// Param: "commentId"
								// Leaf parameter, slashes are prohibited
								idx := strings.IndexByte(elem, '/')
								if idx >= 0 {
									break
								}
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "PATCH":
										s.handleUpdateSpanCommentRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "PATCH")
									}

									return
								}

								elem = origElem
							case 'f': // Prefix: "feedback-scores"
								origElem := elem
								if l := len("feedback-scores"); len(elem) >= l && elem[0:l] == "feedback-scores" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch r.Method {
									case "PUT":
										s.handleScoreBatchOfSpansRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "PUT")
									}

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/names"

									if l := len("/names"); len(elem) >= l && elem[0:l] == "/names" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleFindFeedbackScoreNames1Request([0]string{}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}

								}

								elem = origElem
							case 's': // Prefix: "stats"
								origElem := elem
								if l := len("stats"); len(elem) >= l && elem[0:l] == "stats" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleGetSpanStatsRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}

								elem = origElem
							}
							// Param: "id"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[0] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								switch r.Method {
								case "DELETE":
									s.handleDeleteSpanByIdRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								case "GET":
									s.handleGetSpanByIdRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								case "PATCH":
									s.handleUpdateSpanRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "DELETE,GET,PATCH")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'c': // Prefix: "comments"

									if l := len("comments"); len(elem) >= l && elem[0:l] == "comments" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch r.Method {
										case "POST":
											s.handleAddSpanCommentRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "POST")
										}

										return
									}
									switch elem[0] {
									case '/': // Prefix: "/"

										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "commentId"
										// Leaf parameter, slashes are prohibited
										idx := strings.IndexByte(elem, '/')
										if idx >= 0 {
											break
										}
										args[1] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "GET":
												s.handleGetSpanCommentRequest([2]string{
													args[0],
													args[1],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "GET")
											}

											return
										}

									}

								case 'f': // Prefix: "feedback-scores"

									if l := len("feedback-scores"); len(elem) >= l && elem[0:l] == "feedback-scores" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch r.Method {
										case "PUT":
											s.handleAddSpanFeedbackScoreRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "PUT")
										}

										return
									}
									switch elem[0] {
									case '/': // Prefix: "/delete"

										if l := len("/delete"); len(elem) >= l && elem[0:l] == "/delete" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "POST":
												s.handleDeleteSpanFeedbackScoreRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "POST")
											}

											return
										}

									}

								}

							}

						}

					case 't': // Prefix: "t"

						if l := len("t"); len(elem) >= l && elem[0:l] == "t" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'o': // Prefix: "oggles"

							if l := len("oggles"); len(elem) >= l && elem[0:l] == "oggles" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleGetServiceTogglesRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}

						case 'r': // Prefix: "races"

							if l := len("races"); len(elem) >= l && elem[0:l] == "races" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch r.Method {
								case "GET":
									s.handleGetTracesByProjectRequest([0]string{}, elemIsEscaped, w, r)
								case "POST":
									s.handleCreateTraceRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET,POST")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'b': // Prefix: "batch"
									origElem := elem
									if l := len("batch"); len(elem) >= l && elem[0:l] == "batch" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "PATCH":
											s.handleBatchUpdateTracesRequest([0]string{}, elemIsEscaped, w, r)
										case "POST":
											s.handleCreateTracesRequest([0]string{}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "PATCH,POST")
										}

										return
									}

									elem = origElem
								case 'c': // Prefix: "comments/"
									origElem := elem
									if l := len("comments/"); len(elem) >= l && elem[0:l] == "comments/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'd': // Prefix: "delete"
										origElem := elem
										if l := len("delete"); len(elem) >= l && elem[0:l] == "delete" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "POST":
												s.handleDeleteTraceCommentsRequest([0]string{}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "POST")
											}

											return
										}

										elem = origElem
									}
									// Param: "commentId"
									// Leaf parameter, slashes are prohibited
									idx := strings.IndexByte(elem, '/')
									if idx >= 0 {
										break
									}
									args[0] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "PATCH":
											s.handleUpdateTraceCommentRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "PATCH")
										}

										return
									}

									elem = origElem
								case 'd': // Prefix: "delete"
									origElem := elem
									if l := len("delete"); len(elem) >= l && elem[0:l] == "delete" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "POST":
											s.handleDeleteTracesRequest([0]string{}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "POST")
										}

										return
									}

									elem = origElem
								case 'f': // Prefix: "feedback-scores"
									origElem := elem
									if l := len("feedback-scores"); len(elem) >= l && elem[0:l] == "feedback-scores" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch r.Method {
										case "PUT":
											s.handleScoreBatchOfTracesRequest([0]string{}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "PUT")
										}

										return
									}
									switch elem[0] {
									case '/': // Prefix: "/names"

										if l := len("/names"); len(elem) >= l && elem[0:l] == "/names" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "GET":
												s.handleFindFeedbackScoreNames2Request([0]string{}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "GET")
											}

											return
										}

									}

									elem = origElem
								case 's': // Prefix: "stats"
									origElem := elem
									if l := len("stats"); len(elem) >= l && elem[0:l] == "stats" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleGetTraceStatsRequest([0]string{}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}

									elem = origElem
								case 't': // Prefix: "threads"
									origElem := elem
									if l := len("threads"); len(elem) >= l && elem[0:l] == "threads" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch r.Method {
										case "GET":
											s.handleGetTraceThreadsRequest([0]string{}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}
									switch elem[0] {
									case '/': // Prefix: "/"

										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'b': // Prefix: "batch"
											origElem := elem
											if l := len("batch"); len(elem) >= l && elem[0:l] == "batch" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "PATCH":
													s.handleBatchUpdateThreadsRequest([0]string{}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "PATCH")
												}

												return
											}

											elem = origElem
										case 'c': // Prefix: "c"
											origElem := elem
											if l := len("c"); len(elem) >= l && elem[0:l] == "c" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 'l': // Prefix: "lose"

												if l := len("lose"); len(elem) >= l && elem[0:l] == "lose" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch r.Method {
													case "PUT":
														s.handleCloseTraceThreadRequest([0]string{}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "PUT")
													}

													return
												}

											case 'o': // Prefix: "omments/"

												if l := len("omments/"); len(elem) >= l && elem[0:l] == "omments/" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 'd': // Prefix: "delete"
													origElem := elem
													if l := len("delete"); len(elem) >= l && elem[0:l] == "delete" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf node.
														switch r.Method {
														case "POST":
															s.handleDeleteThreadCommentsRequest([0]string{}, elemIsEscaped, w, r)
														default:
															s.notAllowed(w, r, "POST")
														}

														return
													}

													elem = origElem
												}
												// Param: "commentId"
												// Leaf parameter, slashes are prohibited
												idx := strings.IndexByte(elem, '/')
												if idx >= 0 {
													break
												}
												args[0] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf node.
													switch r.Method {
													case "PATCH":
														s.handleUpdateThreadCommentRequest([1]string{
															args[0],
														}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "PATCH")
													}

													return
												}

											}

											elem = origElem
										case 'd': // Prefix: "delete"
											origElem := elem
											if l := len("delete"); len(elem) >= l && elem[0:l] == "delete" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "POST":
													s.handleDeleteTraceThreadsRequest([0]string{}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "POST")
												}

												return
											}

											elem = origElem
										case 'f': // Prefix: "feedback-scores"
											origElem := elem
											if l := len("feedback-scores"); len(elem) >= l && elem[0:l] == "feedback-scores" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch r.Method {
												case "PUT":
													s.handleScoreBatchOfThreadsRequest([0]string{}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "PUT")
												}

												return
											}
											switch elem[0] {
											case '/': // Prefix: "/"

												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 'd': // Prefix: "delete"

													if l := len("delete"); len(elem) >= l && elem[0:l] == "delete" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf node.
														switch r.Method {
														case "POST":
															s.handleDeleteThreadFeedbackScoresRequest([0]string{}, elemIsEscaped, w, r)
														default:
															s.notAllowed(w, r, "POST")
														}

														return
													}

												case 'n': // Prefix: "names"

													if l := len("names"); len(elem) >= l && elem[0:l] == "names" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf node.
														switch r.Method {
														case "GET":
															s.handleFindTraceThreadsFeedbackScoreNamesRequest([0]string{}, elemIsEscaped, w, r)
														default:
															s.notAllowed(w, r, "GET")
														}

														return
													}

												}

											}

											elem = origElem
										case 'o': // Prefix: "open"
											origElem := elem
											if l := len("open"); len(elem) >= l && elem[0:l] == "open" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "PUT":
													s.handleOpenTraceThreadRequest([0]string{}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "PUT")
												}

												return
											}

											elem = origElem
										case 'r': // Prefix: "retrieve"
											origElem := elem
											if l := len("retrieve"); len(elem) >= l && elem[0:l] == "retrieve" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "POST":
													s.handleGetTraceThreadRequest([0]string{}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "POST")
												}

												return
											}

											elem = origElem
										case 's': // Prefix: "stats"
											origElem := elem
											if l := len("stats"); len(elem) >= l && elem[0:l] == "stats" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "GET":
													s.handleGetTraceThreadStatsRequest([0]string{}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "GET")
												}

												return
											}

											elem = origElem
										}
										// Param: "id"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx < 0 {
											idx = len(elem)
										}
										args[0] = elem[:idx]
										elem = elem[idx:]

										if len(elem) == 0 {
											switch r.Method {
											case "PATCH":
												s.handleUpdateThreadRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "PATCH")
											}

											return
										}
										switch elem[0] {
										case '/': // Prefix: "/comments"

											if l := len("/comments"); len(elem) >= l && elem[0:l] == "/comments" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch r.Method {
												case "POST":
													s.handleAddThreadCommentRequest([1]string{
														args[0],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "POST")
												}

												return
											}
											switch elem[0] {
											case '/': // Prefix: "/"

												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "commentId"
												// Leaf parameter, slashes are prohibited
												idx := strings.IndexByte(elem, '/')
												if idx >= 0 {
													break
												}
												args[1] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf node.
													switch r.Method {
													case "GET":
														s.handleGetThreadCommentRequest([2]string{
															args[0],
															args[1],
														}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "GET")
													}

													return
												}

											}

										}

									}

									elem = origElem
								}
								// Param: "id"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[0] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									switch r.Method {
									case "DELETE":
										s.handleDeleteTraceByIdRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									case "GET":
										s.handleGetTraceByIdRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									case "PATCH":
										s.handleUpdateTraceRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "DELETE,GET,PATCH")
									}

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/"

									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'c': // Prefix: "comments"

										if l := len("comments"); len(elem) >= l && elem[0:l] == "comments" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch r.Method {
											case "POST":
												s.handleAddTraceCommentRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "POST")
											}

											return
										}
										switch elem[0] {
										case '/': // Prefix: "/"

											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "commentId"
											// Leaf parameter, slashes are prohibited
											idx := strings.IndexByte(elem, '/')
											if idx >= 0 {
												break
											}
											args[1] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "GET":
													s.handleGetTraceCommentRequest([2]string{
														args[0],
														args[1],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "GET")
												}

												return
											}

										}

									case 'f': // Prefix: "feedback-scores"

										if l := len("feedback-scores"); len(elem) >= l && elem[0:l] == "feedback-scores" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch r.Method {
											case "PUT":
												s.handleAddTraceFeedbackScoreRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "PUT")
											}

											return
										}
										switch elem[0] {
										case '/': // Prefix: "/delete"

											if l := len("/delete"); len(elem) >= l && elem[0:l] == "/delete" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "POST":
													s.handleDeleteTraceFeedbackScoreRequest([1]string{
														args[0],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "POST")
												}

												return
											}

										}

									}

								}

							}

						}

					case 'w': // Prefix: "w"

						if l := len("w"); len(elem) >= l && elem[0:l] == "w" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'e': // Prefix: "elcome-wizard"

							if l := len("elcome-wizard"); len(elem) >= l && elem[0:l] == "elcome-wizard" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleGetWelcomeWizardStatusRequest([0]string{}, elemIsEscaped, w, r)
								case "POST":
									s.handleSubmitWelcomeWizardRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET,POST")
								}

								return
							}

						case 'o': // Prefix: "orkspaces/"

							if l := len("orkspaces/"); len(elem) >= l && elem[0:l] == "orkspaces/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'c': // Prefix: "co"

								if l := len("co"); len(elem) >= l && elem[0:l] == "co" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'n': // Prefix: "nfigurations"

									if l := len("nfigurations"); len(elem) >= l && elem[0:l] == "nfigurations" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "DELETE":
											s.handleDeleteWorkspaceConfigurationRequest([0]string{}, elemIsEscaped, w, r)
										case "GET":
											s.handleGetWorkspaceConfigurationRequest([0]string{}, elemIsEscaped, w, r)
										case "PUT":
											s.handleUpsertWorkspaceConfigurationRequest([0]string{}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "DELETE,GET,PUT")
										}

										return
									}

								case 's': // Prefix: "sts"

									if l := len("sts"); len(elem) >= l && elem[0:l] == "sts" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch r.Method {
										case "POST":
											s.handleGetCostRequest([0]string{}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "POST")
										}

										return
									}
									switch elem[0] {
									case '/': // Prefix: "/summaries"

										if l := len("/summaries"); len(elem) >= l && elem[0:l] == "/summaries" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "POST":
												s.handleCostsSummaryRequest([0]string{}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "POST")
											}

											return
										}

									}

								}

							case 'm': // Prefix: "metrics"

								if l := len("metrics"); len(elem) >= l && elem[0:l] == "metrics" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch r.Method {
									case "POST":
										s.handleGetMetricRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "POST")
									}

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/summaries"

									if l := len("/summaries"); len(elem) >= l && elem[0:l] == "/summaries" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "POST":
											s.handleMetricsSummaryRequest([0]string{}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "POST")
										}

										return
									}

								}

							}

						}

					}

				}

			}

		}
	}
	s.notFound(w, r)
}

// Route is route object.
type Route struct {
	name           string
	summary        string
	operationID    string
	operationGroup string
	pathPattern    string
	count          int
	args           [3]string
}

// Name returns ogen operation name.
//
// It is guaranteed to be unique and not empty.
func (r Route) Name() string {
	return r.name
}

// Summary returns OpenAPI summary.
func (r Route) Summary() string {
	return r.summary
}

// OperationID returns OpenAPI operationId.
func (r Route) OperationID() string {
	return r.operationID
}

// OperationGroup returns the x-ogen-operation-group value.
func (r Route) OperationGroup() string {
	return r.operationGroup
}

// PathPattern returns OpenAPI path.
func (r Route) PathPattern() string {
	return r.pathPattern
}

// Args returns parsed arguments.
func (r Route) Args() []string {
	return r.args[:r.count]
}

// FindRoute finds Route for given method and path.
//
// Note: this method does not unescape path or handle reserved characters in path properly. Use FindPath instead.
func (s *Server) FindRoute(method, path string) (Route, bool) {
	return s.FindPath(method, &url.URL{Path: path})
}

// FindPath finds Route for given method and URL.
func (s *Server) FindPath(method string, u *url.URL) (r Route, _ bool) {
	var (
		elem = u.Path
		args = r.args
	)
	if rawPath := u.RawPath; rawPath != "" {
		if normalized, ok := uri.NormalizeEscapedPath(rawPath); ok {
			elem = normalized
		}
		defer func() {
			for i, arg := range r.args[:r.count] {
				if unescaped, err := url.PathUnescape(arg); err == nil {
					r.args[i] = unescaped
				}
			}
		}()
	}

	elem, ok := s.cutPrefix(elem)
	if !ok {
		return r, false
	}

	// Static code generated router with unwrapped path search.
	switch {
	default:
		if len(elem) == 0 {
			break
		}
		switch elem[0] {
		case '/': // Prefix: "/"

			if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
				elem = elem[l:]
			} else {
				break
			}

			if len(elem) == 0 {
				break
			}
			switch elem[0] {
			case 'i': // Prefix: "is-alive/"

				if l := len("is-alive/"); len(elem) >= l && elem[0:l] == "is-alive/" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'p': // Prefix: "ping"

					if l := len("ping"); len(elem) >= l && elem[0:l] == "ping" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf node.
						switch method {
						case "GET":
							r.name = IsAliveOperation
							r.summary = ""
							r.operationID = "isAlive"
							r.operationGroup = ""
							r.pathPattern = "/is-alive/ping"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}

				case 'v': // Prefix: "ver"

					if l := len("ver"); len(elem) >= l && elem[0:l] == "ver" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf node.
						switch method {
						case "GET":
							r.name = VersionOperation
							r.summary = ""
							r.operationID = "version"
							r.operationGroup = ""
							r.pathPattern = "/is-alive/ver"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}

				}

			case 'v': // Prefix: "v1/"

				if l := len("v1/"); len(elem) >= l && elem[0:l] == "v1/" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'i': // Prefix: "internal/usage/"

					if l := len("internal/usage/"); len(elem) >= l && elem[0:l] == "internal/usage/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'b': // Prefix: "bi-"

						if l := len("bi-"); len(elem) >= l && elem[0:l] == "bi-" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'd': // Prefix: "datasets"

							if l := len("datasets"); len(elem) >= l && elem[0:l] == "datasets" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "GET":
									r.name = GetDatasetBiInfoOperation
									r.summary = "Get datasets information for BI events"
									r.operationID = "getDatasetBiInfo"
									r.operationGroup = ""
									r.pathPattern = "/v1/internal/usage/bi-datasets"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}

						case 'e': // Prefix: "experiments"

							if l := len("experiments"); len(elem) >= l && elem[0:l] == "experiments" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "GET":
									r.name = GetExperimentBiInfoOperation
									r.summary = "Get experiments information for BI events"
									r.operationID = "getExperimentBiInfo"
									r.operationGroup = ""
									r.pathPattern = "/v1/internal/usage/bi-experiments"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}

						case 's': // Prefix: "spans"

							if l := len("spans"); len(elem) >= l && elem[0:l] == "spans" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "GET":
									r.name = GetSpansBiInfoOperation
									r.summary = "Get spans information for BI events"
									r.operationID = "getSpansBiInfo"
									r.operationGroup = ""
									r.pathPattern = "/v1/internal/usage/bi-spans"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}

						case 't': // Prefix: "traces"

							if l := len("traces"); len(elem) >= l && elem[0:l] == "traces" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "GET":
									r.name = GetTracesBiInfoOperation
									r.summary = "Get traces information for BI events"
									r.operationID = "getTracesBiInfo"
									r.operationGroup = ""
									r.pathPattern = "/v1/internal/usage/bi-traces"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}

						}

					case 'w': // Prefix: "workspace-"

						if l := len("workspace-"); len(elem) >= l && elem[0:l] == "workspace-" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 's': // Prefix: "span-counts"

							if l := len("span-counts"); len(elem) >= l && elem[0:l] == "span-counts" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "GET":
									r.name = GetSpansCountForWorkspacesOperation
									r.summary = "Get spans count on previous day for all available workspaces"
									r.operationID = "getSpansCountForWorkspaces"
									r.operationGroup = ""
									r.pathPattern = "/v1/internal/usage/workspace-span-counts"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}

						case 't': // Prefix: "trace-counts"

							if l := len("trace-counts"); len(elem) >= l && elem[0:l] == "trace-counts" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "GET":
									r.name = GetTracesCountForWorkspacesOperation
									r.summary = "Get traces count on previous day for all available workspaces"
									r.operationID = "getTracesCountForWorkspaces"
									r.operationGroup = ""
									r.pathPattern = "/v1/internal/usage/workspace-trace-counts"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}

						}

					}

				case 'p': // Prefix: "private/"

					if l := len("private/"); len(elem) >= l && elem[0:l] == "private/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'a': // Prefix: "a"

						if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'l': // Prefix: "lerts"

							if l := len("lerts"); len(elem) >= l && elem[0:l] == "lerts" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									r.name = FindAlertsOperation
									r.summary = "Find alerts"
									r.operationID = "findAlerts"
									r.operationGroup = ""
									r.pathPattern = "/v1/private/alerts"
									r.args = args
									r.count = 0
									return r, true
								case "POST":
									r.name = CreateAlertOperation
									r.summary = "Create alert"
									r.operationID = "createAlert"
									r.operationGroup = ""
									r.pathPattern = "/v1/private/alerts"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'd': // Prefix: "delete"
									origElem := elem
									if l := len("delete"); len(elem) >= l && elem[0:l] == "delete" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "POST":
											r.name = DeleteAlertBatchOperation
											r.summary = "Delete alert batch"
											r.operationID = "deleteAlertBatch"
											r.operationGroup = ""
											r.pathPattern = "/v1/private/alerts/delete"
											r.args = args
											r.count = 0
											return r, true
										default:
											return
										}
									}

									elem = origElem
								case 'w': // Prefix: "webhooks/"
									origElem := elem
									if l := len("webhooks/"); len(elem) >= l && elem[0:l] == "webhooks/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'e': // Prefix: "examples"

										if l := len("examples"); len(elem) >= l && elem[0:l] == "examples" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch method {
											case "GET":
												r.name = GetWebhookExamplesOperation
												r.summary = "Get webhook payload examples"
												r.operationID = "getWebhookExamples"
												r.operationGroup = ""
												r.pathPattern = "/v1/private/alerts/webhooks/examples"
												r.args = args
												r.count = 0
												return r, true
											default:
												return
											}
										}

									case 't': // Prefix: "tests"

										if l := len("tests"); len(elem) >= l && elem[0:l] == "tests" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch method {
											case "POST":
												r.name = TestWebhookOperation
												r.summary = "Test alert webhook"
												r.operationID = "testWebhook"
												r.operationGroup = ""
												r.pathPattern = "/v1/private/alerts/webhooks/tests"
												r.args = args
												r.count = 0
												return r, true
											default:
												return
											}
										}

									}

									elem = origElem
								}
								// Param: "id"
								// Leaf parameter, slashes are prohibited
								idx := strings.IndexByte(elem, '/')
								if idx >= 0 {
									break
								}
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "GET":
										r.name = GetAlertByIdOperation
										r.summary = "Get Alert by id"
										r.operationID = "getAlertById"
										r.operationGroup = ""
										r.pathPattern = "/v1/private/alerts/{id}"
										r.args = args
										r.count = 1
										return r, true
									case "PUT":
										r.name = UpdateAlertOperation
										r.summary = "Update alert"
										r.operationID = "updateAlert"
										r.operationGroup = ""
										r.pathPattern = "/v1/private/alerts/{id}"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}

							}

						case 'n': // Prefix: "nnotation-queues"

							if l := len("nnotation-queues"); len(elem) >= l && elem[0:l] == "nnotation-queues" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									r.name = FindAnnotationQueuesOperation
									r.summary = "Find annotation queues"
									r.operationID = "findAnnotationQueues"
									r.operationGroup = ""
									r.pathPattern = "/v1/private/annotation-queues"
									r.args = args
									r.count = 0
									return r, true
								case "POST":
									r.name = CreateAnnotationQueueOperation
									r.summary = "Create annotation queue"
									r.operationID = "createAnnotationQueue"
									r.operationGroup = ""
									r.pathPattern = "/v1/private/annotation-queues"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'b': // Prefix: "batch"
									origElem := elem
									if l := len("batch"); len(elem) >= l && elem[0:l] == "batch" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "POST":
											r.name = CreateAnnotationQueueBatchOperation
											r.summary = "Create annotation queue batch"
											r.operationID = "createAnnotationQueueBatch"
											r.operationGroup = ""
											r.pathPattern = "/v1/private/annotation-queues/batch"
											r.args = args
											r.count = 0
											return r, true
										default:
											return
										}
									}

									elem = origElem
								case 'd': // Prefix: "delete"
									origElem := elem
									if l := len("delete"); len(elem) >= l && elem[0:l] == "delete" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "POST":
											r.name = DeleteAnnotationQueueBatchOperation
											r.summary = "Delete annotation queue batch"
											r.operationID = "deleteAnnotationQueueBatch"
											r.operationGroup = ""
											r.pathPattern = "/v1/private/annotation-queues/delete"
											r.args = args
											r.count = 0
											return r, true
										default:
											return
										}
									}

									elem = origElem
								}
								// Param: "id"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[0] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									switch method {
									case "GET":
										r.name = GetAnnotationQueueByIdOperation
										r.summary = "Get annotation queue by id"
										r.operationID = "getAnnotationQueueById"
										r.operationGroup = ""
										r.pathPattern = "/v1/private/annotation-queues/{id}"
										r.args = args
										r.count = 1
										return r, true
									case "PATCH":
										r.name = UpdateAnnotationQueueOperation
										r.summary = "Update annotation queue"
										r.operationID = "updateAnnotationQueue"
										r.operationGroup = ""
										r.pathPattern = "/v1/private/annotation-queues/{id}"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
								switch elem[0] {
								case '/': // Prefix: "/items/"

									if l := len("/items/"); len(elem) >= l && elem[0:l] == "/items/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'a': // Prefix: "add"

										if l := len("add"); len(elem) >= l && elem[0:l] == "add" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch method {
											case "POST":
												r.name = AddItemsToAnnotationQueueOperation
												r.summary = "Add items to annotation queue"
												r.operationID = "addItemsToAnnotationQueue"
												r.operationGroup = ""
												r.pathPattern = "/v1/private/annotation-queues/{id}/items/add"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}

									case 'd': // Prefix: "delete"

										if l := len("delete"); len(elem) >= l && elem[0:l] == "delete" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch method {
											case "POST":
												r.name = RemoveItemsFromAnnotationQueueOperation
												r.summary = "Remove items from annotation queue"
												r.operationID = "removeItemsFromAnnotationQueue"
												r.operationGroup = ""
												r.pathPattern = "/v1/private/annotation-queues/{id}/items/delete"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}

									}

								}

							}

						case 't': // Prefix: "ttachment/"

							if l := len("ttachment/"); len(elem) >= l && elem[0:l] == "ttachment/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'd': // Prefix: "delete"

								if l := len("delete"); len(elem) >= l && elem[0:l] == "delete" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "POST":
										r.name = DeleteAttachmentsOperation
										r.summary = "Delete attachments"
										r.operationID = "deleteAttachments"
										r.operationGroup = ""
										r.pathPattern = "/v1/private/attachment/delete"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}

							case 'l': // Prefix: "list"

								if l := len("list"); len(elem) >= l && elem[0:l] == "list" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "GET":
										r.name = AttachmentListOperation
										r.summary = "Attachments list for entity"
										r.operationID = "attachmentList"
										r.operationGroup = ""
										r.pathPattern = "/v1/private/attachment/list"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}

							case 'u': // Prefix: "upload-"

								if l := len("upload-"); len(elem) >= l && elem[0:l] == "upload-" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'c': // Prefix: "complete"

									if l := len("complete"); len(elem) >= l && elem[0:l] == "complete" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "POST":
											r.name = CompleteMultiPartUploadOperation
											r.summary = "Complete multipart attachment upload"
											r.operationID = "completeMultiPartUpload"
											r.operationGroup = ""
											r.pathPattern = "/v1/private/attachment/upload-complete"
											r.args = args
											r.count = 0
											return r, true
										default:
											return
										}
									}

								case 's': // Prefix: "start"

									if l := len("start"); len(elem) >= l && elem[0:l] == "start" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "POST":
											r.name = StartMultiPartUploadOperation
											r.summary = "Start multipart attachment upload"
											r.operationID = "startMultiPartUpload"
											r.operationGroup = ""
											r.pathPattern = "/v1/private/attachment/upload-start"
											r.args = args
											r.count = 0
											return r, true
										default:
											return
										}
									}

								}

							}

						case 'u': // Prefix: "ut"

							if l := len("ut"); len(elem) >= l && elem[0:l] == "ut" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'h': // Prefix: "h"

								if l := len("h"); len(elem) >= l && elem[0:l] == "h" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "POST":
										r.name = CheckAccessOperation
										r.summary = "Check user access to workspace"
										r.operationID = "checkAccess"
										r.operationGroup = ""
										r.pathPattern = "/v1/private/auth"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}
								switch elem[0] {
								case '/': // Prefix: "/workspace"

									if l := len("/workspace"); len(elem) >= l && elem[0:l] == "/workspace" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "GET":
											r.name = GetWorkspaceNameOperation
											r.summary = "User's default workspace name"
											r.operationID = "getWorkspaceName"
											r.operationGroup = ""
											r.pathPattern = "/v1/private/auth/workspace"
											r.args = args
											r.count = 0
											return r, true
										default:
											return
										}
									}

								}

							case 'o': // Prefix: "omations/evaluators"

								if l := len("omations/evaluators"); len(elem) >= l && elem[0:l] == "omations/evaluators" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										r.name = FindEvaluatorsOperation
										r.summary = "Find project Evaluators"
										r.operationID = "findEvaluators"
										r.operationGroup = ""
										r.pathPattern = "/v1/private/automations/evaluators"
										r.args = args
										r.count = 0
										return r, true
									case "POST":
										r.name = CreateAutomationRuleEvaluatorOperation
										r.summary = "Create automation rule evaluator"
										r.operationID = "createAutomationRuleEvaluator"
										r.operationGroup = ""
										r.pathPattern = "/v1/private/automations/evaluators"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}
								switch elem[0] {
								case '/': // Prefix: "/"

									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'd': // Prefix: "delete"
										origElem := elem
										if l := len("delete"); len(elem) >= l && elem[0:l] == "delete" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch method {
											case "POST":
												r.name = DeleteAutomationRuleEvaluatorBatchOperation
												r.summary = "Delete automation rule evaluators"
												r.operationID = "deleteAutomationRuleEvaluatorBatch"
												r.operationGroup = ""
												r.pathPattern = "/v1/private/automations/evaluators/delete"
												r.args = args
												r.count = 0
												return r, true
											default:
												return
											}
										}

										elem = origElem
									}
									// Param: "id"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[0] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										switch method {
										case "GET":
											r.name = GetEvaluatorByIdOperation
											r.summary = "Get automation rule evaluator by id"
											r.operationID = "getEvaluatorById"
											r.operationGroup = ""
											r.pathPattern = "/v1/private/automations/evaluators/{id}"
											r.args = args
											r.count = 1
											return r, true
										case "PATCH":
											r.name = UpdateAutomationRuleEvaluatorOperation
											r.summary = "Update Automation Rule Evaluator by id"
											r.operationID = "updateAutomationRuleEvaluator"
											r.operationGroup = ""
											r.pathPattern = "/v1/private/automations/evaluators/{id}"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}
									switch elem[0] {
									case '/': // Prefix: "/logs"

										if l := len("/logs"); len(elem) >= l && elem[0:l] == "/logs" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch method {
											case "GET":
												r.name = GetEvaluatorLogsByIdOperation
												r.summary = "Get automation rule evaluator logs by id"
												r.operationID = "getEvaluatorLogsById"
												r.operationGroup = ""
												r.pathPattern = "/v1/private/automations/evaluators/{id}/logs"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}

									}

								}

							}

						}

					case 'c': // Prefix: "chat/completions"

						if l := len("chat/completions"); len(elem) >= l && elem[0:l] == "chat/completions" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "POST":
								r.name = CreateChatCompletionsOperation
								r.summary = "Create chat completions"
								r.operationID = "createChatCompletions"
								r.operationGroup = ""
								r.pathPattern = "/v1/private/chat/completions"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

					case 'd': // Prefix: "da"

						if l := len("da"); len(elem) >= l && elem[0:l] == "da" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 's': // Prefix: "shboards"

							if l := len("shboards"); len(elem) >= l && elem[0:l] == "shboards" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									r.name = FindDashboardsOperation
									r.summary = "Find dashboards"
									r.operationID = "findDashboards"
									r.operationGroup = ""
									r.pathPattern = "/v1/private/dashboards"
									r.args = args
									r.count = 0
									return r, true
								case "POST":
									r.name = CreateDashboardOperation
									r.summary = "Create dashboard"
									r.operationID = "createDashboard"
									r.operationGroup = ""
									r.pathPattern = "/v1/private/dashboards"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'd': // Prefix: "delete-batch"
									origElem := elem
									if l := len("delete-batch"); len(elem) >= l && elem[0:l] == "delete-batch" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "POST":
											r.name = DeleteDashboardsBatchOperation
											r.summary = "Delete dashboards"
											r.operationID = "deleteDashboardsBatch"
											r.operationGroup = ""
											r.pathPattern = "/v1/private/dashboards/delete-batch"
											r.args = args
											r.count = 0
											return r, true
										default:
											return
										}
									}

									elem = origElem
								}
								// Param: "dashboardId"
								// Leaf parameter, slashes are prohibited
								idx := strings.IndexByte(elem, '/')
								if idx >= 0 {
									break
								}
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "DELETE":
										r.name = DeleteDashboardOperation
										r.summary = "Delete dashboard"
										r.operationID = "deleteDashboard"
										r.operationGroup = ""
										r.pathPattern = "/v1/private/dashboards/{dashboardId}"
										r.args = args
										r.count = 1
										return r, true
									case "GET":
										r.name = GetDashboardByIdOperation
										r.summary = "Get dashboard by id"
										r.operationID = "getDashboardById"
										r.operationGroup = ""
										r.pathPattern = "/v1/private/dashboards/{dashboardId}"
										r.args = args
										r.count = 1
										return r, true
									case "PATCH":
										r.name = UpdateDashboardOperation
										r.summary = "Update dashboard"
										r.operationID = "updateDashboard"
										r.operationGroup = ""
										r.pathPattern = "/v1/private/dashboards/{dashboardId}"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}

							}

						case 't': // Prefix: "tasets"

							if l := len("tasets"); len(elem) >= l && elem[0:l] == "tasets" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									r.name = FindDatasetsOperation
									r.summary = "Find datasets"
									r.operationID = "findDatasets"
									r.operationGroup = ""
									r.pathPattern = "/v1/private/datasets"
									r.args = args
									r.count = 0
									return r, true
								case "POST":
									r.name = CreateDatasetOperation
									r.summary = "Create dataset"
									r.operationID = "createDataset"
									r.operationGroup = ""
									r.pathPattern = "/v1/private/datasets"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'd': // Prefix: "delete"
									origElem := elem
									if l := len("delete"); len(elem) >= l && elem[0:l] == "delete" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "POST":
											r.name = DeleteDatasetByNameOperation
											r.summary = "Delete dataset by name"
											r.operationID = "deleteDatasetByName"
											r.operationGroup = ""
											r.pathPattern = "/v1/private/datasets/delete"
											r.args = args
											r.count = 0
											return r, true
										default:
											return
										}
									}
									switch elem[0] {
									case '-': // Prefix: "-batch"

										if l := len("-batch"); len(elem) >= l && elem[0:l] == "-batch" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch method {
											case "POST":
												r.name = DeleteDatasetsBatchOperation
												r.summary = "Delete datasets"
												r.operationID = "deleteDatasetsBatch"
												r.operationGroup = ""
												r.pathPattern = "/v1/private/datasets/delete-batch"
												r.args = args
												r.count = 0
												return r, true
											default:
												return
											}
										}

									}

									elem = origElem
								case 'i': // Prefix: "items"
									origElem := elem
									if l := len("items"); len(elem) >= l && elem[0:l] == "items" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "PUT":
											r.name = CreateOrUpdateDatasetItemsOperation
											r.summary = "Create/update dataset items"
											r.operationID = "createOrUpdateDatasetItems"
											r.operationGroup = ""
											r.pathPattern = "/v1/private/datasets/items"
											r.args = args
											r.count = 0
											return r, true
										default:
											return
										}
									}
									switch elem[0] {
									case '/': // Prefix: "/"

										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'b': // Prefix: "batch"
											origElem := elem
											if l := len("batch"); len(elem) >= l && elem[0:l] == "batch" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch method {
												case "PATCH":
													r.name = BatchUpdateDatasetItemsOperation
													r.summary = "Batch update dataset items"
													r.operationID = "batchUpdateDatasetItems"
													r.operationGroup = ""
													r.pathPattern = "/v1/private/datasets/items/batch"
													r.args = args
													r.count = 0
													return r, true
												default:
													return
												}
											}

											elem = origElem
										case 'd': // Prefix: "delete"
											origElem := elem
											if l := len("delete"); len(elem) >= l && elem[0:l] == "delete" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch method {
												case "POST":
													r.name = DeleteDatasetItemsOperation
													r.summary = "Delete dataset items"
													r.operationID = "deleteDatasetItems"
													r.operationGroup = ""
													r.pathPattern = "/v1/private/datasets/items/delete"
													r.args = args
													r.count = 0
													return r, true
												default:
													return
												}
											}

											elem = origElem
										case 'f': // Prefix: "from-csv"
											origElem := elem
											if l := len("from-csv"); len(elem) >= l && elem[0:l] == "from-csv" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch method {
												case "POST":
													r.name = CreateDatasetItemsFromCsvOperation
													r.summary = "Create dataset items from CSV file"
													r.operationID = "createDatasetItemsFromCsv"
													r.operationGroup = ""
													r.pathPattern = "/v1/private/datasets/items/from-csv"
													r.args = args
													r.count = 0
													return r, true
												default:
													return
												}
											}

											elem = origElem
										}
										// Param: "itemId"
										// Leaf parameter, slashes are prohibited
										idx := strings.IndexByte(elem, '/')
										if idx >= 0 {
											break
										}
										args[0] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf node.
											switch method {
											case "GET":
												r.name = GetDatasetItemByIdOperation
												r.summary = "Get dataset item by id"
												r.operationID = "getDatasetItemById"
												r.operationGroup = ""
												r.pathPattern = "/v1/private/datasets/items/{itemId}"
												r.args = args
												r.count = 1
												return r, true
											case "PATCH":
												r.name = PatchDatasetItemOperation
												r.summary = "Partially update dataset item by id"
												r.operationID = "patchDatasetItem"
												r.operationGroup = ""
												r.pathPattern = "/v1/private/datasets/items/{itemId}"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}

									}

									elem = origElem
								case 'r': // Prefix: "retrieve"
									origElem := elem
									if l := len("retrieve"); len(elem) >= l && elem[0:l] == "retrieve" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "POST":
											r.name = GetDatasetByIdentifierOperation
											r.summary = "Get dataset by name"
											r.operationID = "getDatasetByIdentifier"
											r.operationGroup = ""
											r.pathPattern = "/v1/private/datasets/retrieve"
											r.args = args
											r.count = 0
											return r, true
										default:
											return
										}
									}

									elem = origElem
								}
								// Param: "id"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[0] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									switch method {
									case "DELETE":
										r.name = DeleteDatasetOperation
										r.summary = "Delete dataset by id"
										r.operationID = "deleteDataset"
										r.operationGroup = ""
										r.pathPattern = "/v1/private/datasets/{id}"
										r.args = args
										r.count = 1
										return r, true
									case "GET":
										r.name = GetDatasetByIdOperation
										r.summary = "Get dataset by id"
										r.operationID = "getDatasetById"
										r.operationGroup = ""
										r.pathPattern = "/v1/private/datasets/{id}"
										r.args = args
										r.count = 1
										return r, true
									case "PUT":
										r.name = UpdateDatasetOperation
										r.summary = "Update dataset by id"
										r.operationID = "updateDataset"
										r.operationGroup = ""
										r.pathPattern = "/v1/private/datasets/{id}"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
								switch elem[0] {
								case '/': // Prefix: "/"

									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'e': // Prefix: "expansions"

										if l := len("expansions"); len(elem) >= l && elem[0:l] == "expansions" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch method {
											case "POST":
												r.name = ExpandDatasetOperation
												r.summary = "Expand dataset with synthetic samples"
												r.operationID = "expandDataset"
												r.operationGroup = ""
												r.pathPattern = "/v1/private/datasets/{id}/expansions"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}

									case 'i': // Prefix: "items"

										if l := len("items"); len(elem) >= l && elem[0:l] == "items" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch method {
											case "GET":
												r.name = GetDatasetItemsOperation
												r.summary = "Get dataset items"
												r.operationID = "getDatasetItems"
												r.operationGroup = ""
												r.pathPattern = "/v1/private/datasets/{id}/items"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}
										switch elem[0] {
										case '/': // Prefix: "/"

											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 'e': // Prefix: "experiments/items"

												if l := len("experiments/items"); len(elem) >= l && elem[0:l] == "experiments/items" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch method {
													case "GET":
														r.name = FindDatasetItemsWithExperimentItemsOperation
														r.summary = "Find dataset items with experiment items"
														r.operationID = "findDatasetItemsWithExperimentItems"
														r.operationGroup = ""
														r.pathPattern = "/v1/private/datasets/{id}/items/experiments/items"
														r.args = args
														r.count = 1
														return r, true
													default:
														return
													}
												}
												switch elem[0] {
												case '/': // Prefix: "/"

													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														break
													}
													switch elem[0] {
													case 'o': // Prefix: "output/columns"

														if l := len("output/columns"); len(elem) >= l && elem[0:l] == "output/columns" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf node.
															switch method {
															case "GET":
																r.name = GetDatasetItemsOutputColumnsOperation
																r.summary = "Get dataset items output columns"
																r.operationID = "getDatasetItemsOutputColumns"
																r.operationGroup = ""
																r.pathPattern = "/v1/private/datasets/{id}/items/experiments/items/output/columns"
																r.args = args
																r.count = 1
																return r, true
															default:
																return
															}
														}

													case 's': // Prefix: "stats"

														if l := len("stats"); len(elem) >= l && elem[0:l] == "stats" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf node.
															switch method {
															case "GET":
																r.name = GetDatasetExperimentItemsStatsOperation
																r.summary = "Get experiment items stats for dataset"
																r.operationID = "getDatasetExperimentItemsStats"
																r.operationGroup = ""
																r.pathPattern = "/v1/private/datasets/{id}/items/experiments/items/stats"
																r.args = args
																r.count = 1
																return r, true
															default:
																return
															}
														}

													}

												}

											case 'f': // Prefix: "from-"

												if l := len("from-"); len(elem) >= l && elem[0:l] == "from-" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 's': // Prefix: "spans"

													if l := len("spans"); len(elem) >= l && elem[0:l] == "spans" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf node.
														switch method {
														case "POST":
															r.name = CreateDatasetItemsFromSpansOperation
															r.summary = "Create dataset items from spans"
															r.operationID = "createDatasetItemsFromSpans"
															r.operationGroup = ""
															r.pathPattern = "/v1/private/datasets/{dataset_id}/items/from-spans"
															r.args = args
															r.count = 1
															return r, true
														default:
															return
														}
													}

												case 't': // Prefix: "traces"

													if l := len("traces"); len(elem) >= l && elem[0:l] == "traces" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf node.
														switch method {
														case "POST":
															r.name = CreateDatasetItemsFromTracesOperation
															r.summary = "Create dataset items from traces"
															r.operationID = "createDatasetItemsFromTraces"
															r.operationGroup = ""
															r.pathPattern = "/v1/private/datasets/{dataset_id}/items/from-traces"
															r.args = args
															r.count = 1
															return r, true
														default:
															return
														}
													}

												}

											}

										}

									case 'v': // Prefix: "versions"

										if l := len("versions"); len(elem) >= l && elem[0:l] == "versions" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch method {
											case "GET":
												r.name = ListDatasetVersionsOperation
												r.summary = "List dataset versions"
												r.operationID = "listDatasetVersions"
												r.operationGroup = ""
												r.pathPattern = "/v1/private/datasets/{id}/versions"
												r.args = args
												r.count = 1
												return r, true
											case "POST":
												r.name = CreateDatasetVersionOperation
												r.summary = "Create dataset version"
												r.operationID = "createDatasetVersion"
												r.operationGroup = ""
												r.pathPattern = "/v1/private/datasets/{id}/versions"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}
										switch elem[0] {
										case '/': // Prefix: "/"

											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 'd': // Prefix: "diff"
												origElem := elem
												if l := len("diff"); len(elem) >= l && elem[0:l] == "diff" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch method {
													case "GET":
														r.name = CompareDatasetVersionsOperation
														r.summary = "Compare latest version with draft"
														r.operationID = "compareDatasetVersions"
														r.operationGroup = ""
														r.pathPattern = "/v1/private/datasets/{id}/versions/diff"
														r.args = args
														r.count = 1
														return r, true
													default:
														return
													}
												}

												elem = origElem
											case 'h': // Prefix: "hash/"
												origElem := elem
												if l := len("hash/"); len(elem) >= l && elem[0:l] == "hash/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "versionHash"
												// Match until "/"
												idx := strings.IndexByte(elem, '/')
												if idx < 0 {
													idx = len(elem)
												}
												args[1] = elem[:idx]
												elem = elem[idx:]

												if len(elem) == 0 {
													switch method {
													case "PATCH":
														r.name = UpdateDatasetVersionOperation
														r.summary = "Update dataset version"
														r.operationID = "updateDatasetVersion"
														r.operationGroup = ""
														r.pathPattern = "/v1/private/datasets/{id}/versions/hash/{versionHash}"
														r.args = args
														r.count = 2
														return r, true
													default:
														return
													}
												}
												switch elem[0] {
												case '/': // Prefix: "/tags"

													if l := len("/tags"); len(elem) >= l && elem[0:l] == "/tags" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf node.
														switch method {
														case "POST":
															r.name = CreateVersionTagOperation
															r.summary = "Create version tag"
															r.operationID = "createVersionTag"
															r.operationGroup = ""
															r.pathPattern = "/v1/private/datasets/{id}/versions/hash/{versionHash}/tags"
															r.args = args
															r.count = 2
															return r, true
														default:
															return
														}
													}

												}

												elem = origElem
											case 'r': // Prefix: "restore"
												origElem := elem
												if l := len("restore"); len(elem) >= l && elem[0:l] == "restore" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch method {
													case "POST":
														r.name = RestoreDatasetVersionOperation
														r.summary = "Restore dataset to a previous version"
														r.operationID = "restoreDatasetVersion"
														r.operationGroup = ""
														r.pathPattern = "/v1/private/datasets/{id}/versions/restore"
														r.args = args
														r.count = 1
														return r, true
													default:
														return
													}
												}

												elem = origElem
											}
											// Param: "versionHash"
											// Match until "/"
											idx := strings.IndexByte(elem, '/')
											if idx < 0 {
												idx = len(elem)
											}
											args[1] = elem[:idx]
											elem = elem[idx:]

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case '/': // Prefix: "/tags/"

												if l := len("/tags/"); len(elem) >= l && elem[0:l] == "/tags/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "tag"
												// Leaf parameter, slashes are prohibited
												idx := strings.IndexByte(elem, '/')
												if idx >= 0 {
													break
												}
												args[2] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf node.
													switch method {
													case "DELETE":
														r.name = DeleteVersionTagOperation
														r.summary = "Delete version tag"
														r.operationID = "deleteVersionTag"
														r.operationGroup = ""
														r.pathPattern = "/v1/private/datasets/{id}/versions/{versionHash}/tags/{tag}"
														r.args = args
														r.count = 3
														return r, true
													default:
														return
													}
												}

											}

										}

									}

								}

							}

						}

					case 'e': // Prefix: "experiments"

						if l := len("experiments"); len(elem) >= l && elem[0:l] == "experiments" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch method {
							case "GET":
								r.name = FindExperimentsOperation
								r.summary = "Find experiments"
								r.operationID = "findExperiments"
								r.operationGroup = ""
								r.pathPattern = "/v1/private/experiments"
								r.args = args
								r.count = 0
								return r, true
							case "POST":
								r.name = CreateExperimentOperation
								r.summary = "Create experiment"
								r.operationID = "createExperiment"
								r.operationGroup = ""
								r.pathPattern = "/v1/private/experiments"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/"

							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'd': // Prefix: "delete"
								origElem := elem
								if l := len("delete"); len(elem) >= l && elem[0:l] == "delete" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "POST":
										r.name = DeleteExperimentsByIdOperation
										r.summary = "Delete experiments by id"
										r.operationID = "deleteExperimentsById"
										r.operationGroup = ""
										r.pathPattern = "/v1/private/experiments/delete"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}

								elem = origElem
							case 'f': // Prefix: "f"
								origElem := elem
								if l := len("f"); len(elem) >= l && elem[0:l] == "f" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'e': // Prefix: "eedback-scores/names"

									if l := len("eedback-scores/names"); len(elem) >= l && elem[0:l] == "eedback-scores/names" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "GET":
											r.name = FindFeedbackScoreNamesOperation
											r.summary = "Find Feedback Score names"
											r.operationID = "findFeedbackScoreNames"
											r.operationGroup = ""
											r.pathPattern = "/v1/private/experiments/feedback-scores/names"
											r.args = args
											r.count = 0
											return r, true
										default:
											return
										}
									}

								case 'i': // Prefix: "inish"

									if l := len("inish"); len(elem) >= l && elem[0:l] == "inish" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "POST":
											r.name = FinishExperimentsOperation
											r.summary = "Finish experiments"
											r.operationID = "finishExperiments"
											r.operationGroup = ""
											r.pathPattern = "/v1/private/experiments/finish"
											r.args = args
											r.count = 0
											return r, true
										default:
											return
										}
									}

								}

								elem = origElem
							case 'g': // Prefix: "groups"
								origElem := elem
								if l := len("groups"); len(elem) >= l && elem[0:l] == "groups" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										r.name = FindExperimentGroupsOperation
										r.summary = "Find experiment groups"
										r.operationID = "findExperimentGroups"
										r.operationGroup = ""
										r.pathPattern = "/v1/private/experiments/groups"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}
								switch elem[0] {
								case '/': // Prefix: "/aggregations"

									if l := len("/aggregations"); len(elem) >= l && elem[0:l] == "/aggregations" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "GET":
											r.name = FindExperimentGroupsAggregationsOperation
											r.summary = "Find experiment groups with aggregations"
											r.operationID = "findExperimentGroupsAggregations"
											r.operationGroup = ""
											r.pathPattern = "/v1/private/experiments/groups/aggregations"
											r.args = args
											r.count = 0
											return r, true
										default:
											return
										}
									}

								}

								elem = origElem
							case 'i': // Prefix: "items"
								origElem := elem
								if l := len("items"); len(elem) >= l && elem[0:l] == "items" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "POST":
										r.name = CreateExperimentItemsOperation
										r.summary = "Create experiment items"
										r.operationID = "createExperimentItems"
										r.operationGroup = ""
										r.pathPattern = "/v1/private/experiments/items"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}
								switch elem[0] {
								case '/': // Prefix: "/"

									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'b': // Prefix: "bulk"
										origElem := elem
										if l := len("bulk"); len(elem) >= l && elem[0:l] == "bulk" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch method {
											case "PUT":
												r.name = ExperimentItemsBulkOperation
												r.summary = "Record experiment items in bulk"
												r.operationID = "experimentItemsBulk"
												r.operationGroup = ""
												r.pathPattern = "/v1/private/experiments/items/bulk"
												r.args = args
												r.count = 0
												return r, true
											default:
												return
											}
										}

										elem = origElem
									case 'd': // Prefix: "delete"
										origElem := elem
										if l := len("delete"); len(elem) >= l && elem[0:l] == "delete" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch method {
											case "POST":
												r.name = DeleteExperimentItemsOperation
												r.summary = "Delete experiment items"
												r.operationID = "deleteExperimentItems"
												r.operationGroup = ""
												r.pathPattern = "/v1/private/experiments/items/delete"
												r.args = args
												r.count = 0
												return r, true
											default:
												return
											}
										}

										elem = origElem
									}
									// Param: "id"
									// Leaf parameter, slashes are prohibited
									idx := strings.IndexByte(elem, '/')
									if idx >= 0 {
										break
									}
									args[0] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "GET":
											r.name = GetExperimentItemByIdOperation
											r.summary = "Get experiment item by id"
											r.operationID = "getExperimentItemById"
											r.operationGroup = ""
											r.pathPattern = "/v1/private/experiments/items/{id}"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}

								}

								elem = origElem
							}
							// Param: "id"
							// Leaf parameter, slashes are prohibited
							idx := strings.IndexByte(elem, '/')
							if idx >= 0 {
								break
							}
							args[0] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "GET":
									r.name = GetExperimentByIdOperation
									r.summary = "Get experiment by id"
									r.operationID = "getExperimentById"
									r.operationGroup = ""
									r.pathPattern = "/v1/private/experiments/{id}"
									r.args = args
									r.count = 1
									return r, true
								case "PATCH":
									r.name = UpdateExperimentOperation
									r.summary = "Update experiment by id"
									r.operationID = "updateExperiment"
									r.operationGroup = ""
									r.pathPattern = "/v1/private/experiments/{id}"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}

						}

					case 'f': // Prefix: "feedback-definitions"

						if l := len("feedback-definitions"); len(elem) >= l && elem[0:l] == "feedback-definitions" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch method {
							case "GET":
								r.name = FindFeedbackDefinitionsOperation
								r.summary = "Find Feedback definitions"
								r.operationID = "findFeedbackDefinitions"
								r.operationGroup = ""
								r.pathPattern = "/v1/private/feedback-definitions"
								r.args = args
								r.count = 0
								return r, true
							case "POST":
								r.name = CreateFeedbackDefinitionOperation
								r.summary = "Create feedback definition"
								r.operationID = "createFeedbackDefinition"
								r.operationGroup = ""
								r.pathPattern = "/v1/private/feedback-definitions"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/"

							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'd': // Prefix: "delete"
								origElem := elem
								if l := len("delete"); len(elem) >= l && elem[0:l] == "delete" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "POST":
										r.name = DeleteFeedbackDefinitionsBatchOperation
										r.summary = "Delete feedback definitions"
										r.operationID = "deleteFeedbackDefinitionsBatch"
										r.operationGroup = ""
										r.pathPattern = "/v1/private/feedback-definitions/delete"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}

								elem = origElem
							}
							// Param: "id"
							// Leaf parameter, slashes are prohibited
							idx := strings.IndexByte(elem, '/')
							if idx >= 0 {
								break
							}
							args[0] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "DELETE":
									r.name = DeleteFeedbackDefinitionByIdOperation
									r.summary = "Delete feedback definition by id"
									r.operationID = "deleteFeedbackDefinitionById"
									r.operationGroup = ""
									r.pathPattern = "/v1/private/feedback-definitions/{id}"
									r.args = args
									r.count = 1
									return r, true
								case "GET":
									r.name = GetFeedbackDefinitionByIdOperation
									r.summary = "Get feedback definition by id"
									r.operationID = "getFeedbackDefinitionById"
									r.operationGroup = ""
									r.pathPattern = "/v1/private/feedback-definitions/{id}"
									r.args = args
									r.count = 1
									return r, true
								case "PUT":
									r.name = UpdateFeedbackDefinitionOperation
									r.summary = "Update feedback definition by id"
									r.operationID = "updateFeedbackDefinition"
									r.operationGroup = ""
									r.pathPattern = "/v1/private/feedback-definitions/{id}"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}

						}

					case 'g': // Prefix: "guardrails"

						if l := len("guardrails"); len(elem) >= l && elem[0:l] == "guardrails" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "POST":
								r.name = CreateGuardrailsOperation
								r.summary = "Create guardrails for traces in a batch"
								r.operationID = "createGuardrails"
								r.operationGroup = ""
								r.pathPattern = "/v1/private/guardrails"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

					case 'l': // Prefix: "llm-provider-key"

						if l := len("llm-provider-key"); len(elem) >= l && elem[0:l] == "llm-provider-key" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch method {
							case "GET":
								r.name = FindLlmProviderKeysOperation
								r.summary = "Find LLM Provider's ApiKeys"
								r.operationID = "findLlmProviderKeys"
								r.operationGroup = ""
								r.pathPattern = "/v1/private/llm-provider-key"
								r.args = args
								r.count = 0
								return r, true
							case "POST":
								r.name = StoreLlmProviderApiKeyOperation
								r.summary = "Store LLM Provider's ApiKey"
								r.operationID = "storeLlmProviderApiKey"
								r.operationGroup = ""
								r.pathPattern = "/v1/private/llm-provider-key"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/"

							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'd': // Prefix: "delete"
								origElem := elem
								if l := len("delete"); len(elem) >= l && elem[0:l] == "delete" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "POST":
										r.name = DeleteLlmProviderApiKeysBatchOperation
										r.summary = "Delete LLM Provider's ApiKeys"
										r.operationID = "deleteLlmProviderApiKeysBatch"
										r.operationGroup = ""
										r.pathPattern = "/v1/private/llm-provider-key/delete"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}

								elem = origElem
							}
							// Param: "id"
							// Leaf parameter, slashes are prohibited
							idx := strings.IndexByte(elem, '/')
							if idx >= 0 {
								break
							}
							args[0] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "GET":
									r.name = GetLlmProviderApiKeyByIdOperation
									r.summary = "Get LLM Provider's ApiKey by id"
									r.operationID = "getLlmProviderApiKeyById"
									r.operationGroup = ""
									r.pathPattern = "/v1/private/llm-provider-key/{id}"
									r.args = args
									r.count = 1
									return r, true
								case "PATCH":
									r.name = UpdateLlmProviderApiKeyOperation
									r.summary = "Update LLM Provider's ApiKey"
									r.operationID = "updateLlmProviderApiKey"
									r.operationGroup = ""
									r.pathPattern = "/v1/private/llm-provider-key/{id}"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}

						}

					case 'm': // Prefix: "manual-evaluation/"

						if l := len("manual-evaluation/"); len(elem) >= l && elem[0:l] == "manual-evaluation/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 's': // Prefix: "spans"

							if l := len("spans"); len(elem) >= l && elem[0:l] == "spans" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "POST":
									r.name = EvaluateSpansOperation
									r.summary = "Manually evaluate spans"
									r.operationID = "evaluateSpans"
									r.operationGroup = ""
									r.pathPattern = "/v1/private/manual-evaluation/spans"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}

						case 't': // Prefix: "t"

							if l := len("t"); len(elem) >= l && elem[0:l] == "t" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'h': // Prefix: "hreads"

								if l := len("hreads"); len(elem) >= l && elem[0:l] == "hreads" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "POST":
										r.name = EvaluateThreadsOperation
										r.summary = "Manually evaluate threads"
										r.operationID = "evaluateThreads"
										r.operationGroup = ""
										r.pathPattern = "/v1/private/manual-evaluation/threads"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}

							case 'r': // Prefix: "races"

								if l := len("races"); len(elem) >= l && elem[0:l] == "races" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "POST":
										r.name = EvaluateTracesOperation
										r.summary = "Manually evaluate traces"
										r.operationID = "evaluateTraces"
										r.operationGroup = ""
										r.pathPattern = "/v1/private/manual-evaluation/traces"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}

							}

						}

					case 'o': // Prefix: "optimizations"

						if l := len("optimizations"); len(elem) >= l && elem[0:l] == "optimizations" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch method {
							case "GET":
								r.name = FindOptimizationsOperation
								r.summary = "Find optimizations"
								r.operationID = "findOptimizations"
								r.operationGroup = ""
								r.pathPattern = "/v1/private/optimizations"
								r.args = args
								r.count = 0
								return r, true
							case "POST":
								r.name = CreateOptimizationOperation
								r.summary = "Create optimization"
								r.operationID = "createOptimization"
								r.operationGroup = ""
								r.pathPattern = "/v1/private/optimizations"
								r.args = args
								r.count = 0
								return r, true
							case "PUT":
								r.name = UpsertOptimizationOperation
								r.summary = "Upsert optimization"
								r.operationID = "upsertOptimization"
								r.operationGroup = ""
								r.pathPattern = "/v1/private/optimizations"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/"

							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'd': // Prefix: "delete"
								origElem := elem
								if l := len("delete"); len(elem) >= l && elem[0:l] == "delete" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "POST":
										r.name = DeleteOptimizationsByIdOperation
										r.summary = "Delete optimizations by id"
										r.operationID = "deleteOptimizationsById"
										r.operationGroup = ""
										r.pathPattern = "/v1/private/optimizations/delete"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}

								elem = origElem
							case 's': // Prefix: "studio"
								origElem := elem
								if l := len("studio"); len(elem) >= l && elem[0:l] == "studio" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										r.name = FindStudioOptimizationsOperation
										r.summary = "Find Studio optimizations"
										r.operationID = "findStudioOptimizations"
										r.operationGroup = ""
										r.pathPattern = "/v1/private/optimizations/studio"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}
								switch elem[0] {
								case '/': // Prefix: "/"

									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "id"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[0] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										switch method {
										case "GET":
											r.name = GetStudioOptimizationByIdOperation
											r.summary = "Get Studio optimization by id"
											r.operationID = "getStudioOptimizationById"
											r.operationGroup = ""
											r.pathPattern = "/v1/private/optimizations/studio/{id}"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}
									switch elem[0] {
									case '/': // Prefix: "/"

										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'c': // Prefix: "cancel"

											if l := len("cancel"); len(elem) >= l && elem[0:l] == "cancel" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch method {
												case "GET":
													r.name = CancelStudioOptimizationsOperation
													r.summary = "Cancel Studio optimizations"
													r.operationID = "cancelStudioOptimizations"
													r.operationGroup = ""
													r.pathPattern = "/v1/private/optimizations/studio/{id}/cancel"
													r.args = args
													r.count = 1
													return r, true
												default:
													return
												}
											}

										case 'l': // Prefix: "logs"

											if l := len("logs"); len(elem) >= l && elem[0:l] == "logs" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch method {
												case "GET":
													r.name = GetStudioOptimizationLogsOperation
													r.summary = "Get Studio optimization logs"
													r.operationID = "getStudioOptimizationLogs"
													r.operationGroup = ""
													r.pathPattern = "/v1/private/optimizations/studio/{id}/logs"
													r.args = args
													r.count = 1
													return r, true
												default:
													return
												}
											}

										}

									}

								}

								elem = origElem
							}
							// Param: "id"
							// Leaf parameter, slashes are prohibited
							idx := strings.IndexByte(elem, '/')
							if idx >= 0 {
								break
							}
							args[0] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "GET":
									r.name = GetOptimizationByIdOperation
									r.summary = "Get optimization by id"
									r.operationID = "getOptimizationById"
									r.operationGroup = ""
									r.pathPattern = "/v1/private/optimizations/{id}"
									r.args = args
									r.count = 1
									return r, true
								case "PUT":
									r.name = UpdateOptimizationsByIdOperation
									r.summary = "Update optimization by id"
									r.operationID = "updateOptimizationsById"
									r.operationGroup = ""
									r.pathPattern = "/v1/private/optimizations/{id}"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}

						}

					case 'p': // Prefix: "pro"

						if l := len("pro"); len(elem) >= l && elem[0:l] == "pro" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'j': // Prefix: "jects"

							if l := len("jects"); len(elem) >= l && elem[0:l] == "jects" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									r.name = FindProjectsOperation
									r.summary = "Find projects"
									r.operationID = "findProjects"
									r.operationGroup = ""
									r.pathPattern = "/v1/private/projects"
									r.args = args
									r.count = 0
									return r, true
								case "POST":
									r.name = CreateProjectOperation
									r.summary = "Create project"
									r.operationID = "createProject"
									r.operationGroup = ""
									r.pathPattern = "/v1/private/projects"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'd': // Prefix: "delete"
									origElem := elem
									if l := len("delete"); len(elem) >= l && elem[0:l] == "delete" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "POST":
											r.name = DeleteProjectsBatchOperation
											r.summary = "Delete projects"
											r.operationID = "deleteProjectsBatch"
											r.operationGroup = ""
											r.pathPattern = "/v1/private/projects/delete"
											r.args = args
											r.count = 0
											return r, true
										default:
											return
										}
									}

									elem = origElem
								case 'f': // Prefix: "feedback-scores/names"
									origElem := elem
									if l := len("feedback-scores/names"); len(elem) >= l && elem[0:l] == "feedback-scores/names" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "GET":
											r.name = FindFeedbackScoreNamesByProjectIdsOperation
											r.summary = "Find Feedback Score names By Project Ids"
											r.operationID = "findFeedbackScoreNamesByProjectIds"
											r.operationGroup = ""
											r.pathPattern = "/v1/private/projects/feedback-scores/names"
											r.args = args
											r.count = 0
											return r, true
										default:
											return
										}
									}

									elem = origElem
								case 'r': // Prefix: "retrieve"
									origElem := elem
									if l := len("retrieve"); len(elem) >= l && elem[0:l] == "retrieve" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "POST":
											r.name = RetrieveProjectOperation
											r.summary = "Retrieve project"
											r.operationID = "retrieveProject"
											r.operationGroup = ""
											r.pathPattern = "/v1/private/projects/retrieve"
											r.args = args
											r.count = 0
											return r, true
										default:
											return
										}
									}

									elem = origElem
								case 's': // Prefix: "stats"
									origElem := elem
									if l := len("stats"); len(elem) >= l && elem[0:l] == "stats" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "GET":
											r.name = GetProjectStatsOperation
											r.summary = "Get Project Stats"
											r.operationID = "getProjectStats"
											r.operationGroup = ""
											r.pathPattern = "/v1/private/projects/stats"
											r.args = args
											r.count = 0
											return r, true
										default:
											return
										}
									}

									elem = origElem
								}
								// Param: "id"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[0] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									switch method {
									case "DELETE":
										r.name = DeleteProjectByIdOperation
										r.summary = "Delete project by id"
										r.operationID = "deleteProjectById"
										r.operationGroup = ""
										r.pathPattern = "/v1/private/projects/{id}"
										r.args = args
										r.count = 1
										return r, true
									case "GET":
										r.name = GetProjectByIdOperation
										r.summary = "Get project by id"
										r.operationID = "getProjectById"
										r.operationGroup = ""
										r.pathPattern = "/v1/private/projects/{id}"
										r.args = args
										r.count = 1
										return r, true
									case "PATCH":
										r.name = UpdateProjectOperation
										r.summary = "Update project by id"
										r.operationID = "updateProject"
										r.operationGroup = ""
										r.pathPattern = "/v1/private/projects/{id}"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
								switch elem[0] {
								case '/': // Prefix: "/metrics"

									if l := len("/metrics"); len(elem) >= l && elem[0:l] == "/metrics" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "POST":
											r.name = GetProjectMetricsOperation
											r.summary = "Get Project Metrics"
											r.operationID = "getProjectMetrics"
											r.operationGroup = ""
											r.pathPattern = "/v1/private/projects/{id}/metrics"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}

								}

							}

						case 'm': // Prefix: "mpts"

							if l := len("mpts"); len(elem) >= l && elem[0:l] == "mpts" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									r.name = GetPromptsOperation
									r.summary = "Get prompts"
									r.operationID = "getPrompts"
									r.operationGroup = ""
									r.pathPattern = "/v1/private/prompts"
									r.args = args
									r.count = 0
									return r, true
								case "POST":
									r.name = CreatePromptOperation
									r.summary = "Create prompt"
									r.operationID = "createPrompt"
									r.operationGroup = ""
									r.pathPattern = "/v1/private/prompts"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'd': // Prefix: "delete"
									origElem := elem
									if l := len("delete"); len(elem) >= l && elem[0:l] == "delete" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "POST":
											r.name = DeletePromptsBatchOperation
											r.summary = "Delete prompts"
											r.operationID = "deletePromptsBatch"
											r.operationGroup = ""
											r.pathPattern = "/v1/private/prompts/delete"
											r.args = args
											r.count = 0
											return r, true
										default:
											return
										}
									}

									elem = origElem
								case 'v': // Prefix: "versions"
									origElem := elem
									if l := len("versions"); len(elem) >= l && elem[0:l] == "versions" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "PATCH":
											r.name = UpdatePromptVersionsOperation
											r.summary = "Update prompt versions"
											r.operationID = "updatePromptVersions"
											r.operationGroup = ""
											r.pathPattern = "/v1/private/prompts/versions"
											r.args = args
											r.count = 0
											return r, true
										case "POST":
											r.name = CreatePromptVersionOperation
											r.summary = "Create prompt version"
											r.operationID = "createPromptVersion"
											r.operationGroup = ""
											r.pathPattern = "/v1/private/prompts/versions"
											r.args = args
											r.count = 0
											return r, true
										default:
											return
										}
									}
									switch elem[0] {
									case '/': // Prefix: "/"

										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'r': // Prefix: "retrieve"
											origElem := elem
											if l := len("retrieve"); len(elem) >= l && elem[0:l] == "retrieve" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch method {
												case "POST":
													r.name = RetrievePromptVersionOperation
													r.summary = "Retrieve prompt version"
													r.operationID = "retrievePromptVersion"
													r.operationGroup = ""
													r.pathPattern = "/v1/private/prompts/versions/retrieve"
													r.args = args
													r.count = 0
													return r, true
												default:
													return
												}
											}

											elem = origElem
										}
										// Param: "versionId"
										// Leaf parameter, slashes are prohibited
										idx := strings.IndexByte(elem, '/')
										if idx >= 0 {
											break
										}
										args[0] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf node.
											switch method {
											case "GET":
												r.name = GetPromptVersionByIdOperation
												r.summary = "Get prompt version by id"
												r.operationID = "getPromptVersionById"
												r.operationGroup = ""
												r.pathPattern = "/v1/private/prompts/versions/{versionId}"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}

									}

									elem = origElem
								}
								// Param: "id"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[0] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									switch method {
									case "DELETE":
										r.name = DeletePromptOperation
										r.summary = "Delete prompt"
										r.operationID = "deletePrompt"
										r.operationGroup = ""
										r.pathPattern = "/v1/private/prompts/{id}"
										r.args = args
										r.count = 1
										return r, true
									case "GET":
										r.name = GetPromptByIdOperation
										r.summary = "Get prompt by id"
										r.operationID = "getPromptById"
										r.operationGroup = ""
										r.pathPattern = "/v1/private/prompts/{id}"
										r.args = args
										r.count = 1
										return r, true
									case "PUT":
										r.name = UpdatePromptOperation
										r.summary = "Update prompt"
										r.operationID = "updatePrompt"
										r.operationGroup = ""
										r.pathPattern = "/v1/private/prompts/{id}"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
								switch elem[0] {
								case '/': // Prefix: "/versions"

									if l := len("/versions"); len(elem) >= l && elem[0:l] == "/versions" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "GET":
											r.name = GetPromptVersionsOperation
											r.summary = "Get prompt versions"
											r.operationID = "getPromptVersions"
											r.operationGroup = ""
											r.pathPattern = "/v1/private/prompts/{id}/versions"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}
									switch elem[0] {
									case '/': // Prefix: "/"

										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "versionId"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx < 0 {
											idx = len(elem)
										}
										args[1] = elem[:idx]
										elem = elem[idx:]

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case '/': // Prefix: "/restore"

											if l := len("/restore"); len(elem) >= l && elem[0:l] == "/restore" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch method {
												case "POST":
													r.name = RestorePromptVersionOperation
													r.summary = "Restore prompt version"
													r.operationID = "restorePromptVersion"
													r.operationGroup = ""
													r.pathPattern = "/v1/private/prompts/{promptId}/versions/{versionId}/restore"
													r.args = args
													r.count = 2
													return r, true
												default:
													return
												}
											}

										}

									}

								}

							}

						}

					case 's': // Prefix: "spans"

						if l := len("spans"); len(elem) >= l && elem[0:l] == "spans" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch method {
							case "GET":
								r.name = GetSpansByProjectOperation
								r.summary = "Get spans by project_name or project_id and optionally by trace_id and/or type"
								r.operationID = "getSpansByProject"
								r.operationGroup = ""
								r.pathPattern = "/v1/private/spans"
								r.args = args
								r.count = 0
								return r, true
							case "POST":
								r.name = CreateSpanOperation
								r.summary = "Create span"
								r.operationID = "createSpan"
								r.operationGroup = ""
								r.pathPattern = "/v1/private/spans"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/"

							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'b': // Prefix: "batch"
								origElem := elem
								if l := len("batch"); len(elem) >= l && elem[0:l] == "batch" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "PATCH":
										r.name = BatchUpdateSpansOperation
										r.summary = "Batch update spans"
										r.operationID = "batchUpdateSpans"
										r.operationGroup = ""
										r.pathPattern = "/v1/private/spans/batch"
										r.args = args
										r.count = 0
										return r, true
									case "POST":
										r.name = CreateSpansOperation
										r.summary = "Create spans"
										r.operationID = "createSpans"
										r.operationGroup = ""
										r.pathPattern = "/v1/private/spans/batch"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}

								elem = origElem
							case 'c': // Prefix: "comments/"
								origElem := elem
								if l := len("comments/"); len(elem) >= l && elem[0:l] == "comments/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'd': // Prefix: "delete"
									origElem := elem
									if l := len("delete"); len(elem) >= l && elem[0:l] == "delete" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "POST":
											r.name = DeleteSpanCommentsOperation
											r.summary = "Delete span comments"
											r.operationID = "deleteSpanComments"
											r.operationGroup = ""
											r.pathPattern = "/v1/private/spans/comments/delete"
											r.args = args
											r.count = 0
											return r, true
										default:
											return
										}
									}

									elem = origElem
								}
								// Param: "commentId"
								// Leaf parameter, slashes are prohibited
								idx := strings.IndexByte(elem, '/')
								if idx >= 0 {
									break
								}
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "PATCH":
										r.name = UpdateSpanCommentOperation
										r.summary = "Update span comment by id"
										r.operationID = "updateSpanComment"
										r.operationGroup = ""
										r.pathPattern = "/v1/private/spans/comments/{commentId}"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}

								elem = origElem
							case 'f': // Prefix: "feedback-scores"
								origElem := elem
								if l := len("feedback-scores"); len(elem) >= l && elem[0:l] == "feedback-scores" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "PUT":
										r.name = ScoreBatchOfSpansOperation
										r.summary = "Batch feedback scoring for spans"
										r.operationID = "scoreBatchOfSpans"
										r.operationGroup = ""
										r.pathPattern = "/v1/private/spans/feedback-scores"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}
								switch elem[0] {
								case '/': // Prefix: "/names"

									if l := len("/names"); len(elem) >= l && elem[0:l] == "/names" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "GET":
											r.name = FindFeedbackScoreNames1Operation
											r.summary = "Find Feedback Score names"
											r.operationID = "findFeedbackScoreNames_1"
											r.operationGroup = ""
											r.pathPattern = "/v1/private/spans/feedback-scores/names"
											r.args = args
											r.count = 0
											return r, true
										default:
											return
										}
									}

								}

								elem = origElem
							case 's': // Prefix: "stats"
								origElem := elem
								if l := len("stats"); len(elem) >= l && elem[0:l] == "stats" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "GET":
										r.name = GetSpanStatsOperation
										r.summary = "Get span stats"
										r.operationID = "getSpanStats"
										r.operationGroup = ""
										r.pathPattern = "/v1/private/spans/stats"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}

								elem = origElem
							}
							// Param: "id"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[0] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								switch method {
								case "DELETE":
									r.name = DeleteSpanByIdOperation
									r.summary = "Delete span by id"
									r.operationID = "deleteSpanById"
									r.operationGroup = ""
									r.pathPattern = "/v1/private/spans/{id}"
									r.args = args
									r.count = 1
									return r, true
								case "GET":
									r.name = GetSpanByIdOperation
									r.summary = "Get span by id"
									r.operationID = "getSpanById"
									r.operationGroup = ""
									r.pathPattern = "/v1/private/spans/{id}"
									r.args = args
									r.count = 1
									return r, true
								case "PATCH":
									r.name = UpdateSpanOperation
									r.summary = "Update span by id"
									r.operationID = "updateSpan"
									r.operationGroup = ""
									r.pathPattern = "/v1/private/spans/{id}"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'c': // Prefix: "comments"

									if l := len("comments"); len(elem) >= l && elem[0:l] == "comments" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "POST":
											r.name = AddSpanCommentOperation
											r.summary = "Add span comment"
											r.operationID = "addSpanComment"
											r.operationGroup = ""
											r.pathPattern = "/v1/private/spans/{id}/comments"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}
									switch elem[0] {
									case '/': // Prefix: "/"

										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "commentId"
										// Leaf parameter, slashes are prohibited
										idx := strings.IndexByte(elem, '/')
										if idx >= 0 {
											break
										}
										args[1] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf node.
											switch method {
											case "GET":
												r.name = GetSpanCommentOperation
												r.summary = "Get span comment"
												r.operationID = "getSpanComment"
												r.operationGroup = ""
												r.pathPattern = "/v1/private/spans/{spanId}/comments/{commentId}"
												r.args = args
												r.count = 2
												return r, true
											default:
												return
											}
										}

									}

								case 'f': // Prefix: "feedback-scores"

									if l := len("feedback-scores"); len(elem) >= l && elem[0:l] == "feedback-scores" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "PUT":
											r.name = AddSpanFeedbackScoreOperation
											r.summary = "Add span feedback score"
											r.operationID = "addSpanFeedbackScore"
											r.operationGroup = ""
											r.pathPattern = "/v1/private/spans/{id}/feedback-scores"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}
									switch elem[0] {
									case '/': // Prefix: "/delete"

										if l := len("/delete"); len(elem) >= l && elem[0:l] == "/delete" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch method {
											case "POST":
												r.name = DeleteSpanFeedbackScoreOperation
												r.summary = "Delete span feedback score"
												r.operationID = "deleteSpanFeedbackScore"
												r.operationGroup = ""
												r.pathPattern = "/v1/private/spans/{id}/feedback-scores/delete"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}

									}

								}

							}

						}

					case 't': // Prefix: "t"

						if l := len("t"); len(elem) >= l && elem[0:l] == "t" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'o': // Prefix: "oggles"

							if l := len("oggles"); len(elem) >= l && elem[0:l] == "oggles" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "GET":
									r.name = GetServiceTogglesOperation
									r.summary = "Get Service Toggles"
									r.operationID = "getServiceToggles"
									r.operationGroup = ""
									r.pathPattern = "/v1/private/toggles"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}

						case 'r': // Prefix: "races"

							if l := len("races"); len(elem) >= l && elem[0:l] == "races" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									r.name = GetTracesByProjectOperation
									r.summary = "Get traces by project_name or project_id"
									r.operationID = "getTracesByProject"
									r.operationGroup = ""
									r.pathPattern = "/v1/private/traces"
									r.args = args
									r.count = 0
									return r, true
								case "POST":
									r.name = CreateTraceOperation
									r.summary = "Create trace"
									r.operationID = "createTrace"
									r.operationGroup = ""
									r.pathPattern = "/v1/private/traces"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'b': // Prefix: "batch"
									origElem := elem
									if l := len("batch"); len(elem) >= l && elem[0:l] == "batch" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "PATCH":
											r.name = BatchUpdateTracesOperation
											r.summary = "Batch update traces"
											r.operationID = "batchUpdateTraces"
											r.operationGroup = ""
											r.pathPattern = "/v1/private/traces/batch"
											r.args = args
											r.count = 0
											return r, true
										case "POST":
											r.name = CreateTracesOperation
											r.summary = "Create traces"
											r.operationID = "createTraces"
											r.operationGroup = ""
											r.pathPattern = "/v1/private/traces/batch"
											r.args = args
											r.count = 0
											return r, true
										default:
											return
										}
									}

									elem = origElem
								case 'c': // Prefix: "comments/"
									origElem := elem
									if l := len("comments/"); len(elem) >= l && elem[0:l] == "comments/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'd': // Prefix: "delete"
										origElem := elem
										if l := len("delete"); len(elem) >= l && elem[0:l] == "delete" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch method {
											case "POST":
												r.name = DeleteTraceCommentsOperation
												r.summary = "Delete trace comments"
												r.operationID = "deleteTraceComments"
												r.operationGroup = ""
												r.pathPattern = "/v1/private/traces/comments/delete"
												r.args = args
												r.count = 0
												return r, true
											default:
												return
											}
										}

										elem = origElem
									}
									// Param: "commentId"
									// Leaf parameter, slashes are prohibited
									idx := strings.IndexByte(elem, '/')
									if idx >= 0 {
										break
									}
									args[0] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "PATCH":
											r.name = UpdateTraceCommentOperation
											r.summary = "Update trace comment by id"
											r.operationID = "updateTraceComment"
											r.operationGroup = ""
											r.pathPattern = "/v1/private/traces/comments/{commentId}"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}

									elem = origElem
								case 'd': // Prefix: "delete"
									origElem := elem
									if l := len("delete"); len(elem) >= l && elem[0:l] == "delete" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "POST":
											r.name = DeleteTracesOperation
											r.summary = "Delete traces"
											r.operationID = "deleteTraces"
											r.operationGroup = ""
											r.pathPattern = "/v1/private/traces/delete"
											r.args = args
											r.count = 0
											return r, true
										default:
											return
										}
									}

									elem = origElem
								case 'f': // Prefix: "feedback-scores"
									origElem := elem
									if l := len("feedback-scores"); len(elem) >= l && elem[0:l] == "feedback-scores" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "PUT":
											r.name = ScoreBatchOfTracesOperation
											r.summary = "Batch feedback scoring for traces"
											r.operationID = "scoreBatchOfTraces"
											r.operationGroup = ""
											r.pathPattern = "/v1/private/traces/feedback-scores"
											r.args = args
											r.count = 0
											return r, true
										default:
											return
										}
									}
									switch elem[0] {
									case '/': // Prefix: "/names"

										if l := len("/names"); len(elem) >= l && elem[0:l] == "/names" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch method {
											case "GET":
												r.name = FindFeedbackScoreNames2Operation
												r.summary = "Find Feedback Score names"
												r.operationID = "findFeedbackScoreNames_2"
												r.operationGroup = ""
												r.pathPattern = "/v1/private/traces/feedback-scores/names"
												r.args = args
												r.count = 0
												return r, true
											default:
												return
											}
										}

									}

									elem = origElem
								case 's': // Prefix: "stats"
									origElem := elem
									if l := len("stats"); len(elem) >= l && elem[0:l] == "stats" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "GET":
											r.name = GetTraceStatsOperation
											r.summary = "Get trace stats"
											r.operationID = "getTraceStats"
											r.operationGroup = ""
											r.pathPattern = "/v1/private/traces/stats"
											r.args = args
											r.count = 0
											return r, true
										default:
											return
										}
									}

									elem = origElem
								case 't': // Prefix: "threads"
									origElem := elem
									if l := len("threads"); len(elem) >= l && elem[0:l] == "threads" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "GET":
											r.name = GetTraceThreadsOperation
											r.summary = "Get trace threads"
											r.operationID = "getTraceThreads"
											r.operationGroup = ""
											r.pathPattern = "/v1/private/traces/threads"
											r.args = args
											r.count = 0
											return r, true
										default:
											return
										}
									}
									switch elem[0] {
									case '/': // Prefix: "/"

										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'b': // Prefix: "batch"
											origElem := elem
											if l := len("batch"); len(elem) >= l && elem[0:l] == "batch" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch method {
												case "PATCH":
													r.name = BatchUpdateThreadsOperation
													r.summary = "Batch update threads"
													r.operationID = "batchUpdateThreads"
													r.operationGroup = ""
													r.pathPattern = "/v1/private/traces/threads/batch"
													r.args = args
													r.count = 0
													return r, true
												default:
													return
												}
											}

											elem = origElem
										case 'c': // Prefix: "c"
											origElem := elem
											if l := len("c"); len(elem) >= l && elem[0:l] == "c" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 'l': // Prefix: "lose"

												if l := len("lose"); len(elem) >= l && elem[0:l] == "lose" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch method {
													case "PUT":
														r.name = CloseTraceThreadOperation
														r.summary = "Close trace thread(s)"
														r.operationID = "closeTraceThread"
														r.operationGroup = ""
														r.pathPattern = "/v1/private/traces/threads/close"
														r.args = args
														r.count = 0
														return r, true
													default:
														return
													}
												}

											case 'o': // Prefix: "omments/"

												if l := len("omments/"); len(elem) >= l && elem[0:l] == "omments/" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 'd': // Prefix: "delete"
													origElem := elem
													if l := len("delete"); len(elem) >= l && elem[0:l] == "delete" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf node.
														switch method {
														case "POST":
															r.name = DeleteThreadCommentsOperation
															r.summary = "Delete thread comments"
															r.operationID = "deleteThreadComments"
															r.operationGroup = ""
															r.pathPattern = "/v1/private/traces/threads/comments/delete"
															r.args = args
															r.count = 0
															return r, true
														default:
															return
														}
													}

													elem = origElem
												}
												// Param: "commentId"
												// Leaf parameter, slashes are prohibited
												idx := strings.IndexByte(elem, '/')
												if idx >= 0 {
													break
												}
												args[0] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf node.
													switch method {
													case "PATCH":
														r.name = UpdateThreadCommentOperation
														r.summary = "Update thread comment by id"
														r.operationID = "updateThreadComment"
														r.operationGroup = ""
														r.pathPattern = "/v1/private/traces/threads/comments/{commentId}"
														r.args = args
														r.count = 1
														return r, true
													default:
														return
													}
												}

											}

											elem = origElem
										case 'd': // Prefix: "delete"
											origElem := elem
											if l := len("delete"); len(elem) >= l && elem[0:l] == "delete" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch method {
												case "POST":
													r.name = DeleteTraceThreadsOperation
													r.summary = "Delete trace threads"
													r.operationID = "deleteTraceThreads"
													r.operationGroup = ""
													r.pathPattern = "/v1/private/traces/threads/delete"
													r.args = args
													r.count = 0
													return r, true
												default:
													return
												}
											}

											elem = origElem
										case 'f': // Prefix: "feedback-scores"
											origElem := elem
											if l := len("feedback-scores"); len(elem) >= l && elem[0:l] == "feedback-scores" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch method {
												case "PUT":
													r.name = ScoreBatchOfThreadsOperation
													r.summary = "Batch feedback scoring for threads"
													r.operationID = "scoreBatchOfThreads"
													r.operationGroup = ""
													r.pathPattern = "/v1/private/traces/threads/feedback-scores"
													r.args = args
													r.count = 0
													return r, true
												default:
													return
												}
											}
											switch elem[0] {
											case '/': // Prefix: "/"

												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 'd': // Prefix: "delete"

													if l := len("delete"); len(elem) >= l && elem[0:l] == "delete" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf node.
														switch method {
														case "POST":
															r.name = DeleteThreadFeedbackScoresOperation
															r.summary = "Delete thread feedback scores"
															r.operationID = "deleteThreadFeedbackScores"
															r.operationGroup = ""
															r.pathPattern = "/v1/private/traces/threads/feedback-scores/delete"
															r.args = args
															r.count = 0
															return r, true
														default:
															return
														}
													}

												case 'n': // Prefix: "names"

													if l := len("names"); len(elem) >= l && elem[0:l] == "names" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf node.
														switch method {
														case "GET":
															r.name = FindTraceThreadsFeedbackScoreNamesOperation
															r.summary = "Find Trace Threads Feedback Score names"
															r.operationID = "findTraceThreadsFeedbackScoreNames"
															r.operationGroup = ""
															r.pathPattern = "/v1/private/traces/threads/feedback-scores/names"
															r.args = args
															r.count = 0
															return r, true
														default:
															return
														}
													}

												}

											}

											elem = origElem
										case 'o': // Prefix: "open"
											origElem := elem
											if l := len("open"); len(elem) >= l && elem[0:l] == "open" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch method {
												case "PUT":
													r.name = OpenTraceThreadOperation
													r.summary = "Open trace thread"
													r.operationID = "openTraceThread"
													r.operationGroup = ""
													r.pathPattern = "/v1/private/traces/threads/open"
													r.args = args
													r.count = 0
													return r, true
												default:
													return
												}
											}

											elem = origElem
										case 'r': // Prefix: "retrieve"
											origElem := elem
											if l := len("retrieve"); len(elem) >= l && elem[0:l] == "retrieve" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch method {
												case "POST":
													r.name = GetTraceThreadOperation
													r.summary = "Get trace thread"
													r.operationID = "getTraceThread"
													r.operationGroup = ""
													r.pathPattern = "/v1/private/traces/threads/retrieve"
													r.args = args
													r.count = 0
													return r, true
												default:
													return
												}
											}

											elem = origElem
										case 's': // Prefix: "stats"
											origElem := elem
											if l := len("stats"); len(elem) >= l && elem[0:l] == "stats" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch method {
												case "GET":
													r.name = GetTraceThreadStatsOperation
													r.summary = "Get trace thread stats"
													r.operationID = "getTraceThreadStats"
													r.operationGroup = ""
													r.pathPattern = "/v1/private/traces/threads/stats"
													r.args = args
													r.count = 0
													return r, true
												default:
													return
												}
											}

											elem = origElem
										}
										// Param: "id"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx < 0 {
											idx = len(elem)
										}
										args[0] = elem[:idx]
										elem = elem[idx:]

										if len(elem) == 0 {
											switch method {
											case "PATCH":
												r.name = UpdateThreadOperation
												r.summary = "Update thread"
												r.operationID = "updateThread"
												r.operationGroup = ""
												r.pathPattern = "/v1/private/traces/threads/{threadModelId}"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}
										switch elem[0] {
										case '/': // Prefix: "/comments"

											if l := len("/comments"); len(elem) >= l && elem[0:l] == "/comments" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch method {
												case "POST":
													r.name = AddThreadCommentOperation
													r.summary = "Add thread comment"
													r.operationID = "addThreadComment"
													r.operationGroup = ""
													r.pathPattern = "/v1/private/traces/threads/{id}/comments"
													r.args = args
													r.count = 1
													return r, true
												default:
													return
												}
											}
											switch elem[0] {
											case '/': // Prefix: "/"

												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "commentId"
												// Leaf parameter, slashes are prohibited
												idx := strings.IndexByte(elem, '/')
												if idx >= 0 {
													break
												}
												args[1] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf node.
													switch method {
													case "GET":
														r.name = GetThreadCommentOperation
														r.summary = "Get thread comment"
														r.operationID = "getThreadComment"
														r.operationGroup = ""
														r.pathPattern = "/v1/private/traces/threads/{threadId}/comments/{commentId}"
														r.args = args
														r.count = 2
														return r, true
													default:
														return
													}
												}

											}

										}

									}

									elem = origElem
								}
								// Param: "id"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[0] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									switch method {
									case "DELETE":
										r.name = DeleteTraceByIdOperation
										r.summary = "Delete trace by id"
										r.operationID = "deleteTraceById"
										r.operationGroup = ""
										r.pathPattern = "/v1/private/traces/{id}"
										r.args = args
										r.count = 1
										return r, true
									case "GET":
										r.name = GetTraceByIdOperation
										r.summary = "Get trace by id"
										r.operationID = "getTraceById"
										r.operationGroup = ""
										r.pathPattern = "/v1/private/traces/{id}"
										r.args = args
										r.count = 1
										return r, true
									case "PATCH":
										r.name = UpdateTraceOperation
										r.summary = "Update trace by id"
										r.operationID = "updateTrace"
										r.operationGroup = ""
										r.pathPattern = "/v1/private/traces/{id}"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
								switch elem[0] {
								case '/': // Prefix: "/"

									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'c': // Prefix: "comments"

										if l := len("comments"); len(elem) >= l && elem[0:l] == "comments" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch method {
											case "POST":
												r.name = AddTraceCommentOperation
												r.summary = "Add trace comment"
												r.operationID = "addTraceComment"
												r.operationGroup = ""
												r.pathPattern = "/v1/private/traces/{id}/comments"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}
										switch elem[0] {
										case '/': // Prefix: "/"

											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "commentId"
											// Leaf parameter, slashes are prohibited
											idx := strings.IndexByte(elem, '/')
											if idx >= 0 {
												break
											}
											args[1] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf node.
												switch method {
												case "GET":
													r.name = GetTraceCommentOperation
													r.summary = "Get trace comment"
													r.operationID = "getTraceComment"
													r.operationGroup = ""
													r.pathPattern = "/v1/private/traces/{traceId}/comments/{commentId}"
													r.args = args
													r.count = 2
													return r, true
												default:
													return
												}
											}

										}

									case 'f': // Prefix: "feedback-scores"

										if l := len("feedback-scores"); len(elem) >= l && elem[0:l] == "feedback-scores" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch method {
											case "PUT":
												r.name = AddTraceFeedbackScoreOperation
												r.summary = "Add trace feedback score"
												r.operationID = "addTraceFeedbackScore"
												r.operationGroup = ""
												r.pathPattern = "/v1/private/traces/{id}/feedback-scores"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}
										switch elem[0] {
										case '/': // Prefix: "/delete"

											if l := len("/delete"); len(elem) >= l && elem[0:l] == "/delete" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch method {
												case "POST":
													r.name = DeleteTraceFeedbackScoreOperation
													r.summary = "Delete trace feedback score"
													r.operationID = "deleteTraceFeedbackScore"
													r.operationGroup = ""
													r.pathPattern = "/v1/private/traces/{id}/feedback-scores/delete"
													r.args = args
													r.count = 1
													return r, true
												default:
													return
												}
											}

										}

									}

								}

							}

						}

					case 'w': // Prefix: "w"

						if l := len("w"); len(elem) >= l && elem[0:l] == "w" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'e': // Prefix: "elcome-wizard"

							if l := len("elcome-wizard"); len(elem) >= l && elem[0:l] == "elcome-wizard" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "GET":
									r.name = GetWelcomeWizardStatusOperation
									r.summary = "Get welcome wizard tracking status"
									r.operationID = "getWelcomeWizardStatus"
									r.operationGroup = ""
									r.pathPattern = "/v1/private/welcome-wizard"
									r.args = args
									r.count = 0
									return r, true
								case "POST":
									r.name = SubmitWelcomeWizardOperation
									r.summary = "Submit welcome wizard"
									r.operationID = "submitWelcomeWizard"
									r.operationGroup = ""
									r.pathPattern = "/v1/private/welcome-wizard"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}

						case 'o': // Prefix: "orkspaces/"

							if l := len("orkspaces/"); len(elem) >= l && elem[0:l] == "orkspaces/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'c': // Prefix: "co"

								if l := len("co"); len(elem) >= l && elem[0:l] == "co" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'n': // Prefix: "nfigurations"

									if l := len("nfigurations"); len(elem) >= l && elem[0:l] == "nfigurations" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "DELETE":
											r.name = DeleteWorkspaceConfigurationOperation
											r.summary = "Delete workspace configuration"
											r.operationID = "deleteWorkspaceConfiguration"
											r.operationGroup = ""
											r.pathPattern = "/v1/private/workspaces/configurations"
											r.args = args
											r.count = 0
											return r, true
										case "GET":
											r.name = GetWorkspaceConfigurationOperation
											r.summary = "Get workspace configuration"
											r.operationID = "getWorkspaceConfiguration"
											r.operationGroup = ""
											r.pathPattern = "/v1/private/workspaces/configurations"
											r.args = args
											r.count = 0
											return r, true
										case "PUT":
											r.name = UpsertWorkspaceConfigurationOperation
											r.summary = "Upsert workspace configuration"
											r.operationID = "upsertWorkspaceConfiguration"
											r.operationGroup = ""
											r.pathPattern = "/v1/private/workspaces/configurations"
											r.args = args
											r.count = 0
											return r, true
										default:
											return
										}
									}

								case 's': // Prefix: "sts"

									if l := len("sts"); len(elem) >= l && elem[0:l] == "sts" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "POST":
											r.name = GetCostOperation
											r.summary = "Get cost daily data"
											r.operationID = "getCost"
											r.operationGroup = ""
											r.pathPattern = "/v1/private/workspaces/costs"
											r.args = args
											r.count = 0
											return r, true
										default:
											return
										}
									}
									switch elem[0] {
									case '/': // Prefix: "/summaries"

										if l := len("/summaries"); len(elem) >= l && elem[0:l] == "/summaries" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch method {
											case "POST":
												r.name = CostsSummaryOperation
												r.summary = "Get costs summary"
												r.operationID = "costsSummary"
												r.operationGroup = ""
												r.pathPattern = "/v1/private/workspaces/costs/summaries"
												r.args = args
												r.count = 0
												return r, true
											default:
												return
											}
										}

									}

								}

							case 'm': // Prefix: "metrics"

								if l := len("metrics"); len(elem) >= l && elem[0:l] == "metrics" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "POST":
										r.name = GetMetricOperation
										r.summary = "Get metric daily data"
										r.operationID = "getMetric"
										r.operationGroup = ""
										r.pathPattern = "/v1/private/workspaces/metrics"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}
								switch elem[0] {
								case '/': // Prefix: "/summaries"

									if l := len("/summaries"); len(elem) >= l && elem[0:l] == "/summaries" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "POST":
											r.name = MetricsSummaryOperation
											r.summary = "Get metrics summary"
											r.operationID = "metricsSummary"
											r.operationGroup = ""
											r.pathPattern = "/v1/private/workspaces/metrics/summaries"
											r.args = args
											r.count = 0
											return r, true
										default:
											return
										}
									}

								}

							}

						}

					}

				}

			}

		}
	}
	return r, false
}
