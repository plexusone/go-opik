// Code generated by ogen, DO NOT EDIT.

package api

import (
	"github.com/ogen-go/ogen/validate"
)

// validateUniqueColumnCompare checks for duplicate items using hash-based detection.
func validateUniqueColumnCompare(items []ColumnCompare) (err error) {
	if len(items) <= 1 {
		return nil
	}

	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(*validate.DepthLimitError); ok {
				err = e
			} else {
				panic(r)
			}
		}
	}()

	type entry struct {
		item  ColumnCompare
		index int
	}
	buckets := make(map[uint64][]entry, len(items))

	for i, item := range items {
		hash := item.Hash()
		bucket := buckets[hash]

		for _, existing := range bucket {
			if item.Equal(existing.item, 0) {
				return &validate.DuplicateItemsError{
					Indices: []int{existing.index, i},
				}
			}
		}

		buckets[hash] = append(bucket, entry{item: item, index: i})
	}

	return nil
}

// validateUniqueColumnPublic checks for duplicate items using hash-based detection.
func validateUniqueColumnPublic(items []ColumnPublic) (err error) {
	if len(items) <= 1 {
		return nil
	}

	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(*validate.DepthLimitError); ok {
				err = e
			} else {
				panic(r)
			}
		}
	}()

	type entry struct {
		item  ColumnPublic
		index int
	}
	buckets := make(map[uint64][]entry, len(items))

	for i, item := range items {
		hash := item.Hash()
		bucket := buckets[hash]

		for _, existing := range bucket {
			if item.Equal(existing.item, 0) {
				return &validate.DuplicateItemsError{
					Indices: []int{existing.index, i},
				}
			}
		}

		buckets[hash] = append(bucket, entry{item: item, index: i})
	}

	return nil
}

// validateUniqueExperimentItem checks for duplicate items using hash-based detection.
func validateUniqueExperimentItem(items []ExperimentItem) (err error) {
	if len(items) <= 1 {
		return nil
	}

	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(*validate.DepthLimitError); ok {
				err = e
			} else {
				panic(r)
			}
		}
	}()

	type entry struct {
		item  ExperimentItem
		index int
	}
	buckets := make(map[uint64][]entry, len(items))

	for i, item := range items {
		hash := item.Hash()
		bucket := buckets[hash]

		for _, existing := range bucket {
			if item.Equal(existing.item, 0) {
				return &validate.DuplicateItemsError{
					Indices: []int{existing.index, i},
				}
			}
		}

		buckets[hash] = append(bucket, entry{item: item, index: i})
	}

	return nil
}

// validateUniqueFeedbackScore checks for duplicate items using hash-based detection.
func validateUniqueFeedbackScore(items []FeedbackScore) (err error) {
	if len(items) <= 1 {
		return nil
	}

	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(*validate.DepthLimitError); ok {
				err = e
			} else {
				panic(r)
			}
		}
	}()

	type entry struct {
		item  FeedbackScore
		index int
	}
	buckets := make(map[uint64][]entry, len(items))

	for i, item := range items {
		hash := item.Hash()
		bucket := buckets[hash]

		for _, existing := range bucket {
			if item.Equal(existing.item, 0) {
				return &validate.DuplicateItemsError{
					Indices: []int{existing.index, i},
				}
			}
		}

		buckets[hash] = append(bucket, entry{item: item, index: i})
	}

	return nil
}

// validateUniqueComment checks for duplicate items using hash-based detection.
func validateUniqueComment(items []Comment) (err error) {
	if len(items) <= 1 {
		return nil
	}

	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(*validate.DepthLimitError); ok {
				err = e
			} else {
				panic(r)
			}
		}
	}()

	type entry struct {
		item  Comment
		index int
	}
	buckets := make(map[uint64][]entry, len(items))

	for i, item := range items {
		hash := item.Hash()
		bucket := buckets[hash]

		for _, existing := range bucket {
			if item.Equal(existing.item, 0) {
				return &validate.DuplicateItemsError{
					Indices: []int{existing.index, i},
				}
			}
		}

		buckets[hash] = append(bucket, entry{item: item, index: i})
	}

	return nil
}

// validateUniqueAnnotationQueueWrite checks for duplicate items using hash-based detection.
func validateUniqueAnnotationQueueWrite(items []AnnotationQueueWrite) (err error) {
	if len(items) <= 1 {
		return nil
	}

	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(*validate.DepthLimitError); ok {
				err = e
			} else {
				panic(r)
			}
		}
	}()

	type entry struct {
		item  AnnotationQueueWrite
		index int
	}
	buckets := make(map[uint64][]entry, len(items))

	for i, item := range items {
		hash := item.Hash()
		bucket := buckets[hash]

		for _, existing := range bucket {
			if item.Equal(existing.item, 0) {
				return &validate.DuplicateItemsError{
					Indices: []int{existing.index, i},
				}
			}
		}

		buckets[hash] = append(bucket, entry{item: item, index: i})
	}

	return nil
}
