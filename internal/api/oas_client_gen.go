// Code generated by ogen, DO NOT EDIT.

package api

import (
	"context"
	"net/url"
	"strings"
	"time"

	"github.com/go-faster/errors"
	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/otelogen"
	"github.com/ogen-go/ogen/uri"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/metric"
	semconv "go.opentelemetry.io/otel/semconv/v1.37.0"
	"go.opentelemetry.io/otel/trace"
)

func trimTrailingSlashes(u *url.URL) {
	u.Path = strings.TrimRight(u.Path, "/")
	u.RawPath = strings.TrimRight(u.RawPath, "/")
}

// Invoker invokes operations described by OpenAPI v3 specification.
type Invoker interface {
	// AddItemsToAnnotationQueue invokes addItemsToAnnotationQueue operation.
	//
	// Add traces or threads to annotation queue.
	//
	// POST /v1/private/annotation-queues/{id}/items/add
	AddItemsToAnnotationQueue(ctx context.Context, request OptAnnotationQueueItemIds, params AddItemsToAnnotationQueueParams) (AddItemsToAnnotationQueueRes, error)
	// AddSpanComment invokes addSpanComment operation.
	//
	// Add span comment.
	//
	// POST /v1/private/spans/{id}/comments
	AddSpanComment(ctx context.Context, request OptComment, params AddSpanCommentParams) (*AddSpanCommentCreated, error)
	// AddSpanFeedbackScore invokes addSpanFeedbackScore operation.
	//
	// Add span feedback score.
	//
	// PUT /v1/private/spans/{id}/feedback-scores
	AddSpanFeedbackScore(ctx context.Context, request OptFeedbackScore, params AddSpanFeedbackScoreParams) error
	// AddThreadComment invokes addThreadComment operation.
	//
	// Add thread comment.
	//
	// POST /v1/private/traces/threads/{id}/comments
	AddThreadComment(ctx context.Context, request OptComment, params AddThreadCommentParams) (*AddThreadCommentCreated, error)
	// AddTraceComment invokes addTraceComment operation.
	//
	// Add trace comment.
	//
	// POST /v1/private/traces/{id}/comments
	AddTraceComment(ctx context.Context, request OptComment, params AddTraceCommentParams) (*AddTraceCommentCreated, error)
	// AddTraceFeedbackScore invokes addTraceFeedbackScore operation.
	//
	// Add trace feedback score.
	//
	// PUT /v1/private/traces/{id}/feedback-scores
	AddTraceFeedbackScore(ctx context.Context, request OptFeedbackScore, params AddTraceFeedbackScoreParams) error
	// AttachmentList invokes attachmentList operation.
	//
	// Attachments list for entity.
	//
	// GET /v1/private/attachment/list
	AttachmentList(ctx context.Context, params AttachmentListParams) (AttachmentListRes, error)
	// BatchUpdateDatasetItems invokes batchUpdateDatasetItems operation.
	//
	// Update multiple dataset items.
	//
	// PATCH /v1/private/datasets/items/batch
	BatchUpdateDatasetItems(ctx context.Context, request OptDatasetItemBatchUpdate) (BatchUpdateDatasetItemsRes, error)
	// BatchUpdateSpans invokes batchUpdateSpans operation.
	//
	// Update multiple spans.
	//
	// PATCH /v1/private/spans/batch
	BatchUpdateSpans(ctx context.Context, request OptSpanBatchUpdate) (BatchUpdateSpansRes, error)
	// BatchUpdateThreads invokes batchUpdateThreads operation.
	//
	// Update multiple threads.
	//
	// PATCH /v1/private/traces/threads/batch
	BatchUpdateThreads(ctx context.Context, request OptTraceThreadBatchUpdate) (BatchUpdateThreadsRes, error)
	// BatchUpdateTraces invokes batchUpdateTraces operation.
	//
	// Update multiple traces.
	//
	// PATCH /v1/private/traces/batch
	BatchUpdateTraces(ctx context.Context, request OptTraceBatchUpdate) (BatchUpdateTracesRes, error)
	// CancelStudioOptimizations invokes cancelStudioOptimizations operation.
	//
	// Cancel Studio optimizations by id.
	//
	// GET /v1/private/optimizations/studio/{id}/cancel
	CancelStudioOptimizations(ctx context.Context, params CancelStudioOptimizationsParams) error
	// CheckAccess invokes checkAccess operation.
	//
	// Check user access to workspace.
	//
	// POST /v1/private/auth
	CheckAccess(ctx context.Context, request *AuthDetailsHolder) (CheckAccessRes, error)
	// CloseTraceThread invokes closeTraceThread operation.
	//
	// Close one or multiple trace threads. Supports both single thread_id and multiple thread_ids for
	// batch operations.
	//
	// PUT /v1/private/traces/threads/close
	CloseTraceThread(ctx context.Context, request OptTraceThreadBatchIdentifier) (CloseTraceThreadRes, error)
	// CompareDatasetVersions invokes compareDatasetVersions operation.
	//
	// Compare the latest committed dataset version with the current draft state. This endpoint provides
	// insights into changes made since the last version was committed. The comparison calculates
	// additions, modifications, deletions, and unchanged items between the latest version snapshot and
	// current draft.
	//
	// GET /v1/private/datasets/{id}/versions/diff
	CompareDatasetVersions(ctx context.Context, params CompareDatasetVersionsParams) (CompareDatasetVersionsRes, error)
	// CompleteMultiPartUpload invokes completeMultiPartUpload operation.
	//
	// Complete multipart attachment upload.
	//
	// POST /v1/private/attachment/upload-complete
	CompleteMultiPartUpload(ctx context.Context, request OptCompleteMultipartUploadRequest) (CompleteMultiPartUploadRes, error)
	// CostsSummary invokes costsSummary operation.
	//
	// Get costs summary.
	//
	// POST /v1/private/workspaces/costs/summaries
	CostsSummary(ctx context.Context, request OptWorkspaceMetricsSummaryRequest) (CostsSummaryRes, error)
	// CreateAlert invokes createAlert operation.
	//
	// Create alert.
	//
	// POST /v1/private/alerts
	CreateAlert(ctx context.Context, request OptAlertWrite) (CreateAlertRes, error)
	// CreateAnnotationQueue invokes createAnnotationQueue operation.
	//
	// Create annotation queue for human annotation workflows.
	//
	// POST /v1/private/annotation-queues
	CreateAnnotationQueue(ctx context.Context, request OptAnnotationQueueWrite) (CreateAnnotationQueueRes, error)
	// CreateAnnotationQueueBatch invokes createAnnotationQueueBatch operation.
	//
	// Create multiple annotation queues for human annotation workflows.
	//
	// POST /v1/private/annotation-queues/batch
	CreateAnnotationQueueBatch(ctx context.Context, request OptAnnotationQueueBatchWrite) (CreateAnnotationQueueBatchRes, error)
	// CreateAutomationRuleEvaluator invokes createAutomationRuleEvaluator operation.
	//
	// Create automation rule evaluator.
	//
	// POST /v1/private/automations/evaluators
	CreateAutomationRuleEvaluator(ctx context.Context, request OptAutomationRuleEvaluatorWrite) (*CreateAutomationRuleEvaluatorCreated, error)
	// CreateChatCompletions invokes createChatCompletions operation.
	//
	// Create chat completions.
	//
	// POST /v1/private/chat/completions
	CreateChatCompletions(ctx context.Context, request OptChatCompletionRequest) (*ChatCompletionResponse, error)
	// CreateDashboard invokes createDashboard operation.
	//
	// Create a new dashboard in a workspace.
	//
	// POST /v1/private/dashboards
	CreateDashboard(ctx context.Context, request OptDashboardWrite) (*DashboardPublicHeaders, error)
	// CreateDataset invokes createDataset operation.
	//
	// Create dataset.
	//
	// POST /v1/private/datasets
	CreateDataset(ctx context.Context, request OptDatasetWrite) (*CreateDatasetCreated, error)
	// CreateDatasetItemsFromCsv invokes createDatasetItemsFromCsv operation.
	//
	// Create dataset items from uploaded CSV file. CSV should have headers in the first row. Processing
	// happens asynchronously in batches.
	//
	// POST /v1/private/datasets/items/from-csv
	CreateDatasetItemsFromCsv(ctx context.Context, request OptCreateDatasetItemsFromCsvReq) (CreateDatasetItemsFromCsvRes, error)
	// CreateDatasetItemsFromSpans invokes createDatasetItemsFromSpans operation.
	//
	// Create dataset items from spans with enriched metadata.
	//
	// POST /v1/private/datasets/{dataset_id}/items/from-spans
	CreateDatasetItemsFromSpans(ctx context.Context, request OptCreateDatasetItemsFromSpansRequest, params CreateDatasetItemsFromSpansParams) error
	// CreateDatasetItemsFromTraces invokes createDatasetItemsFromTraces operation.
	//
	// Create dataset items from traces with enriched metadata.
	//
	// POST /v1/private/datasets/{dataset_id}/items/from-traces
	CreateDatasetItemsFromTraces(ctx context.Context, request OptCreateDatasetItemsFromTracesRequest, params CreateDatasetItemsFromTracesParams) error
	// CreateDatasetVersion invokes createDatasetVersion operation.
	//
	// Create a new immutable version of the dataset by snapshotting the current state.
	//
	// POST /v1/private/datasets/{id}/versions
	CreateDatasetVersion(ctx context.Context, request OptDatasetVersionCreatePublic, params CreateDatasetVersionParams) (CreateDatasetVersionRes, error)
	// CreateExperiment invokes createExperiment operation.
	//
	// Create experiment.
	//
	// POST /v1/private/experiments
	CreateExperiment(ctx context.Context, request OptExperimentWrite) (*CreateExperimentCreated, error)
	// CreateExperimentItems invokes createExperimentItems operation.
	//
	// Create experiment items.
	//
	// POST /v1/private/experiments/items
	CreateExperimentItems(ctx context.Context, request OptExperimentItemsBatch) error
	// CreateFeedbackDefinition invokes createFeedbackDefinition operation.
	//
	// Get feedback definition.
	//
	// POST /v1/private/feedback-definitions
	CreateFeedbackDefinition(ctx context.Context, request OptFeedbackCreate) (*CreateFeedbackDefinitionCreated, error)
	// CreateGuardrails invokes createGuardrails operation.
	//
	// Batch guardrails for traces.
	//
	// POST /v1/private/guardrails
	CreateGuardrails(ctx context.Context, request OptGuardrailBatchWrite) error
	// CreateOptimization invokes createOptimization operation.
	//
	// Create optimization.
	//
	// POST /v1/private/optimizations
	CreateOptimization(ctx context.Context, request OptOptimizationWrite) (*CreateOptimizationCreated, error)
	// CreateOrUpdateDatasetItems invokes createOrUpdateDatasetItems operation.
	//
	// Create/update dataset items based on dataset item id.
	//
	// PUT /v1/private/datasets/items
	CreateOrUpdateDatasetItems(ctx context.Context, request OptDatasetItemBatchWrite) error
	// CreateProject invokes createProject operation.
	//
	// Create project.
	//
	// POST /v1/private/projects
	CreateProject(ctx context.Context, request OptProjectWrite) (CreateProjectRes, error)
	// CreatePrompt invokes createPrompt operation.
	//
	// Create prompt.
	//
	// POST /v1/private/prompts
	CreatePrompt(ctx context.Context, request OptPromptWrite) (CreatePromptRes, error)
	// CreatePromptVersion invokes createPromptVersion operation.
	//
	// Create prompt version.
	//
	// POST /v1/private/prompts/versions
	CreatePromptVersion(ctx context.Context, request OptCreatePromptVersionDetail) (CreatePromptVersionRes, error)
	// CreateSpan invokes createSpan operation.
	//
	// Create span.
	//
	// POST /v1/private/spans
	CreateSpan(ctx context.Context, request OptSpanWrite) (CreateSpanRes, error)
	// CreateSpans invokes createSpans operation.
	//
	// Create spans.
	//
	// POST /v1/private/spans/batch
	CreateSpans(ctx context.Context, request OptSpanBatchWrite) error
	// CreateTrace invokes createTrace operation.
	//
	// Get trace.
	//
	// POST /v1/private/traces
	CreateTrace(ctx context.Context, request OptTraceWrite) (*CreateTraceCreated, error)
	// CreateTraces invokes createTraces operation.
	//
	// Create traces.
	//
	// POST /v1/private/traces/batch
	CreateTraces(ctx context.Context, request OptTraceBatchWrite) error
	// CreateVersionTag invokes createVersionTag operation.
	//
	// Add a tag to a specific dataset version for easy reference (e.g., 'baseline', 'v1.0', 'production').
	//
	// POST /v1/private/datasets/{id}/versions/hash/{versionHash}/tags
	CreateVersionTag(ctx context.Context, request OptDatasetVersionTag, params CreateVersionTagParams) (CreateVersionTagRes, error)
	// DeleteAlertBatch invokes deleteAlertBatch operation.
	//
	// Delete multiple alerts by their IDs.
	//
	// POST /v1/private/alerts/delete
	DeleteAlertBatch(ctx context.Context, request OptBatchDelete) (DeleteAlertBatchRes, error)
	// DeleteAnnotationQueueBatch invokes deleteAnnotationQueueBatch operation.
	//
	// Delete multiple annotation queues by their IDs.
	//
	// POST /v1/private/annotation-queues/delete
	DeleteAnnotationQueueBatch(ctx context.Context, request OptBatchDelete) (DeleteAnnotationQueueBatchRes, error)
	// DeleteAttachments invokes deleteAttachments operation.
	//
	// Delete attachments.
	//
	// POST /v1/private/attachment/delete
	DeleteAttachments(ctx context.Context, request OptCompleteMultipartUploadRequest) (DeleteAttachmentsRes, error)
	// DeleteAutomationRuleEvaluatorBatch invokes deleteAutomationRuleEvaluatorBatch operation.
	//
	// Delete automation rule evaluators batch.
	//
	// POST /v1/private/automations/evaluators/delete
	DeleteAutomationRuleEvaluatorBatch(ctx context.Context, request OptBatchDelete, params DeleteAutomationRuleEvaluatorBatchParams) error
	// DeleteDashboard invokes deleteDashboard operation.
	//
	// Delete dashboard by id.
	//
	// DELETE /v1/private/dashboards/{dashboardId}
	DeleteDashboard(ctx context.Context, params DeleteDashboardParams) error
	// DeleteDashboardsBatch invokes deleteDashboardsBatch operation.
	//
	// Delete dashboards batch.
	//
	// POST /v1/private/dashboards/delete-batch
	DeleteDashboardsBatch(ctx context.Context, request OptBatchDelete) error
	// DeleteDataset invokes deleteDataset operation.
	//
	// Delete dataset by id.
	//
	// DELETE /v1/private/datasets/{id}
	DeleteDataset(ctx context.Context, params DeleteDatasetParams) error
	// DeleteDatasetByName invokes deleteDatasetByName operation.
	//
	// Delete dataset by name.
	//
	// POST /v1/private/datasets/delete
	DeleteDatasetByName(ctx context.Context, request OptDatasetIdentifier) error
	// DeleteDatasetItems invokes deleteDatasetItems operation.
	//
	// Delete dataset items using one of two modes:
	// 1. **Delete by IDs**: Provide 'item_ids' to delete specific items by their IDs
	// 2. **Delete by filters**: Provide 'dataset_id' with optional 'filters' to delete items matching
	// criteria
	// When using filters, an empty 'filters' array will delete all items in the specified dataset.
	//
	// POST /v1/private/datasets/items/delete
	DeleteDatasetItems(ctx context.Context, request OptDatasetItemsDelete) (DeleteDatasetItemsRes, error)
	// DeleteDatasetsBatch invokes deleteDatasetsBatch operation.
	//
	// Delete datasets batch.
	//
	// POST /v1/private/datasets/delete-batch
	DeleteDatasetsBatch(ctx context.Context, request OptBatchDelete) error
	// DeleteExperimentItems invokes deleteExperimentItems operation.
	//
	// Delete experiment items.
	//
	// POST /v1/private/experiments/items/delete
	DeleteExperimentItems(ctx context.Context, request OptExperimentItemsDelete) error
	// DeleteExperimentsById invokes deleteExperimentsById operation.
	//
	// Delete experiments by id.
	//
	// POST /v1/private/experiments/delete
	DeleteExperimentsById(ctx context.Context, request OptDeleteIdsHolder) error
	// DeleteFeedbackDefinitionById invokes deleteFeedbackDefinitionById operation.
	//
	// Delete feedback definition by id.
	//
	// DELETE /v1/private/feedback-definitions/{id}
	DeleteFeedbackDefinitionById(ctx context.Context, params DeleteFeedbackDefinitionByIdParams) (DeleteFeedbackDefinitionByIdRes, error)
	// DeleteFeedbackDefinitionsBatch invokes deleteFeedbackDefinitionsBatch operation.
	//
	// Delete feedback definitions batch.
	//
	// POST /v1/private/feedback-definitions/delete
	DeleteFeedbackDefinitionsBatch(ctx context.Context, request OptBatchDelete) (DeleteFeedbackDefinitionsBatchRes, error)
	// DeleteLlmProviderApiKeysBatch invokes deleteLlmProviderApiKeysBatch operation.
	//
	// Delete LLM Provider's ApiKeys batch.
	//
	// POST /v1/private/llm-provider-key/delete
	DeleteLlmProviderApiKeysBatch(ctx context.Context, request OptBatchDelete) error
	// DeleteOptimizationsById invokes deleteOptimizationsById operation.
	//
	// Delete optimizations by id.
	//
	// POST /v1/private/optimizations/delete
	DeleteOptimizationsById(ctx context.Context, request OptDeleteIdsHolder) error
	// DeleteProjectById invokes deleteProjectById operation.
	//
	// Delete project by id.
	//
	// DELETE /v1/private/projects/{id}
	DeleteProjectById(ctx context.Context, params DeleteProjectByIdParams) (DeleteProjectByIdRes, error)
	// DeleteProjectsBatch invokes deleteProjectsBatch operation.
	//
	// Delete projects batch.
	//
	// POST /v1/private/projects/delete
	DeleteProjectsBatch(ctx context.Context, request OptBatchDelete) error
	// DeletePrompt invokes deletePrompt operation.
	//
	// Delete prompt.
	//
	// DELETE /v1/private/prompts/{id}
	DeletePrompt(ctx context.Context, params DeletePromptParams) error
	// DeletePromptsBatch invokes deletePromptsBatch operation.
	//
	// Delete prompts batch.
	//
	// POST /v1/private/prompts/delete
	DeletePromptsBatch(ctx context.Context, request OptBatchDelete) error
	// DeleteSpanById invokes deleteSpanById operation.
	//
	// Delete span by id.
	//
	// DELETE /v1/private/spans/{id}
	DeleteSpanById(ctx context.Context, params DeleteSpanByIdParams) (DeleteSpanByIdRes, error)
	// DeleteSpanComments invokes deleteSpanComments operation.
	//
	// Delete span comments.
	//
	// POST /v1/private/spans/comments/delete
	DeleteSpanComments(ctx context.Context, request OptBatchDelete) error
	// DeleteSpanFeedbackScore invokes deleteSpanFeedbackScore operation.
	//
	// Delete span feedback score.
	//
	// POST /v1/private/spans/{id}/feedback-scores/delete
	DeleteSpanFeedbackScore(ctx context.Context, request OptDeleteFeedbackScore, params DeleteSpanFeedbackScoreParams) error
	// DeleteThreadComments invokes deleteThreadComments operation.
	//
	// Delete thread comments.
	//
	// POST /v1/private/traces/threads/comments/delete
	DeleteThreadComments(ctx context.Context, request OptBatchDelete) error
	// DeleteThreadFeedbackScores invokes deleteThreadFeedbackScores operation.
	//
	// Delete thread feedback scores.
	//
	// POST /v1/private/traces/threads/feedback-scores/delete
	DeleteThreadFeedbackScores(ctx context.Context, request OptDeleteThreadFeedbackScores) error
	// DeleteTraceById invokes deleteTraceById operation.
	//
	// Delete trace by id.
	//
	// DELETE /v1/private/traces/{id}
	DeleteTraceById(ctx context.Context, params DeleteTraceByIdParams) error
	// DeleteTraceComments invokes deleteTraceComments operation.
	//
	// Delete trace comments.
	//
	// POST /v1/private/traces/comments/delete
	DeleteTraceComments(ctx context.Context, request OptBatchDelete) error
	// DeleteTraceFeedbackScore invokes deleteTraceFeedbackScore operation.
	//
	// Delete trace feedback score.
	//
	// POST /v1/private/traces/{id}/feedback-scores/delete
	DeleteTraceFeedbackScore(ctx context.Context, request OptDeleteFeedbackScore, params DeleteTraceFeedbackScoreParams) error
	// DeleteTraceThreads invokes deleteTraceThreads operation.
	//
	// Delete trace threads.
	//
	// POST /v1/private/traces/threads/delete
	DeleteTraceThreads(ctx context.Context, request OptDeleteTraceThreads) error
	// DeleteTraces invokes deleteTraces operation.
	//
	// Delete traces.
	//
	// POST /v1/private/traces/delete
	DeleteTraces(ctx context.Context, request OptBatchDelete) error
	// DeleteVersionTag invokes deleteVersionTag operation.
	//
	// Remove a tag from a dataset version. The version itself is not deleted, only the tag reference.
	//
	// DELETE /v1/private/datasets/{id}/versions/{versionHash}/tags/{tag}
	DeleteVersionTag(ctx context.Context, params DeleteVersionTagParams) error
	// DeleteWorkspaceConfiguration invokes deleteWorkspaceConfiguration operation.
	//
	// Delete workspace configuration.
	//
	// DELETE /v1/private/workspaces/configurations
	DeleteWorkspaceConfiguration(ctx context.Context) (DeleteWorkspaceConfigurationRes, error)
	// EvaluateSpans invokes evaluateSpans operation.
	//
	// Manually trigger evaluation rules on selected spans. Bypasses sampling and enqueues all specified
	// spans for evaluation.
	//
	// POST /v1/private/manual-evaluation/spans
	EvaluateSpans(ctx context.Context, request OptManualEvaluationRequest) (EvaluateSpansRes, error)
	// EvaluateThreads invokes evaluateThreads operation.
	//
	// Manually trigger evaluation rules on selected threads. Bypasses sampling and enqueues all
	// specified threads for evaluation.
	//
	// POST /v1/private/manual-evaluation/threads
	EvaluateThreads(ctx context.Context, request OptManualEvaluationRequest) (EvaluateThreadsRes, error)
	// EvaluateTraces invokes evaluateTraces operation.
	//
	// Manually trigger evaluation rules on selected traces. Bypasses sampling and enqueues all specified
	// traces for evaluation.
	//
	// POST /v1/private/manual-evaluation/traces
	EvaluateTraces(ctx context.Context, request OptManualEvaluationRequest) (EvaluateTracesRes, error)
	// ExpandDataset invokes expandDataset operation.
	//
	// Generate synthetic dataset samples using LLM based on existing data patterns.
	//
	// POST /v1/private/datasets/{id}/expansions
	ExpandDataset(ctx context.Context, request OptDatasetExpansionWrite, params ExpandDatasetParams) (*DatasetExpansionResponse, error)
	// ExperimentItemsBulk invokes experimentItemsBulk operation.
	//
	// Record experiment items in bulk with traces, spans, and feedback scores. Maximum request size is
	// 4MB.
	//
	// PUT /v1/private/experiments/items/bulk
	ExperimentItemsBulk(ctx context.Context, request OptExperimentItemBulkUploadExperimentItemBulkWriteView) (ExperimentItemsBulkRes, error)
	// FindAlerts invokes findAlerts operation.
	//
	// Find alerts.
	//
	// GET /v1/private/alerts
	FindAlerts(ctx context.Context, params FindAlertsParams) (*AlertPagePublic, error)
	// FindAnnotationQueues invokes findAnnotationQueues operation.
	//
	// Find annotation queues with filtering and sorting.
	//
	// GET /v1/private/annotation-queues
	FindAnnotationQueues(ctx context.Context, params FindAnnotationQueuesParams) (*AnnotationQueuePagePublic, error)
	// FindDashboards invokes findDashboards operation.
	//
	// Find dashboards in a workspace.
	//
	// GET /v1/private/dashboards
	FindDashboards(ctx context.Context, params FindDashboardsParams) (*DashboardPagePublic, error)
	// FindDatasetItemsWithExperimentItems invokes findDatasetItemsWithExperimentItems operation.
	//
	// Find dataset items with experiment items.
	//
	// GET /v1/private/datasets/{id}/items/experiments/items
	FindDatasetItemsWithExperimentItems(ctx context.Context, params FindDatasetItemsWithExperimentItemsParams) (*DatasetItemPageCompare, error)
	// FindDatasets invokes findDatasets operation.
	//
	// Find datasets.
	//
	// GET /v1/private/datasets
	FindDatasets(ctx context.Context, params FindDatasetsParams) (*DatasetPagePublic, error)
	// FindEvaluators invokes findEvaluators operation.
	//
	// Find project Evaluators.
	//
	// GET /v1/private/automations/evaluators
	FindEvaluators(ctx context.Context, params FindEvaluatorsParams) (*AutomationRuleEvaluatorPagePublic, error)
	// FindExperimentGroups invokes findExperimentGroups operation.
	//
	// Find experiments grouped by specified fields.
	//
	// GET /v1/private/experiments/groups
	FindExperimentGroups(ctx context.Context, params FindExperimentGroupsParams) (FindExperimentGroupsRes, error)
	// FindExperimentGroupsAggregations invokes findExperimentGroupsAggregations operation.
	//
	// Find experiments grouped by specified fields with aggregation metrics.
	//
	// GET /v1/private/experiments/groups/aggregations
	FindExperimentGroupsAggregations(ctx context.Context, params FindExperimentGroupsAggregationsParams) (FindExperimentGroupsAggregationsRes, error)
	// FindExperiments invokes findExperiments operation.
	//
	// Find experiments.
	//
	// GET /v1/private/experiments
	FindExperiments(ctx context.Context, params FindExperimentsParams) (FindExperimentsRes, error)
	// FindFeedbackDefinitions invokes findFeedbackDefinitions operation.
	//
	// Find Feedback definitions.
	//
	// GET /v1/private/feedback-definitions
	FindFeedbackDefinitions(ctx context.Context, params FindFeedbackDefinitionsParams) (*FeedbackDefinitionPagePublic, error)
	// FindFeedbackScoreNames invokes findFeedbackScoreNames operation.
	//
	// Find Feedback Score names.
	//
	// GET /v1/private/experiments/feedback-scores/names
	FindFeedbackScoreNames(ctx context.Context, params FindFeedbackScoreNamesParams) ([]string, error)
	// FindFeedbackScoreNames1 invokes findFeedbackScoreNames_1 operation.
	//
	// Find Feedback Score names.
	//
	// GET /v1/private/spans/feedback-scores/names
	FindFeedbackScoreNames1(ctx context.Context, params FindFeedbackScoreNames1Params) ([]string, error)
	// FindFeedbackScoreNames2 invokes findFeedbackScoreNames_2 operation.
	//
	// Find Feedback Score names.
	//
	// GET /v1/private/traces/feedback-scores/names
	FindFeedbackScoreNames2(ctx context.Context, params FindFeedbackScoreNames2Params) ([]string, error)
	// FindFeedbackScoreNamesByProjectIds invokes findFeedbackScoreNamesByProjectIds operation.
	//
	// Find Feedback Score names By Project Ids.
	//
	// GET /v1/private/projects/feedback-scores/names
	FindFeedbackScoreNamesByProjectIds(ctx context.Context, params FindFeedbackScoreNamesByProjectIdsParams) (*FeedbackScoreNames, error)
	// FindLlmProviderKeys invokes findLlmProviderKeys operation.
	//
	// Find LLM Provider's ApiKeys.
	//
	// GET /v1/private/llm-provider-key
	FindLlmProviderKeys(ctx context.Context) (*ProviderApiKeyPagePublic, error)
	// FindOptimizations invokes findOptimizations operation.
	//
	// Find optimizations.
	//
	// GET /v1/private/optimizations
	FindOptimizations(ctx context.Context, params FindOptimizationsParams) (FindOptimizationsRes, error)
	// FindProjects invokes findProjects operation.
	//
	// Find projects.
	//
	// GET /v1/private/projects
	FindProjects(ctx context.Context, params FindProjectsParams) (*ProjectPagePublic, error)
	// FindStudioOptimizations invokes findStudioOptimizations operation.
	//
	// Find Studio optimizations.
	//
	// GET /v1/private/optimizations/studio
	FindStudioOptimizations(ctx context.Context, params FindStudioOptimizationsParams) (FindStudioOptimizationsRes, error)
	// FindTraceThreadsFeedbackScoreNames invokes findTraceThreadsFeedbackScoreNames operation.
	//
	// Find Trace Threads Feedback Score names.
	//
	// GET /v1/private/traces/threads/feedback-scores/names
	FindTraceThreadsFeedbackScoreNames(ctx context.Context, params FindTraceThreadsFeedbackScoreNamesParams) ([]string, error)
	// FinishExperiments invokes finishExperiments operation.
	//
	// Finish experiments and trigger alert events.
	//
	// POST /v1/private/experiments/finish
	FinishExperiments(ctx context.Context, request OptDeleteIdsHolder) (FinishExperimentsRes, error)
	// GetAlertById invokes getAlertById operation.
	//
	// Get Alert by id.
	//
	// GET /v1/private/alerts/{id}
	GetAlertById(ctx context.Context, params GetAlertByIdParams) (GetAlertByIdRes, error)
	// GetAnnotationQueueById invokes getAnnotationQueueById operation.
	//
	// Get annotation queue by id.
	//
	// GET /v1/private/annotation-queues/{id}
	GetAnnotationQueueById(ctx context.Context, params GetAnnotationQueueByIdParams) (GetAnnotationQueueByIdRes, error)
	// GetCost invokes getCost operation.
	//
	// Get cost daily data.
	//
	// POST /v1/private/workspaces/costs
	GetCost(ctx context.Context, request OptWorkspaceMetricsSummaryRequest) (GetCostRes, error)
	// GetDashboardById invokes getDashboardById operation.
	//
	// Get dashboard by id.
	//
	// GET /v1/private/dashboards/{dashboardId}
	GetDashboardById(ctx context.Context, params GetDashboardByIdParams) (GetDashboardByIdRes, error)
	// GetDatasetBiInfo invokes getDatasetBiInfo operation.
	//
	// Get datasets information for BI events per user per workspace.
	//
	// GET /v1/internal/usage/bi-datasets
	GetDatasetBiInfo(ctx context.Context) (*BiInformationResponse, error)
	// GetDatasetById invokes getDatasetById operation.
	//
	// Get dataset by id.
	//
	// GET /v1/private/datasets/{id}
	GetDatasetById(ctx context.Context, params GetDatasetByIdParams) (*DatasetPublic, error)
	// GetDatasetByIdentifier invokes getDatasetByIdentifier operation.
	//
	// Get dataset by name.
	//
	// POST /v1/private/datasets/retrieve
	GetDatasetByIdentifier(ctx context.Context, request OptDatasetIdentifierPublic) (*DatasetPublic, error)
	// GetDatasetExperimentItemsStats invokes getDatasetExperimentItemsStats operation.
	//
	// Get experiment items stats for dataset.
	//
	// GET /v1/private/datasets/{id}/items/experiments/items/stats
	GetDatasetExperimentItemsStats(ctx context.Context, params GetDatasetExperimentItemsStatsParams) (*ProjectStatsPublic, error)
	// GetDatasetItemById invokes getDatasetItemById operation.
	//
	// Get dataset item by id.
	//
	// GET /v1/private/datasets/items/{itemId}
	GetDatasetItemById(ctx context.Context, params GetDatasetItemByIdParams) (*DatasetItemPublic, error)
	// GetDatasetItems invokes getDatasetItems operation.
	//
	// Get dataset items.
	//
	// GET /v1/private/datasets/{id}/items
	GetDatasetItems(ctx context.Context, params GetDatasetItemsParams) (*DatasetItemPagePublic, error)
	// GetDatasetItemsOutputColumns invokes getDatasetItemsOutputColumns operation.
	//
	// Get dataset items output columns.
	//
	// GET /v1/private/datasets/{id}/items/experiments/items/output/columns
	GetDatasetItemsOutputColumns(ctx context.Context, params GetDatasetItemsOutputColumnsParams) (*PageColumns, error)
	// GetEvaluatorById invokes getEvaluatorById operation.
	//
	// Get automation rule by id.
	//
	// GET /v1/private/automations/evaluators/{id}
	GetEvaluatorById(ctx context.Context, params GetEvaluatorByIdParams) (*AutomationRuleEvaluatorPublic, error)
	// GetEvaluatorLogsById invokes getEvaluatorLogsById operation.
	//
	// Get automation rule evaluator logs by id.
	//
	// GET /v1/private/automations/evaluators/{id}/logs
	GetEvaluatorLogsById(ctx context.Context, params GetEvaluatorLogsByIdParams) (*LogPage, error)
	// GetExperimentBiInfo invokes getExperimentBiInfo operation.
	//
	// Get experiments information for BI events per user per workspace.
	//
	// GET /v1/internal/usage/bi-experiments
	GetExperimentBiInfo(ctx context.Context) (*BiInformationResponse, error)
	// GetExperimentById invokes getExperimentById operation.
	//
	// Get experiment by id.
	//
	// GET /v1/private/experiments/{id}
	GetExperimentById(ctx context.Context, params GetExperimentByIdParams) (GetExperimentByIdRes, error)
	// GetExperimentItemById invokes getExperimentItemById operation.
	//
	// Get experiment item by id.
	//
	// GET /v1/private/experiments/items/{id}
	GetExperimentItemById(ctx context.Context, params GetExperimentItemByIdParams) (GetExperimentItemByIdRes, error)
	// GetFeedbackDefinitionById invokes getFeedbackDefinitionById operation.
	//
	// Get feedback definition by id.
	//
	// GET /v1/private/feedback-definitions/{id}
	GetFeedbackDefinitionById(ctx context.Context, params GetFeedbackDefinitionByIdParams) (*FeedbackPublic, error)
	// GetLlmProviderApiKeyById invokes getLlmProviderApiKeyById operation.
	//
	// Get LLM Provider's ApiKey by id.
	//
	// GET /v1/private/llm-provider-key/{id}
	GetLlmProviderApiKeyById(ctx context.Context, params GetLlmProviderApiKeyByIdParams) (GetLlmProviderApiKeyByIdRes, error)
	// GetMetric invokes getMetric operation.
	//
	// Get metric daily data.
	//
	// Deprecated: schema marks this operation as deprecated.
	//
	// POST /v1/private/workspaces/metrics
	GetMetric(ctx context.Context, request OptWorkspaceMetricsSummaryRequest) (GetMetricRes, error)
	// GetOptimizationById invokes getOptimizationById operation.
	//
	// Get optimization by id.
	//
	// GET /v1/private/optimizations/{id}
	GetOptimizationById(ctx context.Context, params GetOptimizationByIdParams) (GetOptimizationByIdRes, error)
	// GetProjectById invokes getProjectById operation.
	//
	// Get project by id.
	//
	// GET /v1/private/projects/{id}
	GetProjectById(ctx context.Context, params GetProjectByIdParams) (*ProjectPublic, error)
	// GetProjectMetrics invokes getProjectMetrics operation.
	//
	// Gets specified metrics for a project.
	//
	// POST /v1/private/projects/{id}/metrics
	GetProjectMetrics(ctx context.Context, request OptProjectMetricRequestPublic, params GetProjectMetricsParams) (GetProjectMetricsRes, error)
	// GetProjectStats invokes getProjectStats operation.
	//
	// Get Project Stats.
	//
	// GET /v1/private/projects/stats
	GetProjectStats(ctx context.Context, params GetProjectStatsParams) (*ProjectStatsSummary, error)
	// GetPromptById invokes getPromptById operation.
	//
	// Get prompt by id.
	//
	// GET /v1/private/prompts/{id}
	GetPromptById(ctx context.Context, params GetPromptByIdParams) (GetPromptByIdRes, error)
	// GetPromptVersionById invokes getPromptVersionById operation.
	//
	// Get prompt version by id.
	//
	// GET /v1/private/prompts/versions/{versionId}
	GetPromptVersionById(ctx context.Context, params GetPromptVersionByIdParams) (GetPromptVersionByIdRes, error)
	// GetPromptVersions invokes getPromptVersions operation.
	//
	// Get prompt versions.
	//
	// GET /v1/private/prompts/{id}/versions
	GetPromptVersions(ctx context.Context, params GetPromptVersionsParams) (*PromptVersionPagePublic, error)
	// GetPrompts invokes getPrompts operation.
	//
	// Get prompts.
	//
	// GET /v1/private/prompts
	GetPrompts(ctx context.Context, params GetPromptsParams) (*PromptPagePublic, error)
	// GetServiceToggles invokes getServiceToggles operation.
	//
	// Get Service Toggles.
	//
	// GET /v1/private/toggles
	GetServiceToggles(ctx context.Context) (*ServiceTogglesConfig, error)
	// GetSpanById invokes getSpanById operation.
	//
	// Get span by id.
	//
	// GET /v1/private/spans/{id}
	GetSpanById(ctx context.Context, params GetSpanByIdParams) (GetSpanByIdRes, error)
	// GetSpanComment invokes getSpanComment operation.
	//
	// Get span comment.
	//
	// GET /v1/private/spans/{spanId}/comments/{commentId}
	GetSpanComment(ctx context.Context, params GetSpanCommentParams) (GetSpanCommentRes, error)
	// GetSpanStats invokes getSpanStats operation.
	//
	// Get span stats.
	//
	// GET /v1/private/spans/stats
	GetSpanStats(ctx context.Context, params GetSpanStatsParams) (*ProjectStatsPublic, error)
	// GetSpansBiInfo invokes getSpansBiInfo operation.
	//
	// Get spans information for BI events per user per workspace.
	//
	// GET /v1/internal/usage/bi-spans
	GetSpansBiInfo(ctx context.Context) (*BiInformationResponse, error)
	// GetSpansByProject invokes getSpansByProject operation.
	//
	// Get spans by project_name or project_id and optionally by trace_id and/or type.
	//
	// GET /v1/private/spans
	GetSpansByProject(ctx context.Context, params GetSpansByProjectParams) (*SpanPagePublic, error)
	// GetSpansCountForWorkspaces invokes getSpansCountForWorkspaces operation.
	//
	// Get spans count on previous day for all available workspaces.
	//
	// GET /v1/internal/usage/workspace-span-counts
	GetSpansCountForWorkspaces(ctx context.Context) (*SpansCountResponse, error)
	// GetStudioOptimizationById invokes getStudioOptimizationById operation.
	//
	// Get Studio optimization with config included.
	//
	// GET /v1/private/optimizations/studio/{id}
	GetStudioOptimizationById(ctx context.Context, params GetStudioOptimizationByIdParams) (GetStudioOptimizationByIdRes, error)
	// GetStudioOptimizationLogs invokes getStudioOptimizationLogs operation.
	//
	// Get presigned S3 URL for downloading optimization logs.
	//
	// GET /v1/private/optimizations/studio/{id}/logs
	GetStudioOptimizationLogs(ctx context.Context, params GetStudioOptimizationLogsParams) (GetStudioOptimizationLogsRes, error)
	// GetThreadComment invokes getThreadComment operation.
	//
	// Get thread comment.
	//
	// GET /v1/private/traces/threads/{threadId}/comments/{commentId}
	GetThreadComment(ctx context.Context, params GetThreadCommentParams) (GetThreadCommentRes, error)
	// GetTraceById invokes getTraceById operation.
	//
	// Get trace by id.
	//
	// GET /v1/private/traces/{id}
	GetTraceById(ctx context.Context, params GetTraceByIdParams) (*TracePublic, error)
	// GetTraceComment invokes getTraceComment operation.
	//
	// Get trace comment.
	//
	// GET /v1/private/traces/{traceId}/comments/{commentId}
	GetTraceComment(ctx context.Context, params GetTraceCommentParams) (GetTraceCommentRes, error)
	// GetTraceStats invokes getTraceStats operation.
	//
	// Get trace stats.
	//
	// GET /v1/private/traces/stats
	GetTraceStats(ctx context.Context, params GetTraceStatsParams) (*ProjectStatsPublic, error)
	// GetTraceThread invokes getTraceThread operation.
	//
	// Get trace thread.
	//
	// POST /v1/private/traces/threads/retrieve
	GetTraceThread(ctx context.Context, request OptTraceThreadIdentifier) (GetTraceThreadRes, error)
	// GetTraceThreadStats invokes getTraceThreadStats operation.
	//
	// Get trace thread stats.
	//
	// GET /v1/private/traces/threads/stats
	GetTraceThreadStats(ctx context.Context, params GetTraceThreadStatsParams) (*ProjectStatsPublic, error)
	// GetTraceThreads invokes getTraceThreads operation.
	//
	// Get trace threads.
	//
	// GET /v1/private/traces/threads
	GetTraceThreads(ctx context.Context, params GetTraceThreadsParams) (*TraceThreadPage, error)
	// GetTracesBiInfo invokes getTracesBiInfo operation.
	//
	// Get traces information for BI events per user per workspace.
	//
	// GET /v1/internal/usage/bi-traces
	GetTracesBiInfo(ctx context.Context) (*BiInformationResponse, error)
	// GetTracesByProject invokes getTracesByProject operation.
	//
	// Get traces by project_name or project_id.
	//
	// GET /v1/private/traces
	GetTracesByProject(ctx context.Context, params GetTracesByProjectParams) (*TracePagePublic, error)
	// GetTracesCountForWorkspaces invokes getTracesCountForWorkspaces operation.
	//
	// Get traces count on previous day for all available workspaces.
	//
	// GET /v1/internal/usage/workspace-trace-counts
	GetTracesCountForWorkspaces(ctx context.Context) (*TraceCountResponse, error)
	// GetWebhookExamples invokes getWebhookExamples operation.
	//
	// Get webhook payload examples for all alert event types, optionally filtered by alert type.
	//
	// GET /v1/private/alerts/webhooks/examples
	GetWebhookExamples(ctx context.Context, params GetWebhookExamplesParams) (*WebhookExamples, error)
	// GetWelcomeWizardStatus invokes getWelcomeWizardStatus operation.
	//
	// Get welcome wizard tracking status for the current workspace.
	//
	// GET /v1/private/welcome-wizard
	GetWelcomeWizardStatus(ctx context.Context) (*WelcomeWizardTracking, error)
	// GetWorkspaceConfiguration invokes getWorkspaceConfiguration operation.
	//
	// Get workspace configuration.
	//
	// GET /v1/private/workspaces/configurations
	GetWorkspaceConfiguration(ctx context.Context) (GetWorkspaceConfigurationRes, error)
	// GetWorkspaceName invokes getWorkspaceName operation.
	//
	// User's default workspace name.
	//
	// GET /v1/private/auth/workspace
	GetWorkspaceName(ctx context.Context) (GetWorkspaceNameRes, error)
	// IsAlive invokes isAlive operation.
	//
	// GET /is-alive/ping
	IsAlive(ctx context.Context) (*IsAliveDefStatusCode, error)
	// ListDatasetVersions invokes listDatasetVersions operation.
	//
	// Get paginated list of versions for a dataset, ordered by creation time (newest first).
	//
	// GET /v1/private/datasets/{id}/versions
	ListDatasetVersions(ctx context.Context, params ListDatasetVersionsParams) (ListDatasetVersionsRes, error)
	// MetricsSummary invokes metricsSummary operation.
	//
	// Get metrics summary.
	//
	// Deprecated: schema marks this operation as deprecated.
	//
	// POST /v1/private/workspaces/metrics/summaries
	MetricsSummary(ctx context.Context, request OptWorkspaceMetricsSummaryRequest) (MetricsSummaryRes, error)
	// OpenTraceThread invokes openTraceThread operation.
	//
	// Open trace thread.
	//
	// PUT /v1/private/traces/threads/open
	OpenTraceThread(ctx context.Context, request OptTraceThreadIdentifier) error
	// PatchDatasetItem invokes patchDatasetItem operation.
	//
	// Partially update dataset item by id. Only provided fields will be updated.
	//
	// PATCH /v1/private/datasets/items/{itemId}
	PatchDatasetItem(ctx context.Context, request OptDatasetItemWrite, params PatchDatasetItemParams) (PatchDatasetItemRes, error)
	// RemoveItemsFromAnnotationQueue invokes removeItemsFromAnnotationQueue operation.
	//
	// Remove items from annotation queue.
	//
	// POST /v1/private/annotation-queues/{id}/items/delete
	RemoveItemsFromAnnotationQueue(ctx context.Context, request OptAnnotationQueueItemIds, params RemoveItemsFromAnnotationQueueParams) (RemoveItemsFromAnnotationQueueRes, error)
	// RestoreDatasetVersion invokes restoreDatasetVersion operation.
	//
	// Restores the dataset to a previous version state. All draft items are replaced with items from the
	// specified version. If the version is not the latest, a new version snapshot is created. If the
	// version is the latest, only draft items are replaced (revert functionality).
	//
	// POST /v1/private/datasets/{id}/versions/restore
	RestoreDatasetVersion(ctx context.Context, request OptDatasetVersionRestorePublic, params RestoreDatasetVersionParams) (RestoreDatasetVersionRes, error)
	// RestorePromptVersion invokes restorePromptVersion operation.
	//
	// Restore a prompt version by creating a new version with the content from the specified version.
	//
	// POST /v1/private/prompts/{promptId}/versions/{versionId}/restore
	RestorePromptVersion(ctx context.Context, params RestorePromptVersionParams) (RestorePromptVersionRes, error)
	// RetrieveProject invokes retrieveProject operation.
	//
	// Retrieve project.
	//
	// POST /v1/private/projects/retrieve
	RetrieveProject(ctx context.Context, request OptProjectRetrieveDetailed) (RetrieveProjectRes, error)
	// RetrievePromptVersion invokes retrievePromptVersion operation.
	//
	// Retrieve prompt version.
	//
	// POST /v1/private/prompts/versions/retrieve
	RetrievePromptVersion(ctx context.Context, request OptPromptVersionRetrieveDetail) (RetrievePromptVersionRes, error)
	// ScoreBatchOfSpans invokes scoreBatchOfSpans operation.
	//
	// Batch feedback scoring for spans.
	//
	// PUT /v1/private/spans/feedback-scores
	ScoreBatchOfSpans(ctx context.Context, request OptFeedbackScoreBatch) error
	// ScoreBatchOfThreads invokes scoreBatchOfThreads operation.
	//
	// Batch feedback scoring for threads.
	//
	// PUT /v1/private/traces/threads/feedback-scores
	ScoreBatchOfThreads(ctx context.Context, request OptFeedbackScoreBatchThread) error
	// ScoreBatchOfTraces invokes scoreBatchOfTraces operation.
	//
	// Batch feedback scoring for traces.
	//
	// PUT /v1/private/traces/feedback-scores
	ScoreBatchOfTraces(ctx context.Context, request OptFeedbackScoreBatch) error
	// StartMultiPartUpload invokes startMultiPartUpload operation.
	//
	// Start multipart attachment upload.
	//
	// POST /v1/private/attachment/upload-start
	StartMultiPartUpload(ctx context.Context, request OptStartMultipartUploadRequest) (StartMultiPartUploadRes, error)
	// StoreLlmProviderApiKey invokes storeLlmProviderApiKey operation.
	//
	// Store LLM Provider's ApiKey.
	//
	// POST /v1/private/llm-provider-key
	StoreLlmProviderApiKey(ctx context.Context, request OptProviderApiKeyWrite) (StoreLlmProviderApiKeyRes, error)
	// SubmitWelcomeWizard invokes submitWelcomeWizard operation.
	//
	// Submit welcome wizard with user information.
	//
	// POST /v1/private/welcome-wizard
	SubmitWelcomeWizard(ctx context.Context, request OptWelcomeWizardSubmission) error
	// TestWebhook invokes testWebhook operation.
	//
	// Test alert webhook.
	//
	// POST /v1/private/alerts/webhooks/tests
	TestWebhook(ctx context.Context, request OptAlertWrite) (TestWebhookRes, error)
	// UpdateAlert invokes updateAlert operation.
	//
	// Update alert.
	//
	// PUT /v1/private/alerts/{id}
	UpdateAlert(ctx context.Context, request OptAlertWrite, params UpdateAlertParams) (UpdateAlertRes, error)
	// UpdateAnnotationQueue invokes updateAnnotationQueue operation.
	//
	// Update annotation queue by id.
	//
	// PATCH /v1/private/annotation-queues/{id}
	UpdateAnnotationQueue(ctx context.Context, request OptAnnotationQueueUpdate, params UpdateAnnotationQueueParams) (UpdateAnnotationQueueRes, error)
	// UpdateAutomationRuleEvaluator invokes updateAutomationRuleEvaluator operation.
	//
	// Update Automation Rule Evaluator by id.
	//
	// PATCH /v1/private/automations/evaluators/{id}
	UpdateAutomationRuleEvaluator(ctx context.Context, request OptAutomationRuleEvaluatorUpdate, params UpdateAutomationRuleEvaluatorParams) error
	// UpdateDashboard invokes updateDashboard operation.
	//
	// Update dashboard by id. Partial updates are supported - only provided fields will be updated.
	//
	// PATCH /v1/private/dashboards/{dashboardId}
	UpdateDashboard(ctx context.Context, request OptDashboardUpdatePublic, params UpdateDashboardParams) (UpdateDashboardRes, error)
	// UpdateDataset invokes updateDataset operation.
	//
	// Update dataset by id.
	//
	// PUT /v1/private/datasets/{id}
	UpdateDataset(ctx context.Context, request OptDatasetUpdate, params UpdateDatasetParams) error
	// UpdateDatasetVersion invokes updateDatasetVersion operation.
	//
	// Update a dataset version's change_description and/or add new tags.
	//
	// PATCH /v1/private/datasets/{id}/versions/hash/{versionHash}
	UpdateDatasetVersion(ctx context.Context, request OptDatasetVersionUpdatePublic, params UpdateDatasetVersionParams) (UpdateDatasetVersionRes, error)
	// UpdateExperiment invokes updateExperiment operation.
	//
	// Update experiment by id.
	//
	// PATCH /v1/private/experiments/{id}
	UpdateExperiment(ctx context.Context, request OptExperimentUpdate, params UpdateExperimentParams) (UpdateExperimentRes, error)
	// UpdateFeedbackDefinition invokes updateFeedbackDefinition operation.
	//
	// Update feedback definition by id.
	//
	// PUT /v1/private/feedback-definitions/{id}
	UpdateFeedbackDefinition(ctx context.Context, request OptFeedbackUpdate, params UpdateFeedbackDefinitionParams) error
	// UpdateLlmProviderApiKey invokes updateLlmProviderApiKey operation.
	//
	// Update LLM Provider's ApiKey.
	//
	// PATCH /v1/private/llm-provider-key/{id}
	UpdateLlmProviderApiKey(ctx context.Context, request OptProviderApiKeyUpdate, params UpdateLlmProviderApiKeyParams) (UpdateLlmProviderApiKeyRes, error)
	// UpdateOptimizationsById invokes updateOptimizationsById operation.
	//
	// Update optimization by id.
	//
	// PUT /v1/private/optimizations/{id}
	UpdateOptimizationsById(ctx context.Context, request OptOptimizationUpdate, params UpdateOptimizationsByIdParams) error
	// UpdateProject invokes updateProject operation.
	//
	// Update project by id.
	//
	// PATCH /v1/private/projects/{id}
	UpdateProject(ctx context.Context, request OptProjectUpdate, params UpdateProjectParams) (UpdateProjectRes, error)
	// UpdatePrompt invokes updatePrompt operation.
	//
	// Update prompt.
	//
	// PUT /v1/private/prompts/{id}
	UpdatePrompt(ctx context.Context, request OptPromptUpdatable, params UpdatePromptParams) (UpdatePromptRes, error)
	// UpdatePromptVersions invokes updatePromptVersions operation.
	//
	// Update one or more prompt versions.
	// Note: Prompt versions are immutable by design.
	// Only organizational properties, such as tags etc., can be updated.
	// Core properties like template and metadata cannot be modified after creation.
	// PATCH semantics:
	// - non-empty values update the field
	// - null values preserve existing field values (no change)
	// - empty values explicitly clear the field.
	//
	// PATCH /v1/private/prompts/versions
	UpdatePromptVersions(ctx context.Context, request OptPromptVersionBatchUpdate) (UpdatePromptVersionsRes, error)
	// UpdateSpan invokes updateSpan operation.
	//
	// Update span by id.
	//
	// PATCH /v1/private/spans/{id}
	UpdateSpan(ctx context.Context, request OptSpanUpdate, params UpdateSpanParams) (UpdateSpanRes, error)
	// UpdateSpanComment invokes updateSpanComment operation.
	//
	// Update span comment by id.
	//
	// PATCH /v1/private/spans/comments/{commentId}
	UpdateSpanComment(ctx context.Context, request OptComment, params UpdateSpanCommentParams) (UpdateSpanCommentRes, error)
	// UpdateThread invokes updateThread operation.
	//
	// Update thread.
	//
	// PATCH /v1/private/traces/threads/{threadModelId}
	UpdateThread(ctx context.Context, request OptTraceThreadUpdate, params UpdateThreadParams) (UpdateThreadRes, error)
	// UpdateThreadComment invokes updateThreadComment operation.
	//
	// Update thread comment by id.
	//
	// PATCH /v1/private/traces/threads/comments/{commentId}
	UpdateThreadComment(ctx context.Context, request OptComment, params UpdateThreadCommentParams) (UpdateThreadCommentRes, error)
	// UpdateTrace invokes updateTrace operation.
	//
	// Update trace by id.
	//
	// PATCH /v1/private/traces/{id}
	UpdateTrace(ctx context.Context, request OptTraceUpdate, params UpdateTraceParams) error
	// UpdateTraceComment invokes updateTraceComment operation.
	//
	// Update trace comment by id.
	//
	// PATCH /v1/private/traces/comments/{commentId}
	UpdateTraceComment(ctx context.Context, request OptComment, params UpdateTraceCommentParams) (UpdateTraceCommentRes, error)
	// UpsertOptimization invokes upsertOptimization operation.
	//
	// Upsert optimization.
	//
	// PUT /v1/private/optimizations
	UpsertOptimization(ctx context.Context, request OptOptimizationWrite) (*UpsertOptimizationCreated, error)
	// UpsertWorkspaceConfiguration invokes upsertWorkspaceConfiguration operation.
	//
	// Upsert workspace configuration.
	//
	// PUT /v1/private/workspaces/configurations
	UpsertWorkspaceConfiguration(ctx context.Context, request OptWorkspaceConfiguration) (UpsertWorkspaceConfigurationRes, error)
	// Version invokes version operation.
	//
	// GET /is-alive/ver
	Version(ctx context.Context) (*VersionDefStatusCode, error)
}

// Client implements OAS client.
type Client struct {
	serverURL *url.URL
	baseClient
}

var _ Handler = struct {
	*Client
}{}

// NewClient initializes new Client defined by OAS.
func NewClient(serverURL string, opts ...ClientOption) (*Client, error) {
	u, err := url.Parse(serverURL)
	if err != nil {
		return nil, err
	}
	trimTrailingSlashes(u)

	c, err := newClientConfig(opts...).baseClient()
	if err != nil {
		return nil, err
	}
	return &Client{
		serverURL:  u,
		baseClient: c,
	}, nil
}

type serverURLKey struct{}

// WithServerURL sets context key to override server URL.
func WithServerURL(ctx context.Context, u *url.URL) context.Context {
	return context.WithValue(ctx, serverURLKey{}, u)
}

func (c *Client) requestURL(ctx context.Context) *url.URL {
	u, ok := ctx.Value(serverURLKey{}).(*url.URL)
	if !ok {
		return c.serverURL
	}
	return u
}

// AddItemsToAnnotationQueue invokes addItemsToAnnotationQueue operation.
//
// Add traces or threads to annotation queue.
//
// POST /v1/private/annotation-queues/{id}/items/add
func (c *Client) AddItemsToAnnotationQueue(ctx context.Context, request OptAnnotationQueueItemIds, params AddItemsToAnnotationQueueParams) (AddItemsToAnnotationQueueRes, error) {
	res, err := c.sendAddItemsToAnnotationQueue(ctx, request, params)
	return res, err
}

func (c *Client) sendAddItemsToAnnotationQueue(ctx context.Context, request OptAnnotationQueueItemIds, params AddItemsToAnnotationQueueParams) (res AddItemsToAnnotationQueueRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("addItemsToAnnotationQueue"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/private/annotation-queues/{id}/items/add"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, AddItemsToAnnotationQueueOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/private/annotation-queues/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/items/add"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAddItemsToAnnotationQueueRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAddItemsToAnnotationQueueResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AddSpanComment invokes addSpanComment operation.
//
// Add span comment.
//
// POST /v1/private/spans/{id}/comments
func (c *Client) AddSpanComment(ctx context.Context, request OptComment, params AddSpanCommentParams) (*AddSpanCommentCreated, error) {
	res, err := c.sendAddSpanComment(ctx, request, params)
	return res, err
}

func (c *Client) sendAddSpanComment(ctx context.Context, request OptComment, params AddSpanCommentParams) (res *AddSpanCommentCreated, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("addSpanComment"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/private/spans/{id}/comments"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, AddSpanCommentOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/private/spans/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/comments"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAddSpanCommentRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAddSpanCommentResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AddSpanFeedbackScore invokes addSpanFeedbackScore operation.
//
// Add span feedback score.
//
// PUT /v1/private/spans/{id}/feedback-scores
func (c *Client) AddSpanFeedbackScore(ctx context.Context, request OptFeedbackScore, params AddSpanFeedbackScoreParams) error {
	_, err := c.sendAddSpanFeedbackScore(ctx, request, params)
	return err
}

func (c *Client) sendAddSpanFeedbackScore(ctx context.Context, request OptFeedbackScore, params AddSpanFeedbackScoreParams) (res *AddSpanFeedbackScoreNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("addSpanFeedbackScore"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.URLTemplateKey.String("/v1/private/spans/{id}/feedback-scores"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, AddSpanFeedbackScoreOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/private/spans/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/feedback-scores"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAddSpanFeedbackScoreRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAddSpanFeedbackScoreResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AddThreadComment invokes addThreadComment operation.
//
// Add thread comment.
//
// POST /v1/private/traces/threads/{id}/comments
func (c *Client) AddThreadComment(ctx context.Context, request OptComment, params AddThreadCommentParams) (*AddThreadCommentCreated, error) {
	res, err := c.sendAddThreadComment(ctx, request, params)
	return res, err
}

func (c *Client) sendAddThreadComment(ctx context.Context, request OptComment, params AddThreadCommentParams) (res *AddThreadCommentCreated, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("addThreadComment"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/private/traces/threads/{id}/comments"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, AddThreadCommentOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/private/traces/threads/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/comments"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAddThreadCommentRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAddThreadCommentResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AddTraceComment invokes addTraceComment operation.
//
// Add trace comment.
//
// POST /v1/private/traces/{id}/comments
func (c *Client) AddTraceComment(ctx context.Context, request OptComment, params AddTraceCommentParams) (*AddTraceCommentCreated, error) {
	res, err := c.sendAddTraceComment(ctx, request, params)
	return res, err
}

func (c *Client) sendAddTraceComment(ctx context.Context, request OptComment, params AddTraceCommentParams) (res *AddTraceCommentCreated, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("addTraceComment"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/private/traces/{id}/comments"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, AddTraceCommentOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/private/traces/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/comments"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAddTraceCommentRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAddTraceCommentResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AddTraceFeedbackScore invokes addTraceFeedbackScore operation.
//
// Add trace feedback score.
//
// PUT /v1/private/traces/{id}/feedback-scores
func (c *Client) AddTraceFeedbackScore(ctx context.Context, request OptFeedbackScore, params AddTraceFeedbackScoreParams) error {
	_, err := c.sendAddTraceFeedbackScore(ctx, request, params)
	return err
}

func (c *Client) sendAddTraceFeedbackScore(ctx context.Context, request OptFeedbackScore, params AddTraceFeedbackScoreParams) (res *AddTraceFeedbackScoreNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("addTraceFeedbackScore"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.URLTemplateKey.String("/v1/private/traces/{id}/feedback-scores"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, AddTraceFeedbackScoreOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/private/traces/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/feedback-scores"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAddTraceFeedbackScoreRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAddTraceFeedbackScoreResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AttachmentList invokes attachmentList operation.
//
// Attachments list for entity.
//
// GET /v1/private/attachment/list
func (c *Client) AttachmentList(ctx context.Context, params AttachmentListParams) (AttachmentListRes, error) {
	res, err := c.sendAttachmentList(ctx, params)
	return res, err
}

func (c *Client) sendAttachmentList(ctx context.Context, params AttachmentListParams) (res AttachmentListRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("attachmentList"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/private/attachment/list"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, AttachmentListOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/attachment/list"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Size.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "project_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "project_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.UUIDToString(params.ProjectID))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "entity_type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "entity_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(string(params.EntityType)))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "entity_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "entity_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.UUIDToString(params.EntityID))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "path" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "path",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.Path))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAttachmentListResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// BatchUpdateDatasetItems invokes batchUpdateDatasetItems operation.
//
// Update multiple dataset items.
//
// PATCH /v1/private/datasets/items/batch
func (c *Client) BatchUpdateDatasetItems(ctx context.Context, request OptDatasetItemBatchUpdate) (BatchUpdateDatasetItemsRes, error) {
	res, err := c.sendBatchUpdateDatasetItems(ctx, request)
	return res, err
}

func (c *Client) sendBatchUpdateDatasetItems(ctx context.Context, request OptDatasetItemBatchUpdate) (res BatchUpdateDatasetItemsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("batchUpdateDatasetItems"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.URLTemplateKey.String("/v1/private/datasets/items/batch"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, BatchUpdateDatasetItemsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/datasets/items/batch"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeBatchUpdateDatasetItemsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeBatchUpdateDatasetItemsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// BatchUpdateSpans invokes batchUpdateSpans operation.
//
// Update multiple spans.
//
// PATCH /v1/private/spans/batch
func (c *Client) BatchUpdateSpans(ctx context.Context, request OptSpanBatchUpdate) (BatchUpdateSpansRes, error) {
	res, err := c.sendBatchUpdateSpans(ctx, request)
	return res, err
}

func (c *Client) sendBatchUpdateSpans(ctx context.Context, request OptSpanBatchUpdate) (res BatchUpdateSpansRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("batchUpdateSpans"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.URLTemplateKey.String("/v1/private/spans/batch"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, BatchUpdateSpansOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/spans/batch"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeBatchUpdateSpansRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeBatchUpdateSpansResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// BatchUpdateThreads invokes batchUpdateThreads operation.
//
// Update multiple threads.
//
// PATCH /v1/private/traces/threads/batch
func (c *Client) BatchUpdateThreads(ctx context.Context, request OptTraceThreadBatchUpdate) (BatchUpdateThreadsRes, error) {
	res, err := c.sendBatchUpdateThreads(ctx, request)
	return res, err
}

func (c *Client) sendBatchUpdateThreads(ctx context.Context, request OptTraceThreadBatchUpdate) (res BatchUpdateThreadsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("batchUpdateThreads"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.URLTemplateKey.String("/v1/private/traces/threads/batch"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, BatchUpdateThreadsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/traces/threads/batch"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeBatchUpdateThreadsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeBatchUpdateThreadsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// BatchUpdateTraces invokes batchUpdateTraces operation.
//
// Update multiple traces.
//
// PATCH /v1/private/traces/batch
func (c *Client) BatchUpdateTraces(ctx context.Context, request OptTraceBatchUpdate) (BatchUpdateTracesRes, error) {
	res, err := c.sendBatchUpdateTraces(ctx, request)
	return res, err
}

func (c *Client) sendBatchUpdateTraces(ctx context.Context, request OptTraceBatchUpdate) (res BatchUpdateTracesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("batchUpdateTraces"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.URLTemplateKey.String("/v1/private/traces/batch"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, BatchUpdateTracesOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/traces/batch"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeBatchUpdateTracesRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeBatchUpdateTracesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CancelStudioOptimizations invokes cancelStudioOptimizations operation.
//
// Cancel Studio optimizations by id.
//
// GET /v1/private/optimizations/studio/{id}/cancel
func (c *Client) CancelStudioOptimizations(ctx context.Context, params CancelStudioOptimizationsParams) error {
	_, err := c.sendCancelStudioOptimizations(ctx, params)
	return err
}

func (c *Client) sendCancelStudioOptimizations(ctx context.Context, params CancelStudioOptimizationsParams) (res *CancelStudioOptimizationsNotImplemented, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("cancelStudioOptimizations"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/private/optimizations/studio/{id}/cancel"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CancelStudioOptimizationsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/private/optimizations/studio/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/cancel"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCancelStudioOptimizationsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CheckAccess invokes checkAccess operation.
//
// Check user access to workspace.
//
// POST /v1/private/auth
func (c *Client) CheckAccess(ctx context.Context, request *AuthDetailsHolder) (CheckAccessRes, error) {
	res, err := c.sendCheckAccess(ctx, request)
	return res, err
}

func (c *Client) sendCheckAccess(ctx context.Context, request *AuthDetailsHolder) (res CheckAccessRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("checkAccess"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/private/auth"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CheckAccessOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/auth"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCheckAccessRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCheckAccessResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CloseTraceThread invokes closeTraceThread operation.
//
// Close one or multiple trace threads. Supports both single thread_id and multiple thread_ids for
// batch operations.
//
// PUT /v1/private/traces/threads/close
func (c *Client) CloseTraceThread(ctx context.Context, request OptTraceThreadBatchIdentifier) (CloseTraceThreadRes, error) {
	res, err := c.sendCloseTraceThread(ctx, request)
	return res, err
}

func (c *Client) sendCloseTraceThread(ctx context.Context, request OptTraceThreadBatchIdentifier) (res CloseTraceThreadRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("closeTraceThread"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.URLTemplateKey.String("/v1/private/traces/threads/close"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CloseTraceThreadOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/traces/threads/close"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCloseTraceThreadRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCloseTraceThreadResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CompareDatasetVersions invokes compareDatasetVersions operation.
//
// Compare the latest committed dataset version with the current draft state. This endpoint provides
// insights into changes made since the last version was committed. The comparison calculates
// additions, modifications, deletions, and unchanged items between the latest version snapshot and
// current draft.
//
// GET /v1/private/datasets/{id}/versions/diff
func (c *Client) CompareDatasetVersions(ctx context.Context, params CompareDatasetVersionsParams) (CompareDatasetVersionsRes, error) {
	res, err := c.sendCompareDatasetVersions(ctx, params)
	return res, err
}

func (c *Client) sendCompareDatasetVersions(ctx context.Context, params CompareDatasetVersionsParams) (res CompareDatasetVersionsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("compareDatasetVersions"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/private/datasets/{id}/versions/diff"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CompareDatasetVersionsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/private/datasets/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/versions/diff"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCompareDatasetVersionsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CompleteMultiPartUpload invokes completeMultiPartUpload operation.
//
// Complete multipart attachment upload.
//
// POST /v1/private/attachment/upload-complete
func (c *Client) CompleteMultiPartUpload(ctx context.Context, request OptCompleteMultipartUploadRequest) (CompleteMultiPartUploadRes, error) {
	res, err := c.sendCompleteMultiPartUpload(ctx, request)
	return res, err
}

func (c *Client) sendCompleteMultiPartUpload(ctx context.Context, request OptCompleteMultipartUploadRequest) (res CompleteMultiPartUploadRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("completeMultiPartUpload"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/private/attachment/upload-complete"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CompleteMultiPartUploadOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/attachment/upload-complete"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCompleteMultiPartUploadRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCompleteMultiPartUploadResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CostsSummary invokes costsSummary operation.
//
// Get costs summary.
//
// POST /v1/private/workspaces/costs/summaries
func (c *Client) CostsSummary(ctx context.Context, request OptWorkspaceMetricsSummaryRequest) (CostsSummaryRes, error) {
	res, err := c.sendCostsSummary(ctx, request)
	return res, err
}

func (c *Client) sendCostsSummary(ctx context.Context, request OptWorkspaceMetricsSummaryRequest) (res CostsSummaryRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("costsSummary"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/private/workspaces/costs/summaries"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CostsSummaryOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/workspaces/costs/summaries"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCostsSummaryRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCostsSummaryResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateAlert invokes createAlert operation.
//
// Create alert.
//
// POST /v1/private/alerts
func (c *Client) CreateAlert(ctx context.Context, request OptAlertWrite) (CreateAlertRes, error) {
	res, err := c.sendCreateAlert(ctx, request)
	return res, err
}

func (c *Client) sendCreateAlert(ctx context.Context, request OptAlertWrite) (res CreateAlertRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createAlert"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/private/alerts"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreateAlertOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/alerts"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateAlertRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateAlertResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateAnnotationQueue invokes createAnnotationQueue operation.
//
// Create annotation queue for human annotation workflows.
//
// POST /v1/private/annotation-queues
func (c *Client) CreateAnnotationQueue(ctx context.Context, request OptAnnotationQueueWrite) (CreateAnnotationQueueRes, error) {
	res, err := c.sendCreateAnnotationQueue(ctx, request)
	return res, err
}

func (c *Client) sendCreateAnnotationQueue(ctx context.Context, request OptAnnotationQueueWrite) (res CreateAnnotationQueueRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createAnnotationQueue"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/private/annotation-queues"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreateAnnotationQueueOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/annotation-queues"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateAnnotationQueueRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateAnnotationQueueResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateAnnotationQueueBatch invokes createAnnotationQueueBatch operation.
//
// Create multiple annotation queues for human annotation workflows.
//
// POST /v1/private/annotation-queues/batch
func (c *Client) CreateAnnotationQueueBatch(ctx context.Context, request OptAnnotationQueueBatchWrite) (CreateAnnotationQueueBatchRes, error) {
	res, err := c.sendCreateAnnotationQueueBatch(ctx, request)
	return res, err
}

func (c *Client) sendCreateAnnotationQueueBatch(ctx context.Context, request OptAnnotationQueueBatchWrite) (res CreateAnnotationQueueBatchRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createAnnotationQueueBatch"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/private/annotation-queues/batch"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreateAnnotationQueueBatchOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/annotation-queues/batch"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateAnnotationQueueBatchRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateAnnotationQueueBatchResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateAutomationRuleEvaluator invokes createAutomationRuleEvaluator operation.
//
// Create automation rule evaluator.
//
// POST /v1/private/automations/evaluators
func (c *Client) CreateAutomationRuleEvaluator(ctx context.Context, request OptAutomationRuleEvaluatorWrite) (*CreateAutomationRuleEvaluatorCreated, error) {
	res, err := c.sendCreateAutomationRuleEvaluator(ctx, request)
	return res, err
}

func (c *Client) sendCreateAutomationRuleEvaluator(ctx context.Context, request OptAutomationRuleEvaluatorWrite) (res *CreateAutomationRuleEvaluatorCreated, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createAutomationRuleEvaluator"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/private/automations/evaluators"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreateAutomationRuleEvaluatorOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/automations/evaluators"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateAutomationRuleEvaluatorRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateAutomationRuleEvaluatorResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateChatCompletions invokes createChatCompletions operation.
//
// Create chat completions.
//
// POST /v1/private/chat/completions
func (c *Client) CreateChatCompletions(ctx context.Context, request OptChatCompletionRequest) (*ChatCompletionResponse, error) {
	res, err := c.sendCreateChatCompletions(ctx, request)
	return res, err
}

func (c *Client) sendCreateChatCompletions(ctx context.Context, request OptChatCompletionRequest) (res *ChatCompletionResponse, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createChatCompletions"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/private/chat/completions"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreateChatCompletionsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/chat/completions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateChatCompletionsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateChatCompletionsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateDashboard invokes createDashboard operation.
//
// Create a new dashboard in a workspace.
//
// POST /v1/private/dashboards
func (c *Client) CreateDashboard(ctx context.Context, request OptDashboardWrite) (*DashboardPublicHeaders, error) {
	res, err := c.sendCreateDashboard(ctx, request)
	return res, err
}

func (c *Client) sendCreateDashboard(ctx context.Context, request OptDashboardWrite) (res *DashboardPublicHeaders, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createDashboard"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/private/dashboards"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreateDashboardOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/dashboards"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateDashboardRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateDashboardResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateDataset invokes createDataset operation.
//
// Create dataset.
//
// POST /v1/private/datasets
func (c *Client) CreateDataset(ctx context.Context, request OptDatasetWrite) (*CreateDatasetCreated, error) {
	res, err := c.sendCreateDataset(ctx, request)
	return res, err
}

func (c *Client) sendCreateDataset(ctx context.Context, request OptDatasetWrite) (res *CreateDatasetCreated, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createDataset"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/private/datasets"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreateDatasetOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/datasets"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateDatasetRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateDatasetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateDatasetItemsFromCsv invokes createDatasetItemsFromCsv operation.
//
// Create dataset items from uploaded CSV file. CSV should have headers in the first row. Processing
// happens asynchronously in batches.
//
// POST /v1/private/datasets/items/from-csv
func (c *Client) CreateDatasetItemsFromCsv(ctx context.Context, request OptCreateDatasetItemsFromCsvReq) (CreateDatasetItemsFromCsvRes, error) {
	res, err := c.sendCreateDatasetItemsFromCsv(ctx, request)
	return res, err
}

func (c *Client) sendCreateDatasetItemsFromCsv(ctx context.Context, request OptCreateDatasetItemsFromCsvReq) (res CreateDatasetItemsFromCsvRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createDatasetItemsFromCsv"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/private/datasets/items/from-csv"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreateDatasetItemsFromCsvOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/datasets/items/from-csv"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateDatasetItemsFromCsvRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateDatasetItemsFromCsvResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateDatasetItemsFromSpans invokes createDatasetItemsFromSpans operation.
//
// Create dataset items from spans with enriched metadata.
//
// POST /v1/private/datasets/{dataset_id}/items/from-spans
func (c *Client) CreateDatasetItemsFromSpans(ctx context.Context, request OptCreateDatasetItemsFromSpansRequest, params CreateDatasetItemsFromSpansParams) error {
	_, err := c.sendCreateDatasetItemsFromSpans(ctx, request, params)
	return err
}

func (c *Client) sendCreateDatasetItemsFromSpans(ctx context.Context, request OptCreateDatasetItemsFromSpansRequest, params CreateDatasetItemsFromSpansParams) (res *CreateDatasetItemsFromSpansNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createDatasetItemsFromSpans"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/private/datasets/{dataset_id}/items/from-spans"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreateDatasetItemsFromSpansOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/private/datasets/"
	{
		// Encode "dataset_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "dataset_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.DatasetID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/items/from-spans"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateDatasetItemsFromSpansRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateDatasetItemsFromSpansResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateDatasetItemsFromTraces invokes createDatasetItemsFromTraces operation.
//
// Create dataset items from traces with enriched metadata.
//
// POST /v1/private/datasets/{dataset_id}/items/from-traces
func (c *Client) CreateDatasetItemsFromTraces(ctx context.Context, request OptCreateDatasetItemsFromTracesRequest, params CreateDatasetItemsFromTracesParams) error {
	_, err := c.sendCreateDatasetItemsFromTraces(ctx, request, params)
	return err
}

func (c *Client) sendCreateDatasetItemsFromTraces(ctx context.Context, request OptCreateDatasetItemsFromTracesRequest, params CreateDatasetItemsFromTracesParams) (res *CreateDatasetItemsFromTracesNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createDatasetItemsFromTraces"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/private/datasets/{dataset_id}/items/from-traces"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreateDatasetItemsFromTracesOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/private/datasets/"
	{
		// Encode "dataset_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "dataset_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.DatasetID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/items/from-traces"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateDatasetItemsFromTracesRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateDatasetItemsFromTracesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateDatasetVersion invokes createDatasetVersion operation.
//
// Create a new immutable version of the dataset by snapshotting the current state.
//
// POST /v1/private/datasets/{id}/versions
func (c *Client) CreateDatasetVersion(ctx context.Context, request OptDatasetVersionCreatePublic, params CreateDatasetVersionParams) (CreateDatasetVersionRes, error) {
	res, err := c.sendCreateDatasetVersion(ctx, request, params)
	return res, err
}

func (c *Client) sendCreateDatasetVersion(ctx context.Context, request OptDatasetVersionCreatePublic, params CreateDatasetVersionParams) (res CreateDatasetVersionRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createDatasetVersion"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/private/datasets/{id}/versions"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreateDatasetVersionOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/private/datasets/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/versions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateDatasetVersionRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateDatasetVersionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateExperiment invokes createExperiment operation.
//
// Create experiment.
//
// POST /v1/private/experiments
func (c *Client) CreateExperiment(ctx context.Context, request OptExperimentWrite) (*CreateExperimentCreated, error) {
	res, err := c.sendCreateExperiment(ctx, request)
	return res, err
}

func (c *Client) sendCreateExperiment(ctx context.Context, request OptExperimentWrite) (res *CreateExperimentCreated, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createExperiment"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/private/experiments"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreateExperimentOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/experiments"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateExperimentRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateExperimentResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateExperimentItems invokes createExperimentItems operation.
//
// Create experiment items.
//
// POST /v1/private/experiments/items
func (c *Client) CreateExperimentItems(ctx context.Context, request OptExperimentItemsBatch) error {
	_, err := c.sendCreateExperimentItems(ctx, request)
	return err
}

func (c *Client) sendCreateExperimentItems(ctx context.Context, request OptExperimentItemsBatch) (res *CreateExperimentItemsNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createExperimentItems"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/private/experiments/items"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreateExperimentItemsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/experiments/items"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateExperimentItemsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateExperimentItemsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateFeedbackDefinition invokes createFeedbackDefinition operation.
//
// Get feedback definition.
//
// POST /v1/private/feedback-definitions
func (c *Client) CreateFeedbackDefinition(ctx context.Context, request OptFeedbackCreate) (*CreateFeedbackDefinitionCreated, error) {
	res, err := c.sendCreateFeedbackDefinition(ctx, request)
	return res, err
}

func (c *Client) sendCreateFeedbackDefinition(ctx context.Context, request OptFeedbackCreate) (res *CreateFeedbackDefinitionCreated, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createFeedbackDefinition"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/private/feedback-definitions"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreateFeedbackDefinitionOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/feedback-definitions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateFeedbackDefinitionRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateFeedbackDefinitionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateGuardrails invokes createGuardrails operation.
//
// Batch guardrails for traces.
//
// POST /v1/private/guardrails
func (c *Client) CreateGuardrails(ctx context.Context, request OptGuardrailBatchWrite) error {
	_, err := c.sendCreateGuardrails(ctx, request)
	return err
}

func (c *Client) sendCreateGuardrails(ctx context.Context, request OptGuardrailBatchWrite) (res *CreateGuardrailsNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createGuardrails"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/private/guardrails"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreateGuardrailsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/guardrails"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateGuardrailsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateGuardrailsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateOptimization invokes createOptimization operation.
//
// Create optimization.
//
// POST /v1/private/optimizations
func (c *Client) CreateOptimization(ctx context.Context, request OptOptimizationWrite) (*CreateOptimizationCreated, error) {
	res, err := c.sendCreateOptimization(ctx, request)
	return res, err
}

func (c *Client) sendCreateOptimization(ctx context.Context, request OptOptimizationWrite) (res *CreateOptimizationCreated, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createOptimization"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/private/optimizations"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreateOptimizationOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/optimizations"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateOptimizationRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateOptimizationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateOrUpdateDatasetItems invokes createOrUpdateDatasetItems operation.
//
// Create/update dataset items based on dataset item id.
//
// PUT /v1/private/datasets/items
func (c *Client) CreateOrUpdateDatasetItems(ctx context.Context, request OptDatasetItemBatchWrite) error {
	_, err := c.sendCreateOrUpdateDatasetItems(ctx, request)
	return err
}

func (c *Client) sendCreateOrUpdateDatasetItems(ctx context.Context, request OptDatasetItemBatchWrite) (res *CreateOrUpdateDatasetItemsNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createOrUpdateDatasetItems"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.URLTemplateKey.String("/v1/private/datasets/items"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreateOrUpdateDatasetItemsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/datasets/items"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateOrUpdateDatasetItemsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateOrUpdateDatasetItemsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateProject invokes createProject operation.
//
// Create project.
//
// POST /v1/private/projects
func (c *Client) CreateProject(ctx context.Context, request OptProjectWrite) (CreateProjectRes, error) {
	res, err := c.sendCreateProject(ctx, request)
	return res, err
}

func (c *Client) sendCreateProject(ctx context.Context, request OptProjectWrite) (res CreateProjectRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createProject"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/private/projects"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreateProjectOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/projects"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateProjectRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateProjectResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreatePrompt invokes createPrompt operation.
//
// Create prompt.
//
// POST /v1/private/prompts
func (c *Client) CreatePrompt(ctx context.Context, request OptPromptWrite) (CreatePromptRes, error) {
	res, err := c.sendCreatePrompt(ctx, request)
	return res, err
}

func (c *Client) sendCreatePrompt(ctx context.Context, request OptPromptWrite) (res CreatePromptRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createPrompt"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/private/prompts"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreatePromptOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/prompts"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreatePromptRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreatePromptResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreatePromptVersion invokes createPromptVersion operation.
//
// Create prompt version.
//
// POST /v1/private/prompts/versions
func (c *Client) CreatePromptVersion(ctx context.Context, request OptCreatePromptVersionDetail) (CreatePromptVersionRes, error) {
	res, err := c.sendCreatePromptVersion(ctx, request)
	return res, err
}

func (c *Client) sendCreatePromptVersion(ctx context.Context, request OptCreatePromptVersionDetail) (res CreatePromptVersionRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createPromptVersion"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/private/prompts/versions"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreatePromptVersionOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/prompts/versions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreatePromptVersionRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreatePromptVersionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateSpan invokes createSpan operation.
//
// Create span.
//
// POST /v1/private/spans
func (c *Client) CreateSpan(ctx context.Context, request OptSpanWrite) (CreateSpanRes, error) {
	res, err := c.sendCreateSpan(ctx, request)
	return res, err
}

func (c *Client) sendCreateSpan(ctx context.Context, request OptSpanWrite) (res CreateSpanRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createSpan"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/private/spans"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreateSpanOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/spans"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateSpanRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateSpanResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateSpans invokes createSpans operation.
//
// Create spans.
//
// POST /v1/private/spans/batch
func (c *Client) CreateSpans(ctx context.Context, request OptSpanBatchWrite) error {
	_, err := c.sendCreateSpans(ctx, request)
	return err
}

func (c *Client) sendCreateSpans(ctx context.Context, request OptSpanBatchWrite) (res *CreateSpansNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createSpans"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/private/spans/batch"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreateSpansOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/spans/batch"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateSpansRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateSpansResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateTrace invokes createTrace operation.
//
// Get trace.
//
// POST /v1/private/traces
func (c *Client) CreateTrace(ctx context.Context, request OptTraceWrite) (*CreateTraceCreated, error) {
	res, err := c.sendCreateTrace(ctx, request)
	return res, err
}

func (c *Client) sendCreateTrace(ctx context.Context, request OptTraceWrite) (res *CreateTraceCreated, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createTrace"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/private/traces"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreateTraceOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/traces"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateTraceRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateTraceResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateTraces invokes createTraces operation.
//
// Create traces.
//
// POST /v1/private/traces/batch
func (c *Client) CreateTraces(ctx context.Context, request OptTraceBatchWrite) error {
	_, err := c.sendCreateTraces(ctx, request)
	return err
}

func (c *Client) sendCreateTraces(ctx context.Context, request OptTraceBatchWrite) (res *CreateTracesNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createTraces"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/private/traces/batch"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreateTracesOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/traces/batch"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateTracesRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateTracesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateVersionTag invokes createVersionTag operation.
//
// Add a tag to a specific dataset version for easy reference (e.g., 'baseline', 'v1.0', 'production').
//
// POST /v1/private/datasets/{id}/versions/hash/{versionHash}/tags
func (c *Client) CreateVersionTag(ctx context.Context, request OptDatasetVersionTag, params CreateVersionTagParams) (CreateVersionTagRes, error) {
	res, err := c.sendCreateVersionTag(ctx, request, params)
	return res, err
}

func (c *Client) sendCreateVersionTag(ctx context.Context, request OptDatasetVersionTag, params CreateVersionTagParams) (res CreateVersionTagRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createVersionTag"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/private/datasets/{id}/versions/hash/{versionHash}/tags"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreateVersionTagOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/v1/private/datasets/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/versions/hash/"
	{
		// Encode "versionHash" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "versionHash",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.VersionHash))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/tags"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateVersionTagRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateVersionTagResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteAlertBatch invokes deleteAlertBatch operation.
//
// Delete multiple alerts by their IDs.
//
// POST /v1/private/alerts/delete
func (c *Client) DeleteAlertBatch(ctx context.Context, request OptBatchDelete) (DeleteAlertBatchRes, error) {
	res, err := c.sendDeleteAlertBatch(ctx, request)
	return res, err
}

func (c *Client) sendDeleteAlertBatch(ctx context.Context, request OptBatchDelete) (res DeleteAlertBatchRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteAlertBatch"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/private/alerts/delete"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteAlertBatchOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/alerts/delete"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDeleteAlertBatchRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteAlertBatchResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteAnnotationQueueBatch invokes deleteAnnotationQueueBatch operation.
//
// Delete multiple annotation queues by their IDs.
//
// POST /v1/private/annotation-queues/delete
func (c *Client) DeleteAnnotationQueueBatch(ctx context.Context, request OptBatchDelete) (DeleteAnnotationQueueBatchRes, error) {
	res, err := c.sendDeleteAnnotationQueueBatch(ctx, request)
	return res, err
}

func (c *Client) sendDeleteAnnotationQueueBatch(ctx context.Context, request OptBatchDelete) (res DeleteAnnotationQueueBatchRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteAnnotationQueueBatch"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/private/annotation-queues/delete"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteAnnotationQueueBatchOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/annotation-queues/delete"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDeleteAnnotationQueueBatchRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteAnnotationQueueBatchResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteAttachments invokes deleteAttachments operation.
//
// Delete attachments.
//
// POST /v1/private/attachment/delete
func (c *Client) DeleteAttachments(ctx context.Context, request OptCompleteMultipartUploadRequest) (DeleteAttachmentsRes, error) {
	res, err := c.sendDeleteAttachments(ctx, request)
	return res, err
}

func (c *Client) sendDeleteAttachments(ctx context.Context, request OptCompleteMultipartUploadRequest) (res DeleteAttachmentsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteAttachments"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/private/attachment/delete"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteAttachmentsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/attachment/delete"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDeleteAttachmentsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteAttachmentsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteAutomationRuleEvaluatorBatch invokes deleteAutomationRuleEvaluatorBatch operation.
//
// Delete automation rule evaluators batch.
//
// POST /v1/private/automations/evaluators/delete
func (c *Client) DeleteAutomationRuleEvaluatorBatch(ctx context.Context, request OptBatchDelete, params DeleteAutomationRuleEvaluatorBatchParams) error {
	_, err := c.sendDeleteAutomationRuleEvaluatorBatch(ctx, request, params)
	return err
}

func (c *Client) sendDeleteAutomationRuleEvaluatorBatch(ctx context.Context, request OptBatchDelete, params DeleteAutomationRuleEvaluatorBatchParams) (res *DeleteAutomationRuleEvaluatorBatchNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteAutomationRuleEvaluatorBatch"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/private/automations/evaluators/delete"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteAutomationRuleEvaluatorBatchOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/automations/evaluators/delete"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "project_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "project_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ProjectID.Get(); ok {
				return e.EncodeValue(conv.UUIDToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDeleteAutomationRuleEvaluatorBatchRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteAutomationRuleEvaluatorBatchResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteDashboard invokes deleteDashboard operation.
//
// Delete dashboard by id.
//
// DELETE /v1/private/dashboards/{dashboardId}
func (c *Client) DeleteDashboard(ctx context.Context, params DeleteDashboardParams) error {
	_, err := c.sendDeleteDashboard(ctx, params)
	return err
}

func (c *Client) sendDeleteDashboard(ctx context.Context, params DeleteDashboardParams) (res *DeleteDashboardNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteDashboard"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/v1/private/dashboards/{dashboardId}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteDashboardOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/private/dashboards/"
	{
		// Encode "dashboardId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "dashboardId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.DashboardId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteDashboardResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteDashboardsBatch invokes deleteDashboardsBatch operation.
//
// Delete dashboards batch.
//
// POST /v1/private/dashboards/delete-batch
func (c *Client) DeleteDashboardsBatch(ctx context.Context, request OptBatchDelete) error {
	_, err := c.sendDeleteDashboardsBatch(ctx, request)
	return err
}

func (c *Client) sendDeleteDashboardsBatch(ctx context.Context, request OptBatchDelete) (res *DeleteDashboardsBatchNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteDashboardsBatch"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/private/dashboards/delete-batch"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteDashboardsBatchOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/dashboards/delete-batch"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDeleteDashboardsBatchRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteDashboardsBatchResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteDataset invokes deleteDataset operation.
//
// Delete dataset by id.
//
// DELETE /v1/private/datasets/{id}
func (c *Client) DeleteDataset(ctx context.Context, params DeleteDatasetParams) error {
	_, err := c.sendDeleteDataset(ctx, params)
	return err
}

func (c *Client) sendDeleteDataset(ctx context.Context, params DeleteDatasetParams) (res *DeleteDatasetNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteDataset"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/v1/private/datasets/{id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteDatasetOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/private/datasets/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteDatasetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteDatasetByName invokes deleteDatasetByName operation.
//
// Delete dataset by name.
//
// POST /v1/private/datasets/delete
func (c *Client) DeleteDatasetByName(ctx context.Context, request OptDatasetIdentifier) error {
	_, err := c.sendDeleteDatasetByName(ctx, request)
	return err
}

func (c *Client) sendDeleteDatasetByName(ctx context.Context, request OptDatasetIdentifier) (res *DeleteDatasetByNameNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteDatasetByName"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/private/datasets/delete"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteDatasetByNameOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/datasets/delete"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDeleteDatasetByNameRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteDatasetByNameResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteDatasetItems invokes deleteDatasetItems operation.
//
// Delete dataset items using one of two modes:
// 1. **Delete by IDs**: Provide 'item_ids' to delete specific items by their IDs
// 2. **Delete by filters**: Provide 'dataset_id' with optional 'filters' to delete items matching
// criteria
// When using filters, an empty 'filters' array will delete all items in the specified dataset.
//
// POST /v1/private/datasets/items/delete
func (c *Client) DeleteDatasetItems(ctx context.Context, request OptDatasetItemsDelete) (DeleteDatasetItemsRes, error) {
	res, err := c.sendDeleteDatasetItems(ctx, request)
	return res, err
}

func (c *Client) sendDeleteDatasetItems(ctx context.Context, request OptDatasetItemsDelete) (res DeleteDatasetItemsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteDatasetItems"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/private/datasets/items/delete"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteDatasetItemsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/datasets/items/delete"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDeleteDatasetItemsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteDatasetItemsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteDatasetsBatch invokes deleteDatasetsBatch operation.
//
// Delete datasets batch.
//
// POST /v1/private/datasets/delete-batch
func (c *Client) DeleteDatasetsBatch(ctx context.Context, request OptBatchDelete) error {
	_, err := c.sendDeleteDatasetsBatch(ctx, request)
	return err
}

func (c *Client) sendDeleteDatasetsBatch(ctx context.Context, request OptBatchDelete) (res *DeleteDatasetsBatchNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteDatasetsBatch"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/private/datasets/delete-batch"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteDatasetsBatchOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/datasets/delete-batch"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDeleteDatasetsBatchRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteDatasetsBatchResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteExperimentItems invokes deleteExperimentItems operation.
//
// Delete experiment items.
//
// POST /v1/private/experiments/items/delete
func (c *Client) DeleteExperimentItems(ctx context.Context, request OptExperimentItemsDelete) error {
	_, err := c.sendDeleteExperimentItems(ctx, request)
	return err
}

func (c *Client) sendDeleteExperimentItems(ctx context.Context, request OptExperimentItemsDelete) (res *DeleteExperimentItemsNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteExperimentItems"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/private/experiments/items/delete"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteExperimentItemsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/experiments/items/delete"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDeleteExperimentItemsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteExperimentItemsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteExperimentsById invokes deleteExperimentsById operation.
//
// Delete experiments by id.
//
// POST /v1/private/experiments/delete
func (c *Client) DeleteExperimentsById(ctx context.Context, request OptDeleteIdsHolder) error {
	_, err := c.sendDeleteExperimentsById(ctx, request)
	return err
}

func (c *Client) sendDeleteExperimentsById(ctx context.Context, request OptDeleteIdsHolder) (res *DeleteExperimentsByIdNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteExperimentsById"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/private/experiments/delete"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteExperimentsByIdOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/experiments/delete"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDeleteExperimentsByIdRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteExperimentsByIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteFeedbackDefinitionById invokes deleteFeedbackDefinitionById operation.
//
// Delete feedback definition by id.
//
// DELETE /v1/private/feedback-definitions/{id}
func (c *Client) DeleteFeedbackDefinitionById(ctx context.Context, params DeleteFeedbackDefinitionByIdParams) (DeleteFeedbackDefinitionByIdRes, error) {
	res, err := c.sendDeleteFeedbackDefinitionById(ctx, params)
	return res, err
}

func (c *Client) sendDeleteFeedbackDefinitionById(ctx context.Context, params DeleteFeedbackDefinitionByIdParams) (res DeleteFeedbackDefinitionByIdRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteFeedbackDefinitionById"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/v1/private/feedback-definitions/{id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteFeedbackDefinitionByIdOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/private/feedback-definitions/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteFeedbackDefinitionByIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteFeedbackDefinitionsBatch invokes deleteFeedbackDefinitionsBatch operation.
//
// Delete feedback definitions batch.
//
// POST /v1/private/feedback-definitions/delete
func (c *Client) DeleteFeedbackDefinitionsBatch(ctx context.Context, request OptBatchDelete) (DeleteFeedbackDefinitionsBatchRes, error) {
	res, err := c.sendDeleteFeedbackDefinitionsBatch(ctx, request)
	return res, err
}

func (c *Client) sendDeleteFeedbackDefinitionsBatch(ctx context.Context, request OptBatchDelete) (res DeleteFeedbackDefinitionsBatchRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteFeedbackDefinitionsBatch"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/private/feedback-definitions/delete"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteFeedbackDefinitionsBatchOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/feedback-definitions/delete"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDeleteFeedbackDefinitionsBatchRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteFeedbackDefinitionsBatchResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteLlmProviderApiKeysBatch invokes deleteLlmProviderApiKeysBatch operation.
//
// Delete LLM Provider's ApiKeys batch.
//
// POST /v1/private/llm-provider-key/delete
func (c *Client) DeleteLlmProviderApiKeysBatch(ctx context.Context, request OptBatchDelete) error {
	_, err := c.sendDeleteLlmProviderApiKeysBatch(ctx, request)
	return err
}

func (c *Client) sendDeleteLlmProviderApiKeysBatch(ctx context.Context, request OptBatchDelete) (res *DeleteLlmProviderApiKeysBatchNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteLlmProviderApiKeysBatch"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/private/llm-provider-key/delete"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteLlmProviderApiKeysBatchOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/llm-provider-key/delete"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDeleteLlmProviderApiKeysBatchRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteLlmProviderApiKeysBatchResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteOptimizationsById invokes deleteOptimizationsById operation.
//
// Delete optimizations by id.
//
// POST /v1/private/optimizations/delete
func (c *Client) DeleteOptimizationsById(ctx context.Context, request OptDeleteIdsHolder) error {
	_, err := c.sendDeleteOptimizationsById(ctx, request)
	return err
}

func (c *Client) sendDeleteOptimizationsById(ctx context.Context, request OptDeleteIdsHolder) (res *DeleteOptimizationsByIdNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteOptimizationsById"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/private/optimizations/delete"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteOptimizationsByIdOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/optimizations/delete"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDeleteOptimizationsByIdRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteOptimizationsByIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteProjectById invokes deleteProjectById operation.
//
// Delete project by id.
//
// DELETE /v1/private/projects/{id}
func (c *Client) DeleteProjectById(ctx context.Context, params DeleteProjectByIdParams) (DeleteProjectByIdRes, error) {
	res, err := c.sendDeleteProjectById(ctx, params)
	return res, err
}

func (c *Client) sendDeleteProjectById(ctx context.Context, params DeleteProjectByIdParams) (res DeleteProjectByIdRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteProjectById"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/v1/private/projects/{id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteProjectByIdOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/private/projects/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteProjectByIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteProjectsBatch invokes deleteProjectsBatch operation.
//
// Delete projects batch.
//
// POST /v1/private/projects/delete
func (c *Client) DeleteProjectsBatch(ctx context.Context, request OptBatchDelete) error {
	_, err := c.sendDeleteProjectsBatch(ctx, request)
	return err
}

func (c *Client) sendDeleteProjectsBatch(ctx context.Context, request OptBatchDelete) (res *DeleteProjectsBatchNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteProjectsBatch"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/private/projects/delete"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteProjectsBatchOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/projects/delete"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDeleteProjectsBatchRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteProjectsBatchResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeletePrompt invokes deletePrompt operation.
//
// Delete prompt.
//
// DELETE /v1/private/prompts/{id}
func (c *Client) DeletePrompt(ctx context.Context, params DeletePromptParams) error {
	_, err := c.sendDeletePrompt(ctx, params)
	return err
}

func (c *Client) sendDeletePrompt(ctx context.Context, params DeletePromptParams) (res *DeletePromptNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deletePrompt"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/v1/private/prompts/{id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeletePromptOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/private/prompts/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeletePromptResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeletePromptsBatch invokes deletePromptsBatch operation.
//
// Delete prompts batch.
//
// POST /v1/private/prompts/delete
func (c *Client) DeletePromptsBatch(ctx context.Context, request OptBatchDelete) error {
	_, err := c.sendDeletePromptsBatch(ctx, request)
	return err
}

func (c *Client) sendDeletePromptsBatch(ctx context.Context, request OptBatchDelete) (res *DeletePromptsBatchNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deletePromptsBatch"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/private/prompts/delete"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeletePromptsBatchOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/prompts/delete"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDeletePromptsBatchRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeletePromptsBatchResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteSpanById invokes deleteSpanById operation.
//
// Delete span by id.
//
// DELETE /v1/private/spans/{id}
func (c *Client) DeleteSpanById(ctx context.Context, params DeleteSpanByIdParams) (DeleteSpanByIdRes, error) {
	res, err := c.sendDeleteSpanById(ctx, params)
	return res, err
}

func (c *Client) sendDeleteSpanById(ctx context.Context, params DeleteSpanByIdParams) (res DeleteSpanByIdRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteSpanById"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/v1/private/spans/{id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteSpanByIdOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/private/spans/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteSpanByIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteSpanComments invokes deleteSpanComments operation.
//
// Delete span comments.
//
// POST /v1/private/spans/comments/delete
func (c *Client) DeleteSpanComments(ctx context.Context, request OptBatchDelete) error {
	_, err := c.sendDeleteSpanComments(ctx, request)
	return err
}

func (c *Client) sendDeleteSpanComments(ctx context.Context, request OptBatchDelete) (res *DeleteSpanCommentsNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteSpanComments"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/private/spans/comments/delete"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteSpanCommentsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/spans/comments/delete"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDeleteSpanCommentsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteSpanCommentsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteSpanFeedbackScore invokes deleteSpanFeedbackScore operation.
//
// Delete span feedback score.
//
// POST /v1/private/spans/{id}/feedback-scores/delete
func (c *Client) DeleteSpanFeedbackScore(ctx context.Context, request OptDeleteFeedbackScore, params DeleteSpanFeedbackScoreParams) error {
	_, err := c.sendDeleteSpanFeedbackScore(ctx, request, params)
	return err
}

func (c *Client) sendDeleteSpanFeedbackScore(ctx context.Context, request OptDeleteFeedbackScore, params DeleteSpanFeedbackScoreParams) (res *DeleteSpanFeedbackScoreNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteSpanFeedbackScore"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/private/spans/{id}/feedback-scores/delete"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteSpanFeedbackScoreOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/private/spans/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/feedback-scores/delete"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDeleteSpanFeedbackScoreRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteSpanFeedbackScoreResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteThreadComments invokes deleteThreadComments operation.
//
// Delete thread comments.
//
// POST /v1/private/traces/threads/comments/delete
func (c *Client) DeleteThreadComments(ctx context.Context, request OptBatchDelete) error {
	_, err := c.sendDeleteThreadComments(ctx, request)
	return err
}

func (c *Client) sendDeleteThreadComments(ctx context.Context, request OptBatchDelete) (res *DeleteThreadCommentsNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteThreadComments"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/private/traces/threads/comments/delete"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteThreadCommentsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/traces/threads/comments/delete"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDeleteThreadCommentsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteThreadCommentsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteThreadFeedbackScores invokes deleteThreadFeedbackScores operation.
//
// Delete thread feedback scores.
//
// POST /v1/private/traces/threads/feedback-scores/delete
func (c *Client) DeleteThreadFeedbackScores(ctx context.Context, request OptDeleteThreadFeedbackScores) error {
	_, err := c.sendDeleteThreadFeedbackScores(ctx, request)
	return err
}

func (c *Client) sendDeleteThreadFeedbackScores(ctx context.Context, request OptDeleteThreadFeedbackScores) (res *DeleteThreadFeedbackScoresNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteThreadFeedbackScores"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/private/traces/threads/feedback-scores/delete"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteThreadFeedbackScoresOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/traces/threads/feedback-scores/delete"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDeleteThreadFeedbackScoresRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteThreadFeedbackScoresResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteTraceById invokes deleteTraceById operation.
//
// Delete trace by id.
//
// DELETE /v1/private/traces/{id}
func (c *Client) DeleteTraceById(ctx context.Context, params DeleteTraceByIdParams) error {
	_, err := c.sendDeleteTraceById(ctx, params)
	return err
}

func (c *Client) sendDeleteTraceById(ctx context.Context, params DeleteTraceByIdParams) (res *DeleteTraceByIdNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteTraceById"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/v1/private/traces/{id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteTraceByIdOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/private/traces/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteTraceByIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteTraceComments invokes deleteTraceComments operation.
//
// Delete trace comments.
//
// POST /v1/private/traces/comments/delete
func (c *Client) DeleteTraceComments(ctx context.Context, request OptBatchDelete) error {
	_, err := c.sendDeleteTraceComments(ctx, request)
	return err
}

func (c *Client) sendDeleteTraceComments(ctx context.Context, request OptBatchDelete) (res *DeleteTraceCommentsNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteTraceComments"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/private/traces/comments/delete"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteTraceCommentsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/traces/comments/delete"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDeleteTraceCommentsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteTraceCommentsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteTraceFeedbackScore invokes deleteTraceFeedbackScore operation.
//
// Delete trace feedback score.
//
// POST /v1/private/traces/{id}/feedback-scores/delete
func (c *Client) DeleteTraceFeedbackScore(ctx context.Context, request OptDeleteFeedbackScore, params DeleteTraceFeedbackScoreParams) error {
	_, err := c.sendDeleteTraceFeedbackScore(ctx, request, params)
	return err
}

func (c *Client) sendDeleteTraceFeedbackScore(ctx context.Context, request OptDeleteFeedbackScore, params DeleteTraceFeedbackScoreParams) (res *DeleteTraceFeedbackScoreNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteTraceFeedbackScore"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/private/traces/{id}/feedback-scores/delete"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteTraceFeedbackScoreOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/private/traces/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/feedback-scores/delete"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDeleteTraceFeedbackScoreRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteTraceFeedbackScoreResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteTraceThreads invokes deleteTraceThreads operation.
//
// Delete trace threads.
//
// POST /v1/private/traces/threads/delete
func (c *Client) DeleteTraceThreads(ctx context.Context, request OptDeleteTraceThreads) error {
	_, err := c.sendDeleteTraceThreads(ctx, request)
	return err
}

func (c *Client) sendDeleteTraceThreads(ctx context.Context, request OptDeleteTraceThreads) (res *DeleteTraceThreadsNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteTraceThreads"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/private/traces/threads/delete"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteTraceThreadsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/traces/threads/delete"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDeleteTraceThreadsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteTraceThreadsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteTraces invokes deleteTraces operation.
//
// Delete traces.
//
// POST /v1/private/traces/delete
func (c *Client) DeleteTraces(ctx context.Context, request OptBatchDelete) error {
	_, err := c.sendDeleteTraces(ctx, request)
	return err
}

func (c *Client) sendDeleteTraces(ctx context.Context, request OptBatchDelete) (res *DeleteTracesNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteTraces"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/private/traces/delete"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteTracesOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/traces/delete"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDeleteTracesRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteTracesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteVersionTag invokes deleteVersionTag operation.
//
// Remove a tag from a dataset version. The version itself is not deleted, only the tag reference.
//
// DELETE /v1/private/datasets/{id}/versions/{versionHash}/tags/{tag}
func (c *Client) DeleteVersionTag(ctx context.Context, params DeleteVersionTagParams) error {
	_, err := c.sendDeleteVersionTag(ctx, params)
	return err
}

func (c *Client) sendDeleteVersionTag(ctx context.Context, params DeleteVersionTagParams) (res *DeleteVersionTagNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteVersionTag"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/v1/private/datasets/{id}/versions/{versionHash}/tags/{tag}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteVersionTagOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/v1/private/datasets/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/versions/"
	{
		// Encode "versionHash" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "versionHash",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.VersionHash))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/tags/"
	{
		// Encode "tag" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "tag",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Tag))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteVersionTagResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteWorkspaceConfiguration invokes deleteWorkspaceConfiguration operation.
//
// Delete workspace configuration.
//
// DELETE /v1/private/workspaces/configurations
func (c *Client) DeleteWorkspaceConfiguration(ctx context.Context) (DeleteWorkspaceConfigurationRes, error) {
	res, err := c.sendDeleteWorkspaceConfiguration(ctx)
	return res, err
}

func (c *Client) sendDeleteWorkspaceConfiguration(ctx context.Context) (res DeleteWorkspaceConfigurationRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("deleteWorkspaceConfiguration"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/v1/private/workspaces/configurations"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteWorkspaceConfigurationOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/workspaces/configurations"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteWorkspaceConfigurationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EvaluateSpans invokes evaluateSpans operation.
//
// Manually trigger evaluation rules on selected spans. Bypasses sampling and enqueues all specified
// spans for evaluation.
//
// POST /v1/private/manual-evaluation/spans
func (c *Client) EvaluateSpans(ctx context.Context, request OptManualEvaluationRequest) (EvaluateSpansRes, error) {
	res, err := c.sendEvaluateSpans(ctx, request)
	return res, err
}

func (c *Client) sendEvaluateSpans(ctx context.Context, request OptManualEvaluationRequest) (res EvaluateSpansRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("evaluateSpans"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/private/manual-evaluation/spans"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, EvaluateSpansOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/manual-evaluation/spans"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeEvaluateSpansRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeEvaluateSpansResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EvaluateThreads invokes evaluateThreads operation.
//
// Manually trigger evaluation rules on selected threads. Bypasses sampling and enqueues all
// specified threads for evaluation.
//
// POST /v1/private/manual-evaluation/threads
func (c *Client) EvaluateThreads(ctx context.Context, request OptManualEvaluationRequest) (EvaluateThreadsRes, error) {
	res, err := c.sendEvaluateThreads(ctx, request)
	return res, err
}

func (c *Client) sendEvaluateThreads(ctx context.Context, request OptManualEvaluationRequest) (res EvaluateThreadsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("evaluateThreads"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/private/manual-evaluation/threads"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, EvaluateThreadsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/manual-evaluation/threads"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeEvaluateThreadsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeEvaluateThreadsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EvaluateTraces invokes evaluateTraces operation.
//
// Manually trigger evaluation rules on selected traces. Bypasses sampling and enqueues all specified
// traces for evaluation.
//
// POST /v1/private/manual-evaluation/traces
func (c *Client) EvaluateTraces(ctx context.Context, request OptManualEvaluationRequest) (EvaluateTracesRes, error) {
	res, err := c.sendEvaluateTraces(ctx, request)
	return res, err
}

func (c *Client) sendEvaluateTraces(ctx context.Context, request OptManualEvaluationRequest) (res EvaluateTracesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("evaluateTraces"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/private/manual-evaluation/traces"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, EvaluateTracesOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/manual-evaluation/traces"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeEvaluateTracesRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeEvaluateTracesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ExpandDataset invokes expandDataset operation.
//
// Generate synthetic dataset samples using LLM based on existing data patterns.
//
// POST /v1/private/datasets/{id}/expansions
func (c *Client) ExpandDataset(ctx context.Context, request OptDatasetExpansionWrite, params ExpandDatasetParams) (*DatasetExpansionResponse, error) {
	res, err := c.sendExpandDataset(ctx, request, params)
	return res, err
}

func (c *Client) sendExpandDataset(ctx context.Context, request OptDatasetExpansionWrite, params ExpandDatasetParams) (res *DatasetExpansionResponse, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("expandDataset"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/private/datasets/{id}/expansions"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ExpandDatasetOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/private/datasets/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/expansions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeExpandDatasetRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeExpandDatasetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ExperimentItemsBulk invokes experimentItemsBulk operation.
//
// Record experiment items in bulk with traces, spans, and feedback scores. Maximum request size is
// 4MB.
//
// PUT /v1/private/experiments/items/bulk
func (c *Client) ExperimentItemsBulk(ctx context.Context, request OptExperimentItemBulkUploadExperimentItemBulkWriteView) (ExperimentItemsBulkRes, error) {
	res, err := c.sendExperimentItemsBulk(ctx, request)
	return res, err
}

func (c *Client) sendExperimentItemsBulk(ctx context.Context, request OptExperimentItemBulkUploadExperimentItemBulkWriteView) (res ExperimentItemsBulkRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("experimentItemsBulk"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.URLTemplateKey.String("/v1/private/experiments/items/bulk"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ExperimentItemsBulkOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/experiments/items/bulk"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeExperimentItemsBulkRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeExperimentItemsBulkResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// FindAlerts invokes findAlerts operation.
//
// Find alerts.
//
// GET /v1/private/alerts
func (c *Client) FindAlerts(ctx context.Context, params FindAlertsParams) (*AlertPagePublic, error) {
	res, err := c.sendFindAlerts(ctx, params)
	return res, err
}

func (c *Client) sendFindAlerts(ctx context.Context, params FindAlertsParams) (res *AlertPagePublic, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("findAlerts"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/private/alerts"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, FindAlertsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/alerts"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Size.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sorting" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sorting",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Sorting.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filters" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filters",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Filters.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeFindAlertsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// FindAnnotationQueues invokes findAnnotationQueues operation.
//
// Find annotation queues with filtering and sorting.
//
// GET /v1/private/annotation-queues
func (c *Client) FindAnnotationQueues(ctx context.Context, params FindAnnotationQueuesParams) (*AnnotationQueuePagePublic, error) {
	res, err := c.sendFindAnnotationQueues(ctx, params)
	return res, err
}

func (c *Client) sendFindAnnotationQueues(ctx context.Context, params FindAnnotationQueuesParams) (res *AnnotationQueuePagePublic, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("findAnnotationQueues"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/private/annotation-queues"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, FindAnnotationQueuesOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/annotation-queues"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Size.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "name" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Name.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filters" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filters",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Filters.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sorting" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sorting",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Sorting.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeFindAnnotationQueuesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// FindDashboards invokes findDashboards operation.
//
// Find dashboards in a workspace.
//
// GET /v1/private/dashboards
func (c *Client) FindDashboards(ctx context.Context, params FindDashboardsParams) (*DashboardPagePublic, error) {
	res, err := c.sendFindDashboards(ctx, params)
	return res, err
}

func (c *Client) sendFindDashboards(ctx context.Context, params FindDashboardsParams) (res *DashboardPagePublic, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("findDashboards"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/private/dashboards"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, FindDashboardsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/dashboards"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Size.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "name" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Name.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sorting" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sorting",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Sorting.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeFindDashboardsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// FindDatasetItemsWithExperimentItems invokes findDatasetItemsWithExperimentItems operation.
//
// Find dataset items with experiment items.
//
// GET /v1/private/datasets/{id}/items/experiments/items
func (c *Client) FindDatasetItemsWithExperimentItems(ctx context.Context, params FindDatasetItemsWithExperimentItemsParams) (*DatasetItemPageCompare, error) {
	res, err := c.sendFindDatasetItemsWithExperimentItems(ctx, params)
	return res, err
}

func (c *Client) sendFindDatasetItemsWithExperimentItems(ctx context.Context, params FindDatasetItemsWithExperimentItemsParams) (res *DatasetItemPageCompare, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("findDatasetItemsWithExperimentItems"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/private/datasets/{id}/items/experiments/items"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, FindDatasetItemsWithExperimentItemsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/private/datasets/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/items/experiments/items"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Size.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "experiment_ids" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "experiment_ids",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.ExperimentIds))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filters" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filters",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Filters.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sorting" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sorting",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Sorting.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "search" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "search",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Search.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "truncate" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "truncate",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Truncate.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeFindDatasetItemsWithExperimentItemsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// FindDatasets invokes findDatasets operation.
//
// Find datasets.
//
// GET /v1/private/datasets
func (c *Client) FindDatasets(ctx context.Context, params FindDatasetsParams) (*DatasetPagePublic, error) {
	res, err := c.sendFindDatasets(ctx, params)
	return res, err
}

func (c *Client) sendFindDatasets(ctx context.Context, params FindDatasetsParams) (res *DatasetPagePublic, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("findDatasets"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/private/datasets"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, FindDatasetsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/datasets"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Size.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "with_experiments_only" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "with_experiments_only",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithExperimentsOnly.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "with_optimizations_only" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "with_optimizations_only",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithOptimizationsOnly.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "prompt_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "prompt_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PromptID.Get(); ok {
				return e.EncodeValue(conv.UUIDToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "name" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Name.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sorting" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sorting",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Sorting.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filters" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filters",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Filters.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeFindDatasetsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// FindEvaluators invokes findEvaluators operation.
//
// Find project Evaluators.
//
// GET /v1/private/automations/evaluators
func (c *Client) FindEvaluators(ctx context.Context, params FindEvaluatorsParams) (*AutomationRuleEvaluatorPagePublic, error) {
	res, err := c.sendFindEvaluators(ctx, params)
	return res, err
}

func (c *Client) sendFindEvaluators(ctx context.Context, params FindEvaluatorsParams) (res *AutomationRuleEvaluatorPagePublic, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("findEvaluators"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/private/automations/evaluators"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, FindEvaluatorsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/automations/evaluators"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "project_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "project_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ProjectID.Get(); ok {
				return e.EncodeValue(conv.UUIDToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "name" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Name.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filters" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filters",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Filters.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sorting" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sorting",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Sorting.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Size.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeFindEvaluatorsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// FindExperimentGroups invokes findExperimentGroups operation.
//
// Find experiments grouped by specified fields.
//
// GET /v1/private/experiments/groups
func (c *Client) FindExperimentGroups(ctx context.Context, params FindExperimentGroupsParams) (FindExperimentGroupsRes, error) {
	res, err := c.sendFindExperimentGroups(ctx, params)
	return res, err
}

func (c *Client) sendFindExperimentGroups(ctx context.Context, params FindExperimentGroupsParams) (res FindExperimentGroupsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("findExperimentGroups"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/private/experiments/groups"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, FindExperimentGroupsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/experiments/groups"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "groups" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "groups",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Groups.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "types" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "types",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Types.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "name" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Name.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filters" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filters",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Filters.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeFindExperimentGroupsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// FindExperimentGroupsAggregations invokes findExperimentGroupsAggregations operation.
//
// Find experiments grouped by specified fields with aggregation metrics.
//
// GET /v1/private/experiments/groups/aggregations
func (c *Client) FindExperimentGroupsAggregations(ctx context.Context, params FindExperimentGroupsAggregationsParams) (FindExperimentGroupsAggregationsRes, error) {
	res, err := c.sendFindExperimentGroupsAggregations(ctx, params)
	return res, err
}

func (c *Client) sendFindExperimentGroupsAggregations(ctx context.Context, params FindExperimentGroupsAggregationsParams) (res FindExperimentGroupsAggregationsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("findExperimentGroupsAggregations"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/private/experiments/groups/aggregations"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, FindExperimentGroupsAggregationsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/experiments/groups/aggregations"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "groups" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "groups",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Groups.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "types" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "types",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Types.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "name" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Name.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filters" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filters",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Filters.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeFindExperimentGroupsAggregationsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// FindExperiments invokes findExperiments operation.
//
// Find experiments.
//
// GET /v1/private/experiments
func (c *Client) FindExperiments(ctx context.Context, params FindExperimentsParams) (FindExperimentsRes, error) {
	res, err := c.sendFindExperiments(ctx, params)
	return res, err
}

func (c *Client) sendFindExperiments(ctx context.Context, params FindExperimentsParams) (res FindExperimentsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("findExperiments"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/private/experiments"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, FindExperimentsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/experiments"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Size.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "datasetId" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "datasetId",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.DatasetId.Get(); ok {
				return e.EncodeValue(conv.UUIDToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "optimization_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "optimization_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.OptimizationID.Get(); ok {
				return e.EncodeValue(conv.UUIDToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "types" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "types",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Types.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "name" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Name.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "dataset_deleted" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "dataset_deleted",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.DatasetDeleted.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "prompt_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "prompt_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PromptID.Get(); ok {
				return e.EncodeValue(conv.UUIDToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sorting" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sorting",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Sorting.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filters" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filters",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Filters.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeFindExperimentsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// FindFeedbackDefinitions invokes findFeedbackDefinitions operation.
//
// Find Feedback definitions.
//
// GET /v1/private/feedback-definitions
func (c *Client) FindFeedbackDefinitions(ctx context.Context, params FindFeedbackDefinitionsParams) (*FeedbackDefinitionPagePublic, error) {
	res, err := c.sendFindFeedbackDefinitions(ctx, params)
	return res, err
}

func (c *Client) sendFindFeedbackDefinitions(ctx context.Context, params FindFeedbackDefinitionsParams) (res *FeedbackDefinitionPagePublic, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("findFeedbackDefinitions"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/private/feedback-definitions"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, FindFeedbackDefinitionsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/feedback-definitions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Size.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "name" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Name.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Type.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeFindFeedbackDefinitionsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// FindFeedbackScoreNames invokes findFeedbackScoreNames operation.
//
// Find Feedback Score names.
//
// GET /v1/private/experiments/feedback-scores/names
func (c *Client) FindFeedbackScoreNames(ctx context.Context, params FindFeedbackScoreNamesParams) ([]string, error) {
	res, err := c.sendFindFeedbackScoreNames(ctx, params)
	return res, err
}

func (c *Client) sendFindFeedbackScoreNames(ctx context.Context, params FindFeedbackScoreNamesParams) (res []string, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("findFeedbackScoreNames"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/private/experiments/feedback-scores/names"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, FindFeedbackScoreNamesOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/experiments/feedback-scores/names"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "experiment_ids" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "experiment_ids",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ExperimentIds.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeFindFeedbackScoreNamesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// FindFeedbackScoreNames1 invokes findFeedbackScoreNames_1 operation.
//
// Find Feedback Score names.
//
// GET /v1/private/spans/feedback-scores/names
func (c *Client) FindFeedbackScoreNames1(ctx context.Context, params FindFeedbackScoreNames1Params) ([]string, error) {
	res, err := c.sendFindFeedbackScoreNames1(ctx, params)
	return res, err
}

func (c *Client) sendFindFeedbackScoreNames1(ctx context.Context, params FindFeedbackScoreNames1Params) (res []string, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("findFeedbackScoreNames_1"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/private/spans/feedback-scores/names"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, FindFeedbackScoreNames1Operation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/spans/feedback-scores/names"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "project_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "project_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ProjectID.Get(); ok {
				return e.EncodeValue(conv.UUIDToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Type.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeFindFeedbackScoreNames1Response(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// FindFeedbackScoreNames2 invokes findFeedbackScoreNames_2 operation.
//
// Find Feedback Score names.
//
// GET /v1/private/traces/feedback-scores/names
func (c *Client) FindFeedbackScoreNames2(ctx context.Context, params FindFeedbackScoreNames2Params) ([]string, error) {
	res, err := c.sendFindFeedbackScoreNames2(ctx, params)
	return res, err
}

func (c *Client) sendFindFeedbackScoreNames2(ctx context.Context, params FindFeedbackScoreNames2Params) (res []string, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("findFeedbackScoreNames_2"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/private/traces/feedback-scores/names"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, FindFeedbackScoreNames2Operation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/traces/feedback-scores/names"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "project_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "project_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ProjectID.Get(); ok {
				return e.EncodeValue(conv.UUIDToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeFindFeedbackScoreNames2Response(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// FindFeedbackScoreNamesByProjectIds invokes findFeedbackScoreNamesByProjectIds operation.
//
// Find Feedback Score names By Project Ids.
//
// GET /v1/private/projects/feedback-scores/names
func (c *Client) FindFeedbackScoreNamesByProjectIds(ctx context.Context, params FindFeedbackScoreNamesByProjectIdsParams) (*FeedbackScoreNames, error) {
	res, err := c.sendFindFeedbackScoreNamesByProjectIds(ctx, params)
	return res, err
}

func (c *Client) sendFindFeedbackScoreNamesByProjectIds(ctx context.Context, params FindFeedbackScoreNamesByProjectIdsParams) (res *FeedbackScoreNames, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("findFeedbackScoreNamesByProjectIds"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/private/projects/feedback-scores/names"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, FindFeedbackScoreNamesByProjectIdsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/projects/feedback-scores/names"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "project_ids" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "project_ids",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ProjectIds.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeFindFeedbackScoreNamesByProjectIdsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// FindLlmProviderKeys invokes findLlmProviderKeys operation.
//
// Find LLM Provider's ApiKeys.
//
// GET /v1/private/llm-provider-key
func (c *Client) FindLlmProviderKeys(ctx context.Context) (*ProviderApiKeyPagePublic, error) {
	res, err := c.sendFindLlmProviderKeys(ctx)
	return res, err
}

func (c *Client) sendFindLlmProviderKeys(ctx context.Context) (res *ProviderApiKeyPagePublic, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("findLlmProviderKeys"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/private/llm-provider-key"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, FindLlmProviderKeysOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/llm-provider-key"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeFindLlmProviderKeysResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// FindOptimizations invokes findOptimizations operation.
//
// Find optimizations.
//
// GET /v1/private/optimizations
func (c *Client) FindOptimizations(ctx context.Context, params FindOptimizationsParams) (FindOptimizationsRes, error) {
	res, err := c.sendFindOptimizations(ctx, params)
	return res, err
}

func (c *Client) sendFindOptimizations(ctx context.Context, params FindOptimizationsParams) (res FindOptimizationsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("findOptimizations"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/private/optimizations"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, FindOptimizationsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/optimizations"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Size.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "dataset_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "dataset_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.DatasetID.Get(); ok {
				return e.EncodeValue(conv.UUIDToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "name" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Name.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "dataset_deleted" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "dataset_deleted",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.DatasetDeleted.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filters" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filters",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Filters.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeFindOptimizationsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// FindProjects invokes findProjects operation.
//
// Find projects.
//
// GET /v1/private/projects
func (c *Client) FindProjects(ctx context.Context, params FindProjectsParams) (*ProjectPagePublic, error) {
	res, err := c.sendFindProjects(ctx, params)
	return res, err
}

func (c *Client) sendFindProjects(ctx context.Context, params FindProjectsParams) (res *ProjectPagePublic, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("findProjects"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/private/projects"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, FindProjectsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/projects"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Size.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "name" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Name.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sorting" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sorting",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Sorting.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeFindProjectsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// FindStudioOptimizations invokes findStudioOptimizations operation.
//
// Find Studio optimizations.
//
// GET /v1/private/optimizations/studio
func (c *Client) FindStudioOptimizations(ctx context.Context, params FindStudioOptimizationsParams) (FindStudioOptimizationsRes, error) {
	res, err := c.sendFindStudioOptimizations(ctx, params)
	return res, err
}

func (c *Client) sendFindStudioOptimizations(ctx context.Context, params FindStudioOptimizationsParams) (res FindStudioOptimizationsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("findStudioOptimizations"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/private/optimizations/studio"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, FindStudioOptimizationsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/optimizations/studio"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Size.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "dataset_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "dataset_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.DatasetID.Get(); ok {
				return e.EncodeValue(conv.UUIDToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "name" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Name.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "dataset_deleted" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "dataset_deleted",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.DatasetDeleted.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filters" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filters",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Filters.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeFindStudioOptimizationsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// FindTraceThreadsFeedbackScoreNames invokes findTraceThreadsFeedbackScoreNames operation.
//
// Find Trace Threads Feedback Score names.
//
// GET /v1/private/traces/threads/feedback-scores/names
func (c *Client) FindTraceThreadsFeedbackScoreNames(ctx context.Context, params FindTraceThreadsFeedbackScoreNamesParams) ([]string, error) {
	res, err := c.sendFindTraceThreadsFeedbackScoreNames(ctx, params)
	return res, err
}

func (c *Client) sendFindTraceThreadsFeedbackScoreNames(ctx context.Context, params FindTraceThreadsFeedbackScoreNamesParams) (res []string, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("findTraceThreadsFeedbackScoreNames"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/private/traces/threads/feedback-scores/names"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, FindTraceThreadsFeedbackScoreNamesOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/traces/threads/feedback-scores/names"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "project_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "project_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ProjectID.Get(); ok {
				return e.EncodeValue(conv.UUIDToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeFindTraceThreadsFeedbackScoreNamesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// FinishExperiments invokes finishExperiments operation.
//
// Finish experiments and trigger alert events.
//
// POST /v1/private/experiments/finish
func (c *Client) FinishExperiments(ctx context.Context, request OptDeleteIdsHolder) (FinishExperimentsRes, error) {
	res, err := c.sendFinishExperiments(ctx, request)
	return res, err
}

func (c *Client) sendFinishExperiments(ctx context.Context, request OptDeleteIdsHolder) (res FinishExperimentsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("finishExperiments"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/private/experiments/finish"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, FinishExperimentsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/experiments/finish"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeFinishExperimentsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeFinishExperimentsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetAlertById invokes getAlertById operation.
//
// Get Alert by id.
//
// GET /v1/private/alerts/{id}
func (c *Client) GetAlertById(ctx context.Context, params GetAlertByIdParams) (GetAlertByIdRes, error) {
	res, err := c.sendGetAlertById(ctx, params)
	return res, err
}

func (c *Client) sendGetAlertById(ctx context.Context, params GetAlertByIdParams) (res GetAlertByIdRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getAlertById"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/private/alerts/{id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetAlertByIdOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/private/alerts/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetAlertByIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetAnnotationQueueById invokes getAnnotationQueueById operation.
//
// Get annotation queue by id.
//
// GET /v1/private/annotation-queues/{id}
func (c *Client) GetAnnotationQueueById(ctx context.Context, params GetAnnotationQueueByIdParams) (GetAnnotationQueueByIdRes, error) {
	res, err := c.sendGetAnnotationQueueById(ctx, params)
	return res, err
}

func (c *Client) sendGetAnnotationQueueById(ctx context.Context, params GetAnnotationQueueByIdParams) (res GetAnnotationQueueByIdRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getAnnotationQueueById"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/private/annotation-queues/{id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetAnnotationQueueByIdOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/private/annotation-queues/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetAnnotationQueueByIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetCost invokes getCost operation.
//
// Get cost daily data.
//
// POST /v1/private/workspaces/costs
func (c *Client) GetCost(ctx context.Context, request OptWorkspaceMetricsSummaryRequest) (GetCostRes, error) {
	res, err := c.sendGetCost(ctx, request)
	return res, err
}

func (c *Client) sendGetCost(ctx context.Context, request OptWorkspaceMetricsSummaryRequest) (res GetCostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getCost"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/private/workspaces/costs"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetCostOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/workspaces/costs"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetCostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetCostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetDashboardById invokes getDashboardById operation.
//
// Get dashboard by id.
//
// GET /v1/private/dashboards/{dashboardId}
func (c *Client) GetDashboardById(ctx context.Context, params GetDashboardByIdParams) (GetDashboardByIdRes, error) {
	res, err := c.sendGetDashboardById(ctx, params)
	return res, err
}

func (c *Client) sendGetDashboardById(ctx context.Context, params GetDashboardByIdParams) (res GetDashboardByIdRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getDashboardById"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/private/dashboards/{dashboardId}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetDashboardByIdOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/private/dashboards/"
	{
		// Encode "dashboardId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "dashboardId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.DashboardId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetDashboardByIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetDatasetBiInfo invokes getDatasetBiInfo operation.
//
// Get datasets information for BI events per user per workspace.
//
// GET /v1/internal/usage/bi-datasets
func (c *Client) GetDatasetBiInfo(ctx context.Context) (*BiInformationResponse, error) {
	res, err := c.sendGetDatasetBiInfo(ctx)
	return res, err
}

func (c *Client) sendGetDatasetBiInfo(ctx context.Context) (res *BiInformationResponse, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getDatasetBiInfo"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/internal/usage/bi-datasets"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetDatasetBiInfoOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/internal/usage/bi-datasets"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetDatasetBiInfoResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetDatasetById invokes getDatasetById operation.
//
// Get dataset by id.
//
// GET /v1/private/datasets/{id}
func (c *Client) GetDatasetById(ctx context.Context, params GetDatasetByIdParams) (*DatasetPublic, error) {
	res, err := c.sendGetDatasetById(ctx, params)
	return res, err
}

func (c *Client) sendGetDatasetById(ctx context.Context, params GetDatasetByIdParams) (res *DatasetPublic, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getDatasetById"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/private/datasets/{id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetDatasetByIdOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/private/datasets/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetDatasetByIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetDatasetByIdentifier invokes getDatasetByIdentifier operation.
//
// Get dataset by name.
//
// POST /v1/private/datasets/retrieve
func (c *Client) GetDatasetByIdentifier(ctx context.Context, request OptDatasetIdentifierPublic) (*DatasetPublic, error) {
	res, err := c.sendGetDatasetByIdentifier(ctx, request)
	return res, err
}

func (c *Client) sendGetDatasetByIdentifier(ctx context.Context, request OptDatasetIdentifierPublic) (res *DatasetPublic, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getDatasetByIdentifier"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/private/datasets/retrieve"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetDatasetByIdentifierOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/datasets/retrieve"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetDatasetByIdentifierRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetDatasetByIdentifierResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetDatasetExperimentItemsStats invokes getDatasetExperimentItemsStats operation.
//
// Get experiment items stats for dataset.
//
// GET /v1/private/datasets/{id}/items/experiments/items/stats
func (c *Client) GetDatasetExperimentItemsStats(ctx context.Context, params GetDatasetExperimentItemsStatsParams) (*ProjectStatsPublic, error) {
	res, err := c.sendGetDatasetExperimentItemsStats(ctx, params)
	return res, err
}

func (c *Client) sendGetDatasetExperimentItemsStats(ctx context.Context, params GetDatasetExperimentItemsStatsParams) (res *ProjectStatsPublic, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getDatasetExperimentItemsStats"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/private/datasets/{id}/items/experiments/items/stats"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetDatasetExperimentItemsStatsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/private/datasets/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/items/experiments/items/stats"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "experiment_ids" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "experiment_ids",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.ExperimentIds))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filters" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filters",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Filters.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetDatasetExperimentItemsStatsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetDatasetItemById invokes getDatasetItemById operation.
//
// Get dataset item by id.
//
// GET /v1/private/datasets/items/{itemId}
func (c *Client) GetDatasetItemById(ctx context.Context, params GetDatasetItemByIdParams) (*DatasetItemPublic, error) {
	res, err := c.sendGetDatasetItemById(ctx, params)
	return res, err
}

func (c *Client) sendGetDatasetItemById(ctx context.Context, params GetDatasetItemByIdParams) (res *DatasetItemPublic, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getDatasetItemById"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/private/datasets/items/{itemId}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetDatasetItemByIdOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/private/datasets/items/"
	{
		// Encode "itemId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "itemId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ItemId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetDatasetItemByIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetDatasetItems invokes getDatasetItems operation.
//
// Get dataset items.
//
// GET /v1/private/datasets/{id}/items
func (c *Client) GetDatasetItems(ctx context.Context, params GetDatasetItemsParams) (*DatasetItemPagePublic, error) {
	res, err := c.sendGetDatasetItems(ctx, params)
	return res, err
}

func (c *Client) sendGetDatasetItems(ctx context.Context, params GetDatasetItemsParams) (res *DatasetItemPagePublic, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getDatasetItems"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/private/datasets/{id}/items"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetDatasetItemsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/private/datasets/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/items"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Size.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "version" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "version",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Version.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filters" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filters",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Filters.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "truncate" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "truncate",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Truncate.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetDatasetItemsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetDatasetItemsOutputColumns invokes getDatasetItemsOutputColumns operation.
//
// Get dataset items output columns.
//
// GET /v1/private/datasets/{id}/items/experiments/items/output/columns
func (c *Client) GetDatasetItemsOutputColumns(ctx context.Context, params GetDatasetItemsOutputColumnsParams) (*PageColumns, error) {
	res, err := c.sendGetDatasetItemsOutputColumns(ctx, params)
	return res, err
}

func (c *Client) sendGetDatasetItemsOutputColumns(ctx context.Context, params GetDatasetItemsOutputColumnsParams) (res *PageColumns, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getDatasetItemsOutputColumns"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/private/datasets/{id}/items/experiments/items/output/columns"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetDatasetItemsOutputColumnsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/private/datasets/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/items/experiments/items/output/columns"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "experiment_ids" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "experiment_ids",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ExperimentIds.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetDatasetItemsOutputColumnsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetEvaluatorById invokes getEvaluatorById operation.
//
// Get automation rule by id.
//
// GET /v1/private/automations/evaluators/{id}
func (c *Client) GetEvaluatorById(ctx context.Context, params GetEvaluatorByIdParams) (*AutomationRuleEvaluatorPublic, error) {
	res, err := c.sendGetEvaluatorById(ctx, params)
	return res, err
}

func (c *Client) sendGetEvaluatorById(ctx context.Context, params GetEvaluatorByIdParams) (res *AutomationRuleEvaluatorPublic, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getEvaluatorById"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/private/automations/evaluators/{id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetEvaluatorByIdOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/private/automations/evaluators/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "project_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "project_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ProjectID.Get(); ok {
				return e.EncodeValue(conv.UUIDToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetEvaluatorByIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetEvaluatorLogsById invokes getEvaluatorLogsById operation.
//
// Get automation rule evaluator logs by id.
//
// GET /v1/private/automations/evaluators/{id}/logs
func (c *Client) GetEvaluatorLogsById(ctx context.Context, params GetEvaluatorLogsByIdParams) (*LogPage, error) {
	res, err := c.sendGetEvaluatorLogsById(ctx, params)
	return res, err
}

func (c *Client) sendGetEvaluatorLogsById(ctx context.Context, params GetEvaluatorLogsByIdParams) (res *LogPage, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getEvaluatorLogsById"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/private/automations/evaluators/{id}/logs"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetEvaluatorLogsByIdOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/private/automations/evaluators/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/logs"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Size.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetEvaluatorLogsByIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetExperimentBiInfo invokes getExperimentBiInfo operation.
//
// Get experiments information for BI events per user per workspace.
//
// GET /v1/internal/usage/bi-experiments
func (c *Client) GetExperimentBiInfo(ctx context.Context) (*BiInformationResponse, error) {
	res, err := c.sendGetExperimentBiInfo(ctx)
	return res, err
}

func (c *Client) sendGetExperimentBiInfo(ctx context.Context) (res *BiInformationResponse, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getExperimentBiInfo"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/internal/usage/bi-experiments"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetExperimentBiInfoOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/internal/usage/bi-experiments"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetExperimentBiInfoResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetExperimentById invokes getExperimentById operation.
//
// Get experiment by id.
//
// GET /v1/private/experiments/{id}
func (c *Client) GetExperimentById(ctx context.Context, params GetExperimentByIdParams) (GetExperimentByIdRes, error) {
	res, err := c.sendGetExperimentById(ctx, params)
	return res, err
}

func (c *Client) sendGetExperimentById(ctx context.Context, params GetExperimentByIdParams) (res GetExperimentByIdRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getExperimentById"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/private/experiments/{id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetExperimentByIdOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/private/experiments/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetExperimentByIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetExperimentItemById invokes getExperimentItemById operation.
//
// Get experiment item by id.
//
// GET /v1/private/experiments/items/{id}
func (c *Client) GetExperimentItemById(ctx context.Context, params GetExperimentItemByIdParams) (GetExperimentItemByIdRes, error) {
	res, err := c.sendGetExperimentItemById(ctx, params)
	return res, err
}

func (c *Client) sendGetExperimentItemById(ctx context.Context, params GetExperimentItemByIdParams) (res GetExperimentItemByIdRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getExperimentItemById"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/private/experiments/items/{id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetExperimentItemByIdOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/private/experiments/items/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetExperimentItemByIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetFeedbackDefinitionById invokes getFeedbackDefinitionById operation.
//
// Get feedback definition by id.
//
// GET /v1/private/feedback-definitions/{id}
func (c *Client) GetFeedbackDefinitionById(ctx context.Context, params GetFeedbackDefinitionByIdParams) (*FeedbackPublic, error) {
	res, err := c.sendGetFeedbackDefinitionById(ctx, params)
	return res, err
}

func (c *Client) sendGetFeedbackDefinitionById(ctx context.Context, params GetFeedbackDefinitionByIdParams) (res *FeedbackPublic, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getFeedbackDefinitionById"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/private/feedback-definitions/{id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetFeedbackDefinitionByIdOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/private/feedback-definitions/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetFeedbackDefinitionByIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetLlmProviderApiKeyById invokes getLlmProviderApiKeyById operation.
//
// Get LLM Provider's ApiKey by id.
//
// GET /v1/private/llm-provider-key/{id}
func (c *Client) GetLlmProviderApiKeyById(ctx context.Context, params GetLlmProviderApiKeyByIdParams) (GetLlmProviderApiKeyByIdRes, error) {
	res, err := c.sendGetLlmProviderApiKeyById(ctx, params)
	return res, err
}

func (c *Client) sendGetLlmProviderApiKeyById(ctx context.Context, params GetLlmProviderApiKeyByIdParams) (res GetLlmProviderApiKeyByIdRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getLlmProviderApiKeyById"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/private/llm-provider-key/{id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetLlmProviderApiKeyByIdOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/private/llm-provider-key/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetLlmProviderApiKeyByIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetMetric invokes getMetric operation.
//
// Get metric daily data.
//
// Deprecated: schema marks this operation as deprecated.
//
// POST /v1/private/workspaces/metrics
func (c *Client) GetMetric(ctx context.Context, request OptWorkspaceMetricsSummaryRequest) (GetMetricRes, error) {
	res, err := c.sendGetMetric(ctx, request)
	return res, err
}

func (c *Client) sendGetMetric(ctx context.Context, request OptWorkspaceMetricsSummaryRequest) (res GetMetricRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getMetric"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/private/workspaces/metrics"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetMetricOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/workspaces/metrics"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetMetricRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetMetricResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetOptimizationById invokes getOptimizationById operation.
//
// Get optimization by id.
//
// GET /v1/private/optimizations/{id}
func (c *Client) GetOptimizationById(ctx context.Context, params GetOptimizationByIdParams) (GetOptimizationByIdRes, error) {
	res, err := c.sendGetOptimizationById(ctx, params)
	return res, err
}

func (c *Client) sendGetOptimizationById(ctx context.Context, params GetOptimizationByIdParams) (res GetOptimizationByIdRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getOptimizationById"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/private/optimizations/{id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetOptimizationByIdOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/private/optimizations/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetOptimizationByIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetProjectById invokes getProjectById operation.
//
// Get project by id.
//
// GET /v1/private/projects/{id}
func (c *Client) GetProjectById(ctx context.Context, params GetProjectByIdParams) (*ProjectPublic, error) {
	res, err := c.sendGetProjectById(ctx, params)
	return res, err
}

func (c *Client) sendGetProjectById(ctx context.Context, params GetProjectByIdParams) (res *ProjectPublic, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getProjectById"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/private/projects/{id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetProjectByIdOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/private/projects/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetProjectByIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetProjectMetrics invokes getProjectMetrics operation.
//
// Gets specified metrics for a project.
//
// POST /v1/private/projects/{id}/metrics
func (c *Client) GetProjectMetrics(ctx context.Context, request OptProjectMetricRequestPublic, params GetProjectMetricsParams) (GetProjectMetricsRes, error) {
	res, err := c.sendGetProjectMetrics(ctx, request, params)
	return res, err
}

func (c *Client) sendGetProjectMetrics(ctx context.Context, request OptProjectMetricRequestPublic, params GetProjectMetricsParams) (res GetProjectMetricsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getProjectMetrics"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/private/projects/{id}/metrics"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetProjectMetricsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/private/projects/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/metrics"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetProjectMetricsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetProjectMetricsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetProjectStats invokes getProjectStats operation.
//
// Get Project Stats.
//
// GET /v1/private/projects/stats
func (c *Client) GetProjectStats(ctx context.Context, params GetProjectStatsParams) (*ProjectStatsSummary, error) {
	res, err := c.sendGetProjectStats(ctx, params)
	return res, err
}

func (c *Client) sendGetProjectStats(ctx context.Context, params GetProjectStatsParams) (res *ProjectStatsSummary, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getProjectStats"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/private/projects/stats"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetProjectStatsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/projects/stats"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Size.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "name" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Name.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sorting" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sorting",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Sorting.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetProjectStatsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetPromptById invokes getPromptById operation.
//
// Get prompt by id.
//
// GET /v1/private/prompts/{id}
func (c *Client) GetPromptById(ctx context.Context, params GetPromptByIdParams) (GetPromptByIdRes, error) {
	res, err := c.sendGetPromptById(ctx, params)
	return res, err
}

func (c *Client) sendGetPromptById(ctx context.Context, params GetPromptByIdParams) (res GetPromptByIdRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getPromptById"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/private/prompts/{id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetPromptByIdOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/private/prompts/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetPromptByIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetPromptVersionById invokes getPromptVersionById operation.
//
// Get prompt version by id.
//
// GET /v1/private/prompts/versions/{versionId}
func (c *Client) GetPromptVersionById(ctx context.Context, params GetPromptVersionByIdParams) (GetPromptVersionByIdRes, error) {
	res, err := c.sendGetPromptVersionById(ctx, params)
	return res, err
}

func (c *Client) sendGetPromptVersionById(ctx context.Context, params GetPromptVersionByIdParams) (res GetPromptVersionByIdRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getPromptVersionById"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/private/prompts/versions/{versionId}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetPromptVersionByIdOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/private/prompts/versions/"
	{
		// Encode "versionId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "versionId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.VersionId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetPromptVersionByIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetPromptVersions invokes getPromptVersions operation.
//
// Get prompt versions.
//
// GET /v1/private/prompts/{id}/versions
func (c *Client) GetPromptVersions(ctx context.Context, params GetPromptVersionsParams) (*PromptVersionPagePublic, error) {
	res, err := c.sendGetPromptVersions(ctx, params)
	return res, err
}

func (c *Client) sendGetPromptVersions(ctx context.Context, params GetPromptVersionsParams) (res *PromptVersionPagePublic, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getPromptVersions"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/private/prompts/{id}/versions"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetPromptVersionsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/private/prompts/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/versions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Size.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "search" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "search",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Search.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sorting" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sorting",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Sorting.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filters" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filters",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Filters.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetPromptVersionsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetPrompts invokes getPrompts operation.
//
// Get prompts.
//
// GET /v1/private/prompts
func (c *Client) GetPrompts(ctx context.Context, params GetPromptsParams) (*PromptPagePublic, error) {
	res, err := c.sendGetPrompts(ctx, params)
	return res, err
}

func (c *Client) sendGetPrompts(ctx context.Context, params GetPromptsParams) (res *PromptPagePublic, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getPrompts"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/private/prompts"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetPromptsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/prompts"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Size.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "name" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Name.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sorting" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sorting",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Sorting.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filters" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filters",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Filters.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetPromptsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetServiceToggles invokes getServiceToggles operation.
//
// Get Service Toggles.
//
// GET /v1/private/toggles
func (c *Client) GetServiceToggles(ctx context.Context) (*ServiceTogglesConfig, error) {
	res, err := c.sendGetServiceToggles(ctx)
	return res, err
}

func (c *Client) sendGetServiceToggles(ctx context.Context) (res *ServiceTogglesConfig, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getServiceToggles"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/private/toggles"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetServiceTogglesOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/toggles"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetServiceTogglesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetSpanById invokes getSpanById operation.
//
// Get span by id.
//
// GET /v1/private/spans/{id}
func (c *Client) GetSpanById(ctx context.Context, params GetSpanByIdParams) (GetSpanByIdRes, error) {
	res, err := c.sendGetSpanById(ctx, params)
	return res, err
}

func (c *Client) sendGetSpanById(ctx context.Context, params GetSpanByIdParams) (res GetSpanByIdRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getSpanById"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/private/spans/{id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetSpanByIdOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/private/spans/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "strip_attachments" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "strip_attachments",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.StripAttachments.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetSpanByIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetSpanComment invokes getSpanComment operation.
//
// Get span comment.
//
// GET /v1/private/spans/{spanId}/comments/{commentId}
func (c *Client) GetSpanComment(ctx context.Context, params GetSpanCommentParams) (GetSpanCommentRes, error) {
	res, err := c.sendGetSpanComment(ctx, params)
	return res, err
}

func (c *Client) sendGetSpanComment(ctx context.Context, params GetSpanCommentParams) (res GetSpanCommentRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getSpanComment"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/private/spans/{spanId}/comments/{commentId}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetSpanCommentOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/v1/private/spans/"
	{
		// Encode "spanId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "spanId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.SpanId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/comments/"
	{
		// Encode "commentId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "commentId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.CommentId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetSpanCommentResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetSpanStats invokes getSpanStats operation.
//
// Get span stats.
//
// GET /v1/private/spans/stats
func (c *Client) GetSpanStats(ctx context.Context, params GetSpanStatsParams) (*ProjectStatsPublic, error) {
	res, err := c.sendGetSpanStats(ctx, params)
	return res, err
}

func (c *Client) sendGetSpanStats(ctx context.Context, params GetSpanStatsParams) (res *ProjectStatsPublic, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getSpanStats"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/private/spans/stats"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetSpanStatsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/spans/stats"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "project_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "project_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ProjectID.Get(); ok {
				return e.EncodeValue(conv.UUIDToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "project_name" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "project_name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ProjectName.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "trace_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "trace_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.TraceID.Get(); ok {
				return e.EncodeValue(conv.UUIDToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Type.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filters" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filters",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Filters.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "from_time" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "from_time",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FromTime.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "to_time" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "to_time",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ToTime.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetSpanStatsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetSpansBiInfo invokes getSpansBiInfo operation.
//
// Get spans information for BI events per user per workspace.
//
// GET /v1/internal/usage/bi-spans
func (c *Client) GetSpansBiInfo(ctx context.Context) (*BiInformationResponse, error) {
	res, err := c.sendGetSpansBiInfo(ctx)
	return res, err
}

func (c *Client) sendGetSpansBiInfo(ctx context.Context) (res *BiInformationResponse, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getSpansBiInfo"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/internal/usage/bi-spans"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetSpansBiInfoOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/internal/usage/bi-spans"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetSpansBiInfoResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetSpansByProject invokes getSpansByProject operation.
//
// Get spans by project_name or project_id and optionally by trace_id and/or type.
//
// GET /v1/private/spans
func (c *Client) GetSpansByProject(ctx context.Context, params GetSpansByProjectParams) (*SpanPagePublic, error) {
	res, err := c.sendGetSpansByProject(ctx, params)
	return res, err
}

func (c *Client) sendGetSpansByProject(ctx context.Context, params GetSpansByProjectParams) (res *SpanPagePublic, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getSpansByProject"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/private/spans"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetSpansByProjectOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/spans"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Size.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "project_name" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "project_name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ProjectName.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "project_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "project_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ProjectID.Get(); ok {
				return e.EncodeValue(conv.UUIDToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "trace_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "trace_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.TraceID.Get(); ok {
				return e.EncodeValue(conv.UUIDToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Type.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filters" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filters",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Filters.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "truncate" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "truncate",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Truncate.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "strip_attachments" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "strip_attachments",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.StripAttachments.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sorting" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sorting",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Sorting.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "exclude" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "exclude",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Exclude.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "from_time" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "from_time",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FromTime.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "to_time" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "to_time",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ToTime.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetSpansByProjectResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetSpansCountForWorkspaces invokes getSpansCountForWorkspaces operation.
//
// Get spans count on previous day for all available workspaces.
//
// GET /v1/internal/usage/workspace-span-counts
func (c *Client) GetSpansCountForWorkspaces(ctx context.Context) (*SpansCountResponse, error) {
	res, err := c.sendGetSpansCountForWorkspaces(ctx)
	return res, err
}

func (c *Client) sendGetSpansCountForWorkspaces(ctx context.Context) (res *SpansCountResponse, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getSpansCountForWorkspaces"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/internal/usage/workspace-span-counts"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetSpansCountForWorkspacesOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/internal/usage/workspace-span-counts"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetSpansCountForWorkspacesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetStudioOptimizationById invokes getStudioOptimizationById operation.
//
// Get Studio optimization with config included.
//
// GET /v1/private/optimizations/studio/{id}
func (c *Client) GetStudioOptimizationById(ctx context.Context, params GetStudioOptimizationByIdParams) (GetStudioOptimizationByIdRes, error) {
	res, err := c.sendGetStudioOptimizationById(ctx, params)
	return res, err
}

func (c *Client) sendGetStudioOptimizationById(ctx context.Context, params GetStudioOptimizationByIdParams) (res GetStudioOptimizationByIdRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getStudioOptimizationById"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/private/optimizations/studio/{id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetStudioOptimizationByIdOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/private/optimizations/studio/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetStudioOptimizationByIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetStudioOptimizationLogs invokes getStudioOptimizationLogs operation.
//
// Get presigned S3 URL for downloading optimization logs.
//
// GET /v1/private/optimizations/studio/{id}/logs
func (c *Client) GetStudioOptimizationLogs(ctx context.Context, params GetStudioOptimizationLogsParams) (GetStudioOptimizationLogsRes, error) {
	res, err := c.sendGetStudioOptimizationLogs(ctx, params)
	return res, err
}

func (c *Client) sendGetStudioOptimizationLogs(ctx context.Context, params GetStudioOptimizationLogsParams) (res GetStudioOptimizationLogsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getStudioOptimizationLogs"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/private/optimizations/studio/{id}/logs"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetStudioOptimizationLogsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/private/optimizations/studio/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/logs"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetStudioOptimizationLogsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetThreadComment invokes getThreadComment operation.
//
// Get thread comment.
//
// GET /v1/private/traces/threads/{threadId}/comments/{commentId}
func (c *Client) GetThreadComment(ctx context.Context, params GetThreadCommentParams) (GetThreadCommentRes, error) {
	res, err := c.sendGetThreadComment(ctx, params)
	return res, err
}

func (c *Client) sendGetThreadComment(ctx context.Context, params GetThreadCommentParams) (res GetThreadCommentRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getThreadComment"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/private/traces/threads/{threadId}/comments/{commentId}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetThreadCommentOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/v1/private/traces/threads/"
	{
		// Encode "threadId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "threadId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ThreadId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/comments/"
	{
		// Encode "commentId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "commentId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.CommentId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetThreadCommentResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetTraceById invokes getTraceById operation.
//
// Get trace by id.
//
// GET /v1/private/traces/{id}
func (c *Client) GetTraceById(ctx context.Context, params GetTraceByIdParams) (*TracePublic, error) {
	res, err := c.sendGetTraceById(ctx, params)
	return res, err
}

func (c *Client) sendGetTraceById(ctx context.Context, params GetTraceByIdParams) (res *TracePublic, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getTraceById"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/private/traces/{id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetTraceByIdOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/private/traces/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "strip_attachments" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "strip_attachments",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.StripAttachments.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetTraceByIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetTraceComment invokes getTraceComment operation.
//
// Get trace comment.
//
// GET /v1/private/traces/{traceId}/comments/{commentId}
func (c *Client) GetTraceComment(ctx context.Context, params GetTraceCommentParams) (GetTraceCommentRes, error) {
	res, err := c.sendGetTraceComment(ctx, params)
	return res, err
}

func (c *Client) sendGetTraceComment(ctx context.Context, params GetTraceCommentParams) (res GetTraceCommentRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getTraceComment"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/private/traces/{traceId}/comments/{commentId}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetTraceCommentOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/v1/private/traces/"
	{
		// Encode "traceId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "traceId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.TraceId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/comments/"
	{
		// Encode "commentId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "commentId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.CommentId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetTraceCommentResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetTraceStats invokes getTraceStats operation.
//
// Get trace stats.
//
// GET /v1/private/traces/stats
func (c *Client) GetTraceStats(ctx context.Context, params GetTraceStatsParams) (*ProjectStatsPublic, error) {
	res, err := c.sendGetTraceStats(ctx, params)
	return res, err
}

func (c *Client) sendGetTraceStats(ctx context.Context, params GetTraceStatsParams) (res *ProjectStatsPublic, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getTraceStats"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/private/traces/stats"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetTraceStatsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/traces/stats"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "project_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "project_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ProjectID.Get(); ok {
				return e.EncodeValue(conv.UUIDToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "project_name" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "project_name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ProjectName.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filters" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filters",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Filters.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "from_time" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "from_time",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FromTime.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "to_time" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "to_time",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ToTime.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetTraceStatsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetTraceThread invokes getTraceThread operation.
//
// Get trace thread.
//
// POST /v1/private/traces/threads/retrieve
func (c *Client) GetTraceThread(ctx context.Context, request OptTraceThreadIdentifier) (GetTraceThreadRes, error) {
	res, err := c.sendGetTraceThread(ctx, request)
	return res, err
}

func (c *Client) sendGetTraceThread(ctx context.Context, request OptTraceThreadIdentifier) (res GetTraceThreadRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getTraceThread"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/private/traces/threads/retrieve"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetTraceThreadOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/traces/threads/retrieve"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetTraceThreadRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetTraceThreadResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetTraceThreadStats invokes getTraceThreadStats operation.
//
// Get trace thread stats.
//
// GET /v1/private/traces/threads/stats
func (c *Client) GetTraceThreadStats(ctx context.Context, params GetTraceThreadStatsParams) (*ProjectStatsPublic, error) {
	res, err := c.sendGetTraceThreadStats(ctx, params)
	return res, err
}

func (c *Client) sendGetTraceThreadStats(ctx context.Context, params GetTraceThreadStatsParams) (res *ProjectStatsPublic, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getTraceThreadStats"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/private/traces/threads/stats"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetTraceThreadStatsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/traces/threads/stats"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "project_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "project_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ProjectID.Get(); ok {
				return e.EncodeValue(conv.UUIDToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "project_name" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "project_name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ProjectName.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filters" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filters",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Filters.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "from_time" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "from_time",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FromTime.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "to_time" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "to_time",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ToTime.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetTraceThreadStatsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetTraceThreads invokes getTraceThreads operation.
//
// Get trace threads.
//
// GET /v1/private/traces/threads
func (c *Client) GetTraceThreads(ctx context.Context, params GetTraceThreadsParams) (*TraceThreadPage, error) {
	res, err := c.sendGetTraceThreads(ctx, params)
	return res, err
}

func (c *Client) sendGetTraceThreads(ctx context.Context, params GetTraceThreadsParams) (res *TraceThreadPage, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getTraceThreads"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/private/traces/threads"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetTraceThreadsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/traces/threads"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Size.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "project_name" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "project_name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ProjectName.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "project_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "project_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ProjectID.Get(); ok {
				return e.EncodeValue(conv.UUIDToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "truncate" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "truncate",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Truncate.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "strip_attachments" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "strip_attachments",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.StripAttachments.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filters" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filters",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Filters.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sorting" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sorting",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Sorting.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "from_time" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "from_time",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FromTime.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "to_time" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "to_time",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ToTime.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetTraceThreadsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetTracesBiInfo invokes getTracesBiInfo operation.
//
// Get traces information for BI events per user per workspace.
//
// GET /v1/internal/usage/bi-traces
func (c *Client) GetTracesBiInfo(ctx context.Context) (*BiInformationResponse, error) {
	res, err := c.sendGetTracesBiInfo(ctx)
	return res, err
}

func (c *Client) sendGetTracesBiInfo(ctx context.Context) (res *BiInformationResponse, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getTracesBiInfo"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/internal/usage/bi-traces"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetTracesBiInfoOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/internal/usage/bi-traces"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetTracesBiInfoResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetTracesByProject invokes getTracesByProject operation.
//
// Get traces by project_name or project_id.
//
// GET /v1/private/traces
func (c *Client) GetTracesByProject(ctx context.Context, params GetTracesByProjectParams) (*TracePagePublic, error) {
	res, err := c.sendGetTracesByProject(ctx, params)
	return res, err
}

func (c *Client) sendGetTracesByProject(ctx context.Context, params GetTracesByProjectParams) (res *TracePagePublic, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getTracesByProject"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/private/traces"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetTracesByProjectOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/traces"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Size.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "project_name" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "project_name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ProjectName.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "project_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "project_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ProjectID.Get(); ok {
				return e.EncodeValue(conv.UUIDToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filters" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filters",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Filters.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "truncate" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "truncate",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Truncate.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "strip_attachments" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "strip_attachments",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.StripAttachments.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sorting" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sorting",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Sorting.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "exclude" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "exclude",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Exclude.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "from_time" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "from_time",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FromTime.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "to_time" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "to_time",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ToTime.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetTracesByProjectResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetTracesCountForWorkspaces invokes getTracesCountForWorkspaces operation.
//
// Get traces count on previous day for all available workspaces.
//
// GET /v1/internal/usage/workspace-trace-counts
func (c *Client) GetTracesCountForWorkspaces(ctx context.Context) (*TraceCountResponse, error) {
	res, err := c.sendGetTracesCountForWorkspaces(ctx)
	return res, err
}

func (c *Client) sendGetTracesCountForWorkspaces(ctx context.Context) (res *TraceCountResponse, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getTracesCountForWorkspaces"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/internal/usage/workspace-trace-counts"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetTracesCountForWorkspacesOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/internal/usage/workspace-trace-counts"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetTracesCountForWorkspacesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetWebhookExamples invokes getWebhookExamples operation.
//
// Get webhook payload examples for all alert event types, optionally filtered by alert type.
//
// GET /v1/private/alerts/webhooks/examples
func (c *Client) GetWebhookExamples(ctx context.Context, params GetWebhookExamplesParams) (*WebhookExamples, error) {
	res, err := c.sendGetWebhookExamples(ctx, params)
	return res, err
}

func (c *Client) sendGetWebhookExamples(ctx context.Context, params GetWebhookExamplesParams) (res *WebhookExamples, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getWebhookExamples"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/private/alerts/webhooks/examples"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetWebhookExamplesOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/alerts/webhooks/examples"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "alert_type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "alert_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.AlertType.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetWebhookExamplesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetWelcomeWizardStatus invokes getWelcomeWizardStatus operation.
//
// Get welcome wizard tracking status for the current workspace.
//
// GET /v1/private/welcome-wizard
func (c *Client) GetWelcomeWizardStatus(ctx context.Context) (*WelcomeWizardTracking, error) {
	res, err := c.sendGetWelcomeWizardStatus(ctx)
	return res, err
}

func (c *Client) sendGetWelcomeWizardStatus(ctx context.Context) (res *WelcomeWizardTracking, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getWelcomeWizardStatus"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/private/welcome-wizard"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetWelcomeWizardStatusOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/welcome-wizard"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetWelcomeWizardStatusResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetWorkspaceConfiguration invokes getWorkspaceConfiguration operation.
//
// Get workspace configuration.
//
// GET /v1/private/workspaces/configurations
func (c *Client) GetWorkspaceConfiguration(ctx context.Context) (GetWorkspaceConfigurationRes, error) {
	res, err := c.sendGetWorkspaceConfiguration(ctx)
	return res, err
}

func (c *Client) sendGetWorkspaceConfiguration(ctx context.Context) (res GetWorkspaceConfigurationRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getWorkspaceConfiguration"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/private/workspaces/configurations"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetWorkspaceConfigurationOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/workspaces/configurations"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetWorkspaceConfigurationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetWorkspaceName invokes getWorkspaceName operation.
//
// User's default workspace name.
//
// GET /v1/private/auth/workspace
func (c *Client) GetWorkspaceName(ctx context.Context) (GetWorkspaceNameRes, error) {
	res, err := c.sendGetWorkspaceName(ctx)
	return res, err
}

func (c *Client) sendGetWorkspaceName(ctx context.Context) (res GetWorkspaceNameRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getWorkspaceName"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/private/auth/workspace"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetWorkspaceNameOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/auth/workspace"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetWorkspaceNameResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// IsAlive invokes isAlive operation.
//
// GET /is-alive/ping
func (c *Client) IsAlive(ctx context.Context) (*IsAliveDefStatusCode, error) {
	res, err := c.sendIsAlive(ctx)
	return res, err
}

func (c *Client) sendIsAlive(ctx context.Context) (res *IsAliveDefStatusCode, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("isAlive"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/is-alive/ping"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, IsAliveOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/is-alive/ping"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeIsAliveResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListDatasetVersions invokes listDatasetVersions operation.
//
// Get paginated list of versions for a dataset, ordered by creation time (newest first).
//
// GET /v1/private/datasets/{id}/versions
func (c *Client) ListDatasetVersions(ctx context.Context, params ListDatasetVersionsParams) (ListDatasetVersionsRes, error) {
	res, err := c.sendListDatasetVersions(ctx, params)
	return res, err
}

func (c *Client) sendListDatasetVersions(ctx context.Context, params ListDatasetVersionsParams) (res ListDatasetVersionsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listDatasetVersions"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/private/datasets/{id}/versions"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ListDatasetVersionsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/private/datasets/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/versions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Size.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListDatasetVersionsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MetricsSummary invokes metricsSummary operation.
//
// Get metrics summary.
//
// Deprecated: schema marks this operation as deprecated.
//
// POST /v1/private/workspaces/metrics/summaries
func (c *Client) MetricsSummary(ctx context.Context, request OptWorkspaceMetricsSummaryRequest) (MetricsSummaryRes, error) {
	res, err := c.sendMetricsSummary(ctx, request)
	return res, err
}

func (c *Client) sendMetricsSummary(ctx context.Context, request OptWorkspaceMetricsSummaryRequest) (res MetricsSummaryRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("metricsSummary"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/private/workspaces/metrics/summaries"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, MetricsSummaryOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/workspaces/metrics/summaries"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeMetricsSummaryRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeMetricsSummaryResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OpenTraceThread invokes openTraceThread operation.
//
// Open trace thread.
//
// PUT /v1/private/traces/threads/open
func (c *Client) OpenTraceThread(ctx context.Context, request OptTraceThreadIdentifier) error {
	_, err := c.sendOpenTraceThread(ctx, request)
	return err
}

func (c *Client) sendOpenTraceThread(ctx context.Context, request OptTraceThreadIdentifier) (res *OpenTraceThreadNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("openTraceThread"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.URLTemplateKey.String("/v1/private/traces/threads/open"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, OpenTraceThreadOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/traces/threads/open"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeOpenTraceThreadRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeOpenTraceThreadResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PatchDatasetItem invokes patchDatasetItem operation.
//
// Partially update dataset item by id. Only provided fields will be updated.
//
// PATCH /v1/private/datasets/items/{itemId}
func (c *Client) PatchDatasetItem(ctx context.Context, request OptDatasetItemWrite, params PatchDatasetItemParams) (PatchDatasetItemRes, error) {
	res, err := c.sendPatchDatasetItem(ctx, request, params)
	return res, err
}

func (c *Client) sendPatchDatasetItem(ctx context.Context, request OptDatasetItemWrite, params PatchDatasetItemParams) (res PatchDatasetItemRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("patchDatasetItem"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.URLTemplateKey.String("/v1/private/datasets/items/{itemId}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, PatchDatasetItemOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/private/datasets/items/"
	{
		// Encode "itemId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "itemId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ItemId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePatchDatasetItemRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePatchDatasetItemResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RemoveItemsFromAnnotationQueue invokes removeItemsFromAnnotationQueue operation.
//
// Remove items from annotation queue.
//
// POST /v1/private/annotation-queues/{id}/items/delete
func (c *Client) RemoveItemsFromAnnotationQueue(ctx context.Context, request OptAnnotationQueueItemIds, params RemoveItemsFromAnnotationQueueParams) (RemoveItemsFromAnnotationQueueRes, error) {
	res, err := c.sendRemoveItemsFromAnnotationQueue(ctx, request, params)
	return res, err
}

func (c *Client) sendRemoveItemsFromAnnotationQueue(ctx context.Context, request OptAnnotationQueueItemIds, params RemoveItemsFromAnnotationQueueParams) (res RemoveItemsFromAnnotationQueueRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("removeItemsFromAnnotationQueue"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/private/annotation-queues/{id}/items/delete"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, RemoveItemsFromAnnotationQueueOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/private/annotation-queues/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/items/delete"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeRemoveItemsFromAnnotationQueueRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeRemoveItemsFromAnnotationQueueResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RestoreDatasetVersion invokes restoreDatasetVersion operation.
//
// Restores the dataset to a previous version state. All draft items are replaced with items from the
// specified version. If the version is not the latest, a new version snapshot is created. If the
// version is the latest, only draft items are replaced (revert functionality).
//
// POST /v1/private/datasets/{id}/versions/restore
func (c *Client) RestoreDatasetVersion(ctx context.Context, request OptDatasetVersionRestorePublic, params RestoreDatasetVersionParams) (RestoreDatasetVersionRes, error) {
	res, err := c.sendRestoreDatasetVersion(ctx, request, params)
	return res, err
}

func (c *Client) sendRestoreDatasetVersion(ctx context.Context, request OptDatasetVersionRestorePublic, params RestoreDatasetVersionParams) (res RestoreDatasetVersionRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("restoreDatasetVersion"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/private/datasets/{id}/versions/restore"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, RestoreDatasetVersionOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/private/datasets/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/versions/restore"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeRestoreDatasetVersionRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeRestoreDatasetVersionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RestorePromptVersion invokes restorePromptVersion operation.
//
// Restore a prompt version by creating a new version with the content from the specified version.
//
// POST /v1/private/prompts/{promptId}/versions/{versionId}/restore
func (c *Client) RestorePromptVersion(ctx context.Context, params RestorePromptVersionParams) (RestorePromptVersionRes, error) {
	res, err := c.sendRestorePromptVersion(ctx, params)
	return res, err
}

func (c *Client) sendRestorePromptVersion(ctx context.Context, params RestorePromptVersionParams) (res RestorePromptVersionRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("restorePromptVersion"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/private/prompts/{promptId}/versions/{versionId}/restore"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, RestorePromptVersionOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/v1/private/prompts/"
	{
		// Encode "promptId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "promptId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.PromptId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/versions/"
	{
		// Encode "versionId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "versionId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.VersionId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/restore"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeRestorePromptVersionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RetrieveProject invokes retrieveProject operation.
//
// Retrieve project.
//
// POST /v1/private/projects/retrieve
func (c *Client) RetrieveProject(ctx context.Context, request OptProjectRetrieveDetailed) (RetrieveProjectRes, error) {
	res, err := c.sendRetrieveProject(ctx, request)
	return res, err
}

func (c *Client) sendRetrieveProject(ctx context.Context, request OptProjectRetrieveDetailed) (res RetrieveProjectRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("retrieveProject"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/private/projects/retrieve"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, RetrieveProjectOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/projects/retrieve"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeRetrieveProjectRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeRetrieveProjectResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RetrievePromptVersion invokes retrievePromptVersion operation.
//
// Retrieve prompt version.
//
// POST /v1/private/prompts/versions/retrieve
func (c *Client) RetrievePromptVersion(ctx context.Context, request OptPromptVersionRetrieveDetail) (RetrievePromptVersionRes, error) {
	res, err := c.sendRetrievePromptVersion(ctx, request)
	return res, err
}

func (c *Client) sendRetrievePromptVersion(ctx context.Context, request OptPromptVersionRetrieveDetail) (res RetrievePromptVersionRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("retrievePromptVersion"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/private/prompts/versions/retrieve"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, RetrievePromptVersionOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/prompts/versions/retrieve"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeRetrievePromptVersionRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeRetrievePromptVersionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ScoreBatchOfSpans invokes scoreBatchOfSpans operation.
//
// Batch feedback scoring for spans.
//
// PUT /v1/private/spans/feedback-scores
func (c *Client) ScoreBatchOfSpans(ctx context.Context, request OptFeedbackScoreBatch) error {
	_, err := c.sendScoreBatchOfSpans(ctx, request)
	return err
}

func (c *Client) sendScoreBatchOfSpans(ctx context.Context, request OptFeedbackScoreBatch) (res *ScoreBatchOfSpansNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("scoreBatchOfSpans"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.URLTemplateKey.String("/v1/private/spans/feedback-scores"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ScoreBatchOfSpansOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/spans/feedback-scores"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeScoreBatchOfSpansRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeScoreBatchOfSpansResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ScoreBatchOfThreads invokes scoreBatchOfThreads operation.
//
// Batch feedback scoring for threads.
//
// PUT /v1/private/traces/threads/feedback-scores
func (c *Client) ScoreBatchOfThreads(ctx context.Context, request OptFeedbackScoreBatchThread) error {
	_, err := c.sendScoreBatchOfThreads(ctx, request)
	return err
}

func (c *Client) sendScoreBatchOfThreads(ctx context.Context, request OptFeedbackScoreBatchThread) (res *ScoreBatchOfThreadsNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("scoreBatchOfThreads"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.URLTemplateKey.String("/v1/private/traces/threads/feedback-scores"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ScoreBatchOfThreadsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/traces/threads/feedback-scores"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeScoreBatchOfThreadsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeScoreBatchOfThreadsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ScoreBatchOfTraces invokes scoreBatchOfTraces operation.
//
// Batch feedback scoring for traces.
//
// PUT /v1/private/traces/feedback-scores
func (c *Client) ScoreBatchOfTraces(ctx context.Context, request OptFeedbackScoreBatch) error {
	_, err := c.sendScoreBatchOfTraces(ctx, request)
	return err
}

func (c *Client) sendScoreBatchOfTraces(ctx context.Context, request OptFeedbackScoreBatch) (res *ScoreBatchOfTracesNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("scoreBatchOfTraces"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.URLTemplateKey.String("/v1/private/traces/feedback-scores"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ScoreBatchOfTracesOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/traces/feedback-scores"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeScoreBatchOfTracesRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeScoreBatchOfTracesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// StartMultiPartUpload invokes startMultiPartUpload operation.
//
// Start multipart attachment upload.
//
// POST /v1/private/attachment/upload-start
func (c *Client) StartMultiPartUpload(ctx context.Context, request OptStartMultipartUploadRequest) (StartMultiPartUploadRes, error) {
	res, err := c.sendStartMultiPartUpload(ctx, request)
	return res, err
}

func (c *Client) sendStartMultiPartUpload(ctx context.Context, request OptStartMultipartUploadRequest) (res StartMultiPartUploadRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("startMultiPartUpload"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/private/attachment/upload-start"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, StartMultiPartUploadOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/attachment/upload-start"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeStartMultiPartUploadRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeStartMultiPartUploadResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// StoreLlmProviderApiKey invokes storeLlmProviderApiKey operation.
//
// Store LLM Provider's ApiKey.
//
// POST /v1/private/llm-provider-key
func (c *Client) StoreLlmProviderApiKey(ctx context.Context, request OptProviderApiKeyWrite) (StoreLlmProviderApiKeyRes, error) {
	res, err := c.sendStoreLlmProviderApiKey(ctx, request)
	return res, err
}

func (c *Client) sendStoreLlmProviderApiKey(ctx context.Context, request OptProviderApiKeyWrite) (res StoreLlmProviderApiKeyRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("storeLlmProviderApiKey"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/private/llm-provider-key"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, StoreLlmProviderApiKeyOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/llm-provider-key"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeStoreLlmProviderApiKeyRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeStoreLlmProviderApiKeyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SubmitWelcomeWizard invokes submitWelcomeWizard operation.
//
// Submit welcome wizard with user information.
//
// POST /v1/private/welcome-wizard
func (c *Client) SubmitWelcomeWizard(ctx context.Context, request OptWelcomeWizardSubmission) error {
	_, err := c.sendSubmitWelcomeWizard(ctx, request)
	return err
}

func (c *Client) sendSubmitWelcomeWizard(ctx context.Context, request OptWelcomeWizardSubmission) (res *SubmitWelcomeWizardNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("submitWelcomeWizard"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/private/welcome-wizard"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SubmitWelcomeWizardOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/welcome-wizard"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSubmitWelcomeWizardRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSubmitWelcomeWizardResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TestWebhook invokes testWebhook operation.
//
// Test alert webhook.
//
// POST /v1/private/alerts/webhooks/tests
func (c *Client) TestWebhook(ctx context.Context, request OptAlertWrite) (TestWebhookRes, error) {
	res, err := c.sendTestWebhook(ctx, request)
	return res, err
}

func (c *Client) sendTestWebhook(ctx context.Context, request OptAlertWrite) (res TestWebhookRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("testWebhook"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/private/alerts/webhooks/tests"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, TestWebhookOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/alerts/webhooks/tests"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeTestWebhookRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTestWebhookResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateAlert invokes updateAlert operation.
//
// Update alert.
//
// PUT /v1/private/alerts/{id}
func (c *Client) UpdateAlert(ctx context.Context, request OptAlertWrite, params UpdateAlertParams) (UpdateAlertRes, error) {
	res, err := c.sendUpdateAlert(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateAlert(ctx context.Context, request OptAlertWrite, params UpdateAlertParams) (res UpdateAlertRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("updateAlert"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.URLTemplateKey.String("/v1/private/alerts/{id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UpdateAlertOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/private/alerts/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateAlertRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateAlertResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateAnnotationQueue invokes updateAnnotationQueue operation.
//
// Update annotation queue by id.
//
// PATCH /v1/private/annotation-queues/{id}
func (c *Client) UpdateAnnotationQueue(ctx context.Context, request OptAnnotationQueueUpdate, params UpdateAnnotationQueueParams) (UpdateAnnotationQueueRes, error) {
	res, err := c.sendUpdateAnnotationQueue(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateAnnotationQueue(ctx context.Context, request OptAnnotationQueueUpdate, params UpdateAnnotationQueueParams) (res UpdateAnnotationQueueRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("updateAnnotationQueue"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.URLTemplateKey.String("/v1/private/annotation-queues/{id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UpdateAnnotationQueueOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/private/annotation-queues/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateAnnotationQueueRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateAnnotationQueueResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateAutomationRuleEvaluator invokes updateAutomationRuleEvaluator operation.
//
// Update Automation Rule Evaluator by id.
//
// PATCH /v1/private/automations/evaluators/{id}
func (c *Client) UpdateAutomationRuleEvaluator(ctx context.Context, request OptAutomationRuleEvaluatorUpdate, params UpdateAutomationRuleEvaluatorParams) error {
	_, err := c.sendUpdateAutomationRuleEvaluator(ctx, request, params)
	return err
}

func (c *Client) sendUpdateAutomationRuleEvaluator(ctx context.Context, request OptAutomationRuleEvaluatorUpdate, params UpdateAutomationRuleEvaluatorParams) (res *UpdateAutomationRuleEvaluatorNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("updateAutomationRuleEvaluator"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.URLTemplateKey.String("/v1/private/automations/evaluators/{id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UpdateAutomationRuleEvaluatorOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/private/automations/evaluators/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateAutomationRuleEvaluatorRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateAutomationRuleEvaluatorResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateDashboard invokes updateDashboard operation.
//
// Update dashboard by id. Partial updates are supported - only provided fields will be updated.
//
// PATCH /v1/private/dashboards/{dashboardId}
func (c *Client) UpdateDashboard(ctx context.Context, request OptDashboardUpdatePublic, params UpdateDashboardParams) (UpdateDashboardRes, error) {
	res, err := c.sendUpdateDashboard(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateDashboard(ctx context.Context, request OptDashboardUpdatePublic, params UpdateDashboardParams) (res UpdateDashboardRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("updateDashboard"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.URLTemplateKey.String("/v1/private/dashboards/{dashboardId}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UpdateDashboardOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/private/dashboards/"
	{
		// Encode "dashboardId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "dashboardId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.DashboardId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateDashboardRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateDashboardResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateDataset invokes updateDataset operation.
//
// Update dataset by id.
//
// PUT /v1/private/datasets/{id}
func (c *Client) UpdateDataset(ctx context.Context, request OptDatasetUpdate, params UpdateDatasetParams) error {
	_, err := c.sendUpdateDataset(ctx, request, params)
	return err
}

func (c *Client) sendUpdateDataset(ctx context.Context, request OptDatasetUpdate, params UpdateDatasetParams) (res *UpdateDatasetNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("updateDataset"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.URLTemplateKey.String("/v1/private/datasets/{id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UpdateDatasetOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/private/datasets/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateDatasetRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateDatasetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateDatasetVersion invokes updateDatasetVersion operation.
//
// Update a dataset version's change_description and/or add new tags.
//
// PATCH /v1/private/datasets/{id}/versions/hash/{versionHash}
func (c *Client) UpdateDatasetVersion(ctx context.Context, request OptDatasetVersionUpdatePublic, params UpdateDatasetVersionParams) (UpdateDatasetVersionRes, error) {
	res, err := c.sendUpdateDatasetVersion(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateDatasetVersion(ctx context.Context, request OptDatasetVersionUpdatePublic, params UpdateDatasetVersionParams) (res UpdateDatasetVersionRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("updateDatasetVersion"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.URLTemplateKey.String("/v1/private/datasets/{id}/versions/hash/{versionHash}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UpdateDatasetVersionOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/v1/private/datasets/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/versions/hash/"
	{
		// Encode "versionHash" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "versionHash",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.VersionHash))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateDatasetVersionRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateDatasetVersionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateExperiment invokes updateExperiment operation.
//
// Update experiment by id.
//
// PATCH /v1/private/experiments/{id}
func (c *Client) UpdateExperiment(ctx context.Context, request OptExperimentUpdate, params UpdateExperimentParams) (UpdateExperimentRes, error) {
	res, err := c.sendUpdateExperiment(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateExperiment(ctx context.Context, request OptExperimentUpdate, params UpdateExperimentParams) (res UpdateExperimentRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("updateExperiment"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.URLTemplateKey.String("/v1/private/experiments/{id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UpdateExperimentOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/private/experiments/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateExperimentRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateExperimentResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateFeedbackDefinition invokes updateFeedbackDefinition operation.
//
// Update feedback definition by id.
//
// PUT /v1/private/feedback-definitions/{id}
func (c *Client) UpdateFeedbackDefinition(ctx context.Context, request OptFeedbackUpdate, params UpdateFeedbackDefinitionParams) error {
	_, err := c.sendUpdateFeedbackDefinition(ctx, request, params)
	return err
}

func (c *Client) sendUpdateFeedbackDefinition(ctx context.Context, request OptFeedbackUpdate, params UpdateFeedbackDefinitionParams) (res *UpdateFeedbackDefinitionNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("updateFeedbackDefinition"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.URLTemplateKey.String("/v1/private/feedback-definitions/{id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UpdateFeedbackDefinitionOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/private/feedback-definitions/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateFeedbackDefinitionRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateFeedbackDefinitionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateLlmProviderApiKey invokes updateLlmProviderApiKey operation.
//
// Update LLM Provider's ApiKey.
//
// PATCH /v1/private/llm-provider-key/{id}
func (c *Client) UpdateLlmProviderApiKey(ctx context.Context, request OptProviderApiKeyUpdate, params UpdateLlmProviderApiKeyParams) (UpdateLlmProviderApiKeyRes, error) {
	res, err := c.sendUpdateLlmProviderApiKey(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateLlmProviderApiKey(ctx context.Context, request OptProviderApiKeyUpdate, params UpdateLlmProviderApiKeyParams) (res UpdateLlmProviderApiKeyRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("updateLlmProviderApiKey"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.URLTemplateKey.String("/v1/private/llm-provider-key/{id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UpdateLlmProviderApiKeyOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/private/llm-provider-key/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateLlmProviderApiKeyRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateLlmProviderApiKeyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateOptimizationsById invokes updateOptimizationsById operation.
//
// Update optimization by id.
//
// PUT /v1/private/optimizations/{id}
func (c *Client) UpdateOptimizationsById(ctx context.Context, request OptOptimizationUpdate, params UpdateOptimizationsByIdParams) error {
	_, err := c.sendUpdateOptimizationsById(ctx, request, params)
	return err
}

func (c *Client) sendUpdateOptimizationsById(ctx context.Context, request OptOptimizationUpdate, params UpdateOptimizationsByIdParams) (res *UpdateOptimizationsByIdNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("updateOptimizationsById"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.URLTemplateKey.String("/v1/private/optimizations/{id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UpdateOptimizationsByIdOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/private/optimizations/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateOptimizationsByIdRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateOptimizationsByIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateProject invokes updateProject operation.
//
// Update project by id.
//
// PATCH /v1/private/projects/{id}
func (c *Client) UpdateProject(ctx context.Context, request OptProjectUpdate, params UpdateProjectParams) (UpdateProjectRes, error) {
	res, err := c.sendUpdateProject(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateProject(ctx context.Context, request OptProjectUpdate, params UpdateProjectParams) (res UpdateProjectRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("updateProject"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.URLTemplateKey.String("/v1/private/projects/{id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UpdateProjectOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/private/projects/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateProjectRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateProjectResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdatePrompt invokes updatePrompt operation.
//
// Update prompt.
//
// PUT /v1/private/prompts/{id}
func (c *Client) UpdatePrompt(ctx context.Context, request OptPromptUpdatable, params UpdatePromptParams) (UpdatePromptRes, error) {
	res, err := c.sendUpdatePrompt(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdatePrompt(ctx context.Context, request OptPromptUpdatable, params UpdatePromptParams) (res UpdatePromptRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("updatePrompt"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.URLTemplateKey.String("/v1/private/prompts/{id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UpdatePromptOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/private/prompts/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdatePromptRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdatePromptResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdatePromptVersions invokes updatePromptVersions operation.
//
// Update one or more prompt versions.
// Note: Prompt versions are immutable by design.
// Only organizational properties, such as tags etc., can be updated.
// Core properties like template and metadata cannot be modified after creation.
// PATCH semantics:
// - non-empty values update the field
// - null values preserve existing field values (no change)
// - empty values explicitly clear the field.
//
// PATCH /v1/private/prompts/versions
func (c *Client) UpdatePromptVersions(ctx context.Context, request OptPromptVersionBatchUpdate) (UpdatePromptVersionsRes, error) {
	res, err := c.sendUpdatePromptVersions(ctx, request)
	return res, err
}

func (c *Client) sendUpdatePromptVersions(ctx context.Context, request OptPromptVersionBatchUpdate) (res UpdatePromptVersionsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("updatePromptVersions"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.URLTemplateKey.String("/v1/private/prompts/versions"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UpdatePromptVersionsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/prompts/versions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdatePromptVersionsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdatePromptVersionsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateSpan invokes updateSpan operation.
//
// Update span by id.
//
// PATCH /v1/private/spans/{id}
func (c *Client) UpdateSpan(ctx context.Context, request OptSpanUpdate, params UpdateSpanParams) (UpdateSpanRes, error) {
	res, err := c.sendUpdateSpan(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateSpan(ctx context.Context, request OptSpanUpdate, params UpdateSpanParams) (res UpdateSpanRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("updateSpan"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.URLTemplateKey.String("/v1/private/spans/{id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UpdateSpanOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/private/spans/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateSpanRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateSpanResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateSpanComment invokes updateSpanComment operation.
//
// Update span comment by id.
//
// PATCH /v1/private/spans/comments/{commentId}
func (c *Client) UpdateSpanComment(ctx context.Context, request OptComment, params UpdateSpanCommentParams) (UpdateSpanCommentRes, error) {
	res, err := c.sendUpdateSpanComment(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateSpanComment(ctx context.Context, request OptComment, params UpdateSpanCommentParams) (res UpdateSpanCommentRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("updateSpanComment"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.URLTemplateKey.String("/v1/private/spans/comments/{commentId}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UpdateSpanCommentOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/private/spans/comments/"
	{
		// Encode "commentId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "commentId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.CommentId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateSpanCommentRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateSpanCommentResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateThread invokes updateThread operation.
//
// Update thread.
//
// PATCH /v1/private/traces/threads/{threadModelId}
func (c *Client) UpdateThread(ctx context.Context, request OptTraceThreadUpdate, params UpdateThreadParams) (UpdateThreadRes, error) {
	res, err := c.sendUpdateThread(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateThread(ctx context.Context, request OptTraceThreadUpdate, params UpdateThreadParams) (res UpdateThreadRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("updateThread"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.URLTemplateKey.String("/v1/private/traces/threads/{threadModelId}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UpdateThreadOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/private/traces/threads/"
	{
		// Encode "threadModelId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "threadModelId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ThreadModelId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateThreadRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateThreadResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateThreadComment invokes updateThreadComment operation.
//
// Update thread comment by id.
//
// PATCH /v1/private/traces/threads/comments/{commentId}
func (c *Client) UpdateThreadComment(ctx context.Context, request OptComment, params UpdateThreadCommentParams) (UpdateThreadCommentRes, error) {
	res, err := c.sendUpdateThreadComment(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateThreadComment(ctx context.Context, request OptComment, params UpdateThreadCommentParams) (res UpdateThreadCommentRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("updateThreadComment"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.URLTemplateKey.String("/v1/private/traces/threads/comments/{commentId}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UpdateThreadCommentOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/private/traces/threads/comments/"
	{
		// Encode "commentId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "commentId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.CommentId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateThreadCommentRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateThreadCommentResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateTrace invokes updateTrace operation.
//
// Update trace by id.
//
// PATCH /v1/private/traces/{id}
func (c *Client) UpdateTrace(ctx context.Context, request OptTraceUpdate, params UpdateTraceParams) error {
	_, err := c.sendUpdateTrace(ctx, request, params)
	return err
}

func (c *Client) sendUpdateTrace(ctx context.Context, request OptTraceUpdate, params UpdateTraceParams) (res *UpdateTraceNoContent, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("updateTrace"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.URLTemplateKey.String("/v1/private/traces/{id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UpdateTraceOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/private/traces/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateTraceRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateTraceResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateTraceComment invokes updateTraceComment operation.
//
// Update trace comment by id.
//
// PATCH /v1/private/traces/comments/{commentId}
func (c *Client) UpdateTraceComment(ctx context.Context, request OptComment, params UpdateTraceCommentParams) (UpdateTraceCommentRes, error) {
	res, err := c.sendUpdateTraceComment(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateTraceComment(ctx context.Context, request OptComment, params UpdateTraceCommentParams) (res UpdateTraceCommentRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("updateTraceComment"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.URLTemplateKey.String("/v1/private/traces/comments/{commentId}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UpdateTraceCommentOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/private/traces/comments/"
	{
		// Encode "commentId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "commentId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.CommentId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateTraceCommentRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateTraceCommentResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpsertOptimization invokes upsertOptimization operation.
//
// Upsert optimization.
//
// PUT /v1/private/optimizations
func (c *Client) UpsertOptimization(ctx context.Context, request OptOptimizationWrite) (*UpsertOptimizationCreated, error) {
	res, err := c.sendUpsertOptimization(ctx, request)
	return res, err
}

func (c *Client) sendUpsertOptimization(ctx context.Context, request OptOptimizationWrite) (res *UpsertOptimizationCreated, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("upsertOptimization"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.URLTemplateKey.String("/v1/private/optimizations"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UpsertOptimizationOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/optimizations"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpsertOptimizationRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpsertOptimizationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpsertWorkspaceConfiguration invokes upsertWorkspaceConfiguration operation.
//
// Upsert workspace configuration.
//
// PUT /v1/private/workspaces/configurations
func (c *Client) UpsertWorkspaceConfiguration(ctx context.Context, request OptWorkspaceConfiguration) (UpsertWorkspaceConfigurationRes, error) {
	res, err := c.sendUpsertWorkspaceConfiguration(ctx, request)
	return res, err
}

func (c *Client) sendUpsertWorkspaceConfiguration(ctx context.Context, request OptWorkspaceConfiguration) (res UpsertWorkspaceConfigurationRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("upsertWorkspaceConfiguration"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.URLTemplateKey.String("/v1/private/workspaces/configurations"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UpsertWorkspaceConfigurationOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/private/workspaces/configurations"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpsertWorkspaceConfigurationRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpsertWorkspaceConfigurationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// Version invokes version operation.
//
// GET /is-alive/ver
func (c *Client) Version(ctx context.Context) (*VersionDefStatusCode, error) {
	res, err := c.sendVersion(ctx)
	return res, err
}

func (c *Client) sendVersion(ctx context.Context) (res *VersionDefStatusCode, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("version"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/is-alive/ver"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, VersionOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/is-alive/ver"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeVersionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}
